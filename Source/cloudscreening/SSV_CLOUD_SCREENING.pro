;**************************************************************************************
;**************************************************************************************
;*
;* NAME:
;*      SSV_CLOUD_SCREENING 
;* 
;* PURPOSE:
;*      SCREEN CLOUD OF A GIVEN SENSOR THROUGH SPATIAL SCALE VARIABILITY (SSV) METHOD OVER PSEUDO INVARIANT CALIBRATION SITE 
;*
;* CALLING SEQUENCE:
;       RES=SSV_CLOUD_SCREENING(OUTPUT_FOLDER, REGION, SENSOR, PROC_VER,$
;*                              ROI_PERCENTAGE, DECIMAL_YEAR_START, DECIMAL_YEAR_STOP, SSV_BAND, $
;*                              VERBOSE=VERBOSE, SKIP_TRAINING=SKIP_TRAINING)
;* 
;* INPUTS:
;*      OUTPUT_FOLDER      - THE FULL PATH OF THE OUTPUT FOLDER REQUIRED
;*      REGION             - A STRING OF THE DIMITRI VALIDATION SITE
;*      SENSOR             - A STRING OF THE SENSOR TO BE UTILISED
;*      PROC_VER           - A STRING OF THE SENSOR PROCESSING VERSION TO BE UTILISED
;*      ROI_PERCENTAGE     - A FLOAT OF THE ACCEPTABLE ROI COVERAGE PERCENTAGE (0-100)
;*      DECIMAL_YEAR_START - START DECIMAL YEAR OF THE PERIOD TO BE UTILISED
;*      DECIMAL_YEAR_STOP  - STOP DECIMAL YEAR OF THE PERIOD TO BE UTILISED
;*      SSV_BAND           - BAND USED IN THE STANDART-DEVIATION
;*
;* KEYWORDS:
;*      VERBOSE       - PROCESSING STATUS OUTPUTS
;*      SKIP_TRAINING - SKIP THE TRAINING STAGE (NEEDS TO HAVE PERFORM IT ALREADY ONCE)
;*
;* OUTPUTS:
;*      STATUS   - 1: NOMINAL OUTPUT, 0 OR -1 ERROR ENCOUNTERED
;*
;* COMMON BLOCKS:
;*      NONE
;*
;* MODIFICATION HISTORY:
;*      17 FEB 2014 - C MAZERAN   - FIRST IMPLEMENTATION
;*      10 DEC 2014 - B ALHAMMOUD - ADD CREATE/UPDATE CLOUD TRAINING FILES
;*      04 JUN 2015 - NCG / MAGELLIUM - UPDATE DATABASE FIELDS WITH DIMITRI V4 SPECIFICATIONS
;*                                      REPLACE TOA_REF.DAT INPUT FILE BY NCDF INGESTION INPUT FILES
;*
;* VALIDATION HISTORY:
;*      17 FEB 2014 - C MAZERAN   - LINUX 64BIT MACHINE IDL 8.2: COMPILATION AND OPERATION SUCCESSFUL
;*      10 DEC 2014 - B ALHAMMOUD - LINUX 64BIT MACHINE IDL 8.2: COMPILATION AND OPERATION SUCCESSFUL
;*
;**************************************************************************************
;**************************************************************************************

FUNCTION GET_SSV_BAND_VALUES_FROM_NCDF_INGESTION_FILE, NCDF_FILENAME, SSV_BAND, SSV_BAND_VALUES=SSV_BAND_VALUES, NPIX=NPIX, VERBOSE=VERBOSE

  FCT_NAME = 'GET_SSV_BAND_VALUES_FROM_NCDF_INGESTION_FILE'
  
  STATUS_OK = GET_DIMITRI_LOCATION('STATUS_OK')
  STATUS_NODATA = GET_DIMITRI_LOCATION('STATUS_NODATA')
  MISSING_VALUE_FLT = GET_DIMITRI_LOCATION('NCDF_MISSING_VALUE')
  
  NCDF_INFOS = FILE_INFO(NCDF_FILENAME)
  
  IF NCDF_INFOS.EXISTS EQ 0 OR STRLEN(NCDF_FILENAME) EQ 0 THEN BEGIN
    IF KEYWORD_SET(VERBOSE) THEN PRINT,FCT_NAME + ': FILE ',NCDF_FILENAME,' IS MISSING, PLEASE CHECK YOUR INGESTION PROGRESS'
    RETURN, STATUS_NODATA
  ENDIF

  ;----------------------
  ; READ INPUT INGESTION FILE
  
  STATUS = NETCDFREAD_INGEST_OUTPUT( NCDF_FILENAME, NCDF_INGEST_STRUCT=NCDF_INGEST_STRUCT, VERBOSE=VERBOSE)
  IF STATUS NE STATUS_OK THEN BEGIN
    IF KEYWORD_SET(VERBOSE) THEN BEGIN
      PRINT, FCT_NAME + ': ERROR DURING ', FILE_BASENAME(NCDF_FILENAME),' FILE READING >> FILE SKIPPED'
    ENDIF
    RETURN, STATUS_NODATA
  ENDIF  

;----------------------------------------
; RETRIEVE BANDS AND DIRECTION NUMBER

  NB_DIRECTIONS = SENSOR_DIRECTION_INFO(NCDF_INGEST_STRUCT.GLOBAL_ATT.SENSOR)
  NB_DIRECTIONS = NB_DIRECTIONS[0]
  

  ; GET TOA VALUES FOR SSV_BAND ACROSS DIRECTIONS (SELECT DIRECTION WITH MAXIMUM CLEAR PIXELS)
  ;----------------------
  
  ; LOOP OVER VIEWING DIRECTION        
  AT_LEAST_ONE_DIR = 0    
  COUNT_CLEAR_PIX = LONARR(NB_DIRECTIONS)
  FOR NUM_DIR=0, NB_DIRECTIONS-1 DO BEGIN

    IDX_CLEAR = WHERE(NCDF_INGEST_STRUCT.VARIABLES.AUTO_CS_1_MASK[*,NUM_DIR] EQ 0, COUNT)
    COUNT_CLEAR_PIX[NUM_DIR] = COUNT

    IF NCDF_INGEST_STRUCT.VARIABLES.ROI_STATUS[NUM_DIR] EQ 0 OR COUNT_CLEAR_PIX[NUM_DIR] EQ 0 THEN BEGIN
      IF KEYWORD_SET(VERBOSE) THEN PRINT, FCT_NAME + ': ROI STATUS WITH 0 VALUE OR NO CLEAR PIXEL >> DIRECTION SKIPPED'
      COUNT_CLEAR_PIX[NUM_DIR] = 0
      GOTO, INIT_NEXT_DIR
    ENDIF

    AT_LEAST_ONE_DIR = 1      
    INIT_NEXT_DIR:

  ENDFOR ; END LOOP ON VIEWING DIRECTION

  IF AT_LEAST_ONE_DIR NE 1 THEN RETURN, STATUS_NODATA
    
  ; GET DIRECTION WITH MAXIMUM CLEAR PIXELS

; FIX DIRECTION USED TO LAST DIRECTION (AS FOR DIMITRI V3.1.1)
; TO BE UPDATED BY ARGANS IF NEEDED
;---------------------------------
;  NPIX = MAX(COUNT_CLEAR_PIX, MAX_COUNT_IDX)
MAX_COUNT_IDX = [NB_DIRECTIONS-1]
NPIX = COUNT_CLEAR_PIX[NB_DIRECTIONS-1]

  IDX_CLEAR = WHERE(NCDF_INGEST_STRUCT.VARIABLES.AUTO_CS_1_MASK[*,MAX_COUNT_IDX[0]] EQ 0)
  SSV_BAND_VALUES = REFORM(NCDF_INGEST_STRUCT.VARIABLES.REFL_BAND[IDX_CLEAR, MAX_COUNT_IDX[0], SSV_BAND], NPIX)
  
  IDX = WHERE(SSV_BAND_VALUES EQ MISSING_VALUE_FLT, COUNT)
  IF COUNT NE 0 THEN PRINT, FCT_NAME + '=============== ATTENTION ==== VALEURS INVALIDES !!!========'        

;        ID = WHERE(ABS(SENSOR_L1B_REF_PIX[0,*]-DB_DATA_CT.DECIMAL_YEAR[RES[IT]]) LE TOL AND $
;                SENSOR_L1B_REF_PIX[NUM_NON_REF+SSV_BAND,*] NE -999., NPIX)
;        IF NPIX EQ 0 THEN CONTINUE
        
;----------------------------------------
; DEAL WITH SEVERAL DIRECTION OR POSSIBLE DOUBLONS IN DB BY TAKING LAST PIXELS
; THIS IS AN APPROXIMATION AS INFO ON NUMBER OF PIXEL PER DIRECTION IS UNKNOWN

;        IF NPIX NE FIX(DB_DATA_CT.ROI_PIX_NUM[RES[IT]]) THEN BEGIN
;          ID = ID[NPIX-FIX(DB_DATA_CT.ROI_PIX_NUM[RES[IT]]):NPIX-1]
;          NPIX = FIX(DB_DATA_CT.ROI_PIX_NUM[RES[IT]])
;        ENDIF

  RETURN, STATUS_OK
    
END




FUNCTION SSV_CLOUD_SCREENING, OUTPUT_FOLDER, REGION, SENSOR, PROC_VER,$
                              ROI_PERCENTAGE, DECIMAL_YEAR_START, DECIMAL_YEAR_STOP, SSV_BAND, $
                              VERBOSE=VERBOSE, SKIP_TRAINING=SKIP_TRAINING


  STATUS_OK = GET_DIMITRI_LOCATION('STATUS_OK')
  STATUS_ERROR = GET_DIMITRI_LOCATION('STATUS_ERROR')
  STATUS_NODATA = GET_DIMITRI_LOCATION('STATUS_NODATA')

;-----------------------------------------
; DEFINE CURRENT FUNCTION NAME
; AND SOME NUMERICAL CONSTANTS

  FCT_NAME    = 'SSV_CLOUD_SCREENING'
  TOL         = 0.000001 ; TOLERANCE FOR FLOAT COMPARISON

;-----------------------------------------
; CHECKS INPUT CRITERIA ARE OK

  RP_LIMIT = FLOAT(ROI_PERCENTAGE)*0.01
  IF RP_LIMIT GT  1.0 OR RP_LIMIT LT 0.0 THEN BEGIN
    PRINT, FCT_NAME+': ERROR, ROI CRITERIA OUT OF RANGE'
    RETURN, STATUS_ERROR
  ENDIF

;----------------------------------------
; RETRIEVE WAVELENGTH

  SSV_WAV = GET_SENSOR_BAND_NAME(SENSOR,SSV_BAND)

;-----------------------------------------
; DEFINE INPUT/OUTPUT FILES AND DIRECTORIES

  IF KEYWORD_SET(VERBOSE) THEN PRINT,FCT_NAME+': DEFINING INPUT/OUTPUT FILES'
  SITE_FILE  = GET_DIMITRI_LOCATION('SITE_DATA')
  DB_FILE    = GET_DIMITRI_LOCATION('DATABASE')
  MAIN_DIRC  = GET_DIMITRI_LOCATION('DIMITRI')
  DL         = GET_DIMITRI_LOCATION('DL')
  IDIR       = GET_DIMITRI_LOCATION('INGESTION_OUTPUT')+DL+'Site_'+REGION+DL+SENSOR+DL+'Proc_'+PROC_VER

;  IDIR       = FILEPATH('',ROOT_DIR=MAIN_DIRC, SUBDIRECTORY=['Input','Site_'+REGION,SENSOR,'Proc_'+PROC_VER])
;  IFILE      = FILEPATH(ROOT_DIR=IDIR, SENSOR+'_TOA_REF_PIX.dat')

  SSV_CS_LOG = FILEPATH(ROOT_DIR=OUTPUT_FOLDER, 'SSV_CS_LOG.txt')
  SSV_CT_SAV = FILEPATH(ROOT_DIR=IDIR, 'CLOUD_TRAINING_SSV_FIT_'+STRTRIM(SSV_BAND,2)+'.dat')

;-----------------------------------------
; CHECK DIMITRI DATABASE EXISTS

  TEMP = FILE_INFO(DB_FILE)
  IF TEMP.EXISTS EQ 0 THEN BEGIN
    PRINT, FCT_NAME+': ERROR, DIMITRI DATABASE FILE DOES NOT EXIST'
    RETURN, STATUS_ERROR
  ENDIF

;-----------------------------------------
; CHECK INPUT SAV FILE EXISTS

;  TEMP = FILE_INFO(IFILE)
;  IF TEMP.EXISTS EQ 0 THEN BEGIN
;    PRINT, FCT_NAME+': ERROR, INPUT SAV FILE DOES NOT EXIST'
;    RETURN,-1
;  ENDIF

;-----------------------------------------
; CHECK INPUT TRAINING PARAMETER SAV FILE EXISTS

  IF KEYWORD_SET(SKIP_TRAINING) THEN BEGIN
    TEMP = FILE_INFO(SSV_CT_SAV)
    IF TEMP.EXISTS EQ 0 THEN BEGIN
      PRINT, FCT_NAME+': ERROR, INPUT TRAINING PARAMETER SAV FILE DOES NOT EXIST'
      RETURN, STATUS_ERROR
    ENDIF
  ENDIF

;--------------------------------
; CREATE OUTPUT FOLDER IF IT DOESN'T EXIST

  RES = FILE_INFO(OUTPUT_FOLDER)
  IF RES.EXISTS NE 1 OR RES.DIRECTORY NE 1 THEN BEGIN
    IF KEYWORD_SET(VERBOSE) THEN PRINT,FCT_NAME+": OUTPUT FOLDER DOESN'T EXIST, CREATING"
    FILE_MKDIR,OUTPUT_FOLDER
  ENDIF

;-----------------------------------------
; RECORD THIS PROCESSING REQUEST IN A LOG

  IF KEYWORD_SET(VERBOSE) THEN PRINT,FCT_NAME+": WRITTING LOG FILE"
  TMP_DATE = SYSTIME()
  TMP_DATE = STRING(STRMID(TMP_DATE,8,2)+'-'+STRMID(TMP_DATE,4,3)+'-'+STRMID(TMP_DATE,20,4)+' '+STRMID(TMP_DATE,11,8))
  TEMP = FILE_INFO(SSV_CS_LOG)
  IF TEMP.EXISTS EQ 0 THEN BEGIN
    OPENW, LUNLOG,SSV_CS_LOG,/GET_LUN
    PRINTF,LUNLOG,'DATE;REGION;SENSOR;PROC_VER;ROI_PERCENTAGE;START;STOP;WAV'
  ENDIF ELSE OPENW,LUNLOG,SSV_CS_LOG,/GET_LUN,/APPEND

  PRINTF,LUNLOG,FORMAT='(4(A,1H;),(F6.2,1H;),2(F10.4,1H;),F8.2)',$
  TMP_DATE,REGION,SENSOR,PROC_VER,ROI_PERCENTAGE,DECIMAL_YEAR_START,DECIMAL_YEAR_STOP, SSV_WAV
  FREE_LUN,LUNLOG

;-----------------------------------------
; COMPUTE ROI AREA IN KM^2

  ICOORDS = GET_SITE_COORDINATES(REGION,SITE_FILE,VERBOSE=VERBOSE)

  IF ICOORDS[0] EQ -1 THEN BEGIN
    PRINT,FCT_NAME+': ERROR, REGION COORDINATES NOT FOUND'
    RETURN, STATUS_ERROR
  ENDIF

  ROI_X     = GREAT_CIRCLE_DISTANCE(ICOORDS[0],ICOORDS[2],ICOORDS[0],ICOORDS[3],/DEGREES,VERBOSE=VERBOSE)
  ROI_Y     = GREAT_CIRCLE_DISTANCE(ICOORDS[0],ICOORDS[2],ICOORDS[1],ICOORDS[2],/DEGREES,VERBOSE=VERBOSE)
  ROI_AREA  = FLOAT(ROI_X)*FLOAT(ROI_Y)
  IF KEYWORD_SET(VERBOSE) THEN PRINT,FCT_NAME+': COMPUTED ROI AREA = ',ROI_AREA

;-----------------------------------------
; GET PIXEL AREA RESOLUTIONS OF SENSOR

  SPX_AREA = (SENSOR_PIXEL_SIZE(SENSOR,/AREA,VERBOSE=VERBOSE))[0]

;-----------------------------------------
; DEFINE ROI PIX THRESHOLD

  PX_THRESH  = FLOOR(DOUBLE(RP_LIMIT*ROI_AREA)/DOUBLE(SPX_AREA))
  IF KEYWORD_SET(VERBOSE) THEN PRINT,FCT_NAME+': COMPUTED PX_THRESHOLDS = ',PX_THRESH

;-----------------------------------------
; ROICOVERAGE CHECK

  IF RP_LIMIT GE 1.0 THEN BEGIN
    ROICOVER = 1
    PX_THRESH = 1
  ENDIF ELSE ROICOVER = 0

;----------------------------------------
; RESTORE THE SENSOR TOA DATA

;  IF KEYWORD_SET(VERBOSE) THEN PRINT,FCT_NAME+': RESTORING SENSOR DATA'
;  RESTORE, IFILE

;-----------------------------------------
; SKIP TRAINING IF NOT SPECIFICIED

  IF KEYWORD_SET(SKIP_TRAINING) THEN GOTO, SCREENING

;-----------------------------------------
; SEARCH FOR ALL CLOUD TRAINING DB FILES AND CLASSES

  PATTERN='DIMITRI_DATABASE_CLOUD_TRAINING_'
  DB_FILE_LIST = FILE_SEARCH(IDIR, PATTERN+'*.CSV', COUNT=N_CLASS)
  IF(N_CLASS LE 3) THEN BEGIN
;   IF NO CLOUD TRAINING DB FILE IN INPUT DIRECTORY'
;   THEN CREATE IT AS DB_FILE_CT, IF NOT UPDATE IT

     RES=CREATE_DB_CT( REGION, SENSOR, PROC_VER,VERBOSE=VERBOSE)
     IF KEYWORD_SET(VERBOSE) THEN PRINT,FCT_NAME+': CREATE AND UPDATE CLOUD_TRAINING CLASSES'

; SEARCH AGAIN FOR ALL CLOUD TRAINING DB FILES AND CLASSES WHICH ARE RECENTLY CREATED
     DB_FILE_LIST = FILE_SEARCH(IDIR, PATTERN+'*.CSV', COUNT=N_CLASS)
     
  ENDIF 
;-----------------------------------------
; IDENTIFY CLASS NAME AND ATTRIBUTE COLOUR

  POS=STRLEN(PATTERN)

  CLASS=STRARR(N_CLASS)
  COLOUR_CLASS=FLTARR(N_CLASS)
  FOR ICLASS=0, N_CLASS-1 DO BEGIN
     CLASS[ICLASS]=(STRSPLIT(STRMID(FILE_BASENAME(DB_FILE_LIST[ICLASS]),POS),'.',/EXTRACT))[0]
     COLOUR_CLASS[ICLASS] = (254.-50.)/(N_CLASS-1.)*ICLASS+50.
  ENDFOR

  IF KEYWORD_SET(VERBOSE) THEN PRINT,FCT_NAME+': ',STRTRIM(N_CLASS,2),' CLASSES DETECTED: ',STRTRIM(CLASS,2)

;-----------------------------------------
; INITIALISE FITTING COEF FOR ALL CLASSES

  A_SSV = FLTARR(N_CLASS)
  B_SSV = FLTARR(N_CLASS)

;----------------------------------------
; LOOP ON CLOUD TRAINING CLASS

  IF KEYWORD_SET(VERBOSE) THEN PRINT,FCT_NAME+': LOOPING OVER TRAINING CLASSES'
  FOR ICLASS=0, N_CLASS-1 DO BEGIN

     DB_FILE_CT = DB_FILE_LIST[ICLASS]

;----------------------------------------
; READ THE DIMITRI CLOUD TRAINING DATABASE

     IF KEYWORD_SET(VERBOSE) THEN PRINT,FCT_NAME+': READING DIMITRI CLOUD TRAINING DATABASE '+CLASS[ICLASS]
     DB_TEMPLATE = GET_DIMITRI_TEMPLATE(1,/TEMPLATE)
     DB_DATA_CT  = READ_ASCII(DB_FILE_CT,TEMPLATE=DB_TEMPLATE)

;----------------------------------------
; SELECT CLOUD TRAINING DATA UPON ROI CRITERIA

     RES = WHERE(STRCMP(DB_DATA_CT.SITE_NAME,REGION)               EQ 1 AND $
                 STRCMP(DB_DATA_CT.SENSOR,SENSOR)               EQ 1 AND $
                 STRCMP(DB_DATA_CT.PROCESSING_VERSION,PROC_VER) EQ 1 AND $
                 DB_DATA_CT.ROI_STATUS  GE ROICOVER                   AND $
                 DB_DATA_CT.ROI_PIX_NUM GE PX_THRESH)

     IF RES[0] EQ -1 THEN BEGIN
       PRINT, FCT_NAME+': WARNING, NO SENSOR DATA FOUND WITHIN PIXEL THRESHOLD CONDITION IN CLOUD TRAINING DB, RETURN'
       RETURN, STATUS_NODATA
     ENDIF

;----------------------------------------
; LOOP ON SENSOR TOA CORRESPONDING TO
; CLOUD TRAINING DATABASE SELECTION

;     A = []
;     B = []
     LOOP_START=1
     FOR IT = 0L, N_ELEMENTS(RES)-1 DO BEGIN
         
        ;----------------------
        ; GET NCDF FILENAME
        NCDF_FILENAME = IDIR + DL + STRTRIM(STRING(DB_DATA_CT.YEAR[RES[IT]]),2) + DL + DB_DATA_CT.L1_INGESTED_FILENAME[RES[IT]]
        STATUS = GET_SSV_BAND_VALUES_FROM_NCDF_INGESTION_FILE(NCDF_FILENAME, SSV_BAND, SSV_BAND_VALUES=SSV_BAND_VALUES, NPIX=NPIX, VERBOSE=VERBOSE)
        
        IF STATUS NE STATUS_OK THEN CONTINUE
        
;----------------------------------------
; COMPUTE SSV FIT FOR THE OBSERVATION

        N = FIX(SQRT(NPIX))
;        TAB = REFORM(SENSOR_L1B_REF_PIX[NUM_NON_REF+SSV_BAND,ID[0:N*N-1]],N,N)
        TAB = REFORM(SSV_BAND_VALUES[0:N*N-1],N,N)

        STDEV = FLTARR(N-2)
        FOR I=2, N-1 DO STDEV[I-2]=STDDEV(CONGRID(TAB,I,I,/INTER,/CENTER,/MINUS_ONE))
        X = INDGEN(N-2)+2.
        FIT = LINFIT(ALOG(X), ALOG(STDEV))

        IF LOOP_START THEN BEGIN
          A = [EXP(FIT[0])]
          B = [FIT[1]]
          LOOP_START = 0
        ENDIF ELSE BEGIN
          A = [A, EXP(FIT[0])]
          B = [B, FIT[1]]
        ENDELSE

     ENDFOR

;----------------------------------------
; TAKE MEDIAN OVER ALL TRAINING DATA 

     A_SSV[ICLASS] = MEDIAN(A)
     B_SSV[ICLASS] = MEDIAN(B)

  ENDFOR

;----------------------------------------
; SAVE TRAINING PARAMETERS

  SAVE, N_CLASS, CLASS, COLOUR_CLASS, SSV_BAND, A_SSV, B_SSV, FILENAME=SSV_CT_SAV
  IF KEYWORD_SET(VERBOSE) THEN PRINT,FCT_NAME+': TRAINING FINISHED' 

SCREENING:
;----------------------------------------
; RESTORE TRAINING PARAMETERS IF NOT GENERATED

  IF KEYWORD_SET(SKIP_TRAINING) THEN BEGIN
    IF KEYWORD_SET(VERBOSE) THEN PRINT,FCT_NAME+': RESTORING TRAINING PARAMETERS'
    RESTORE, SSV_CT_SAV
    IF KEYWORD_SET(VERBOSE) THEN PRINT,FCT_NAME+': ',STRTRIM(N_CLASS,2),' CLASSES DETECTED: ',STRTRIM(CLASS,2)
  ENDIF

;----------------------------------------
; READ THE DIMITRI DATABASE

  IF KEYWORD_SET(VERBOSE) THEN PRINT,FCT_NAME+': READING DIMITRI DATABASE'
  DB_TEMPLATE = GET_DIMITRI_TEMPLATE(1,/TEMPLATE)
  DB_DATA     = READ_ASCII(DB_FILE,TEMPLATE=DB_TEMPLATE)

;----------------------------------------
; SELECT DATA TO BE SCREENED

  RES = WHERE(STRCMP(DB_DATA.SITE_NAME,REGION)            EQ 1 AND $
              STRCMP(DB_DATA.SENSOR,SENSOR)               EQ 1 AND $
              STRCMP(DB_DATA.PROCESSING_VERSION,PROC_VER) EQ 1 AND $
              DB_DATA.DECIMAL_YEAR GE DECIMAL_YEAR_START       AND $
              DB_DATA.DECIMAL_YEAR LE DECIMAL_YEAR_STOP        AND $
              DB_DATA.ROI_STATUS  GE ROICOVER                   AND $
              DB_DATA.ROI_PIX_NUM GE PX_THRESH)

  IF RES[0] EQ -1 THEN BEGIN
    PRINT, FCT_NAME+': WARNING, NO SENSOR DATA FOUND IN DB, RETURN'
    RETURN, STATUS_NODATA
  ENDIF

;---------------------------------------
; GET CURRENT DEVICE TYPE FOR PLOT

  IF KEYWORD_SET(VERBOSE) THEN PRINT, FCT_NAME+': CHANGING TO THE ZBUFFER'
  MACHINE_WINDOW = !D.NAME
  SET_PLOT, 'Z'
  DEVICE, SET_RESOLUTION=[700,400],SET_PIXEL_DEPTH=24
  ERASE
  DEVICE, DECOMPOSED = 0
  LOADCT, 39
  !P.COLOR=0

;----------------------------------------
; SEARCH CORRESPONDING SENSOR TOA

  FOR IT = 0L, N_ELEMENTS(RES)-1 DO BEGIN
  
        ;----------------------
        ; GET NCDF FILENAME
        NCDF_FILENAME = IDIR + DL + STRTRIM(STRING(DB_DATA.YEAR[RES[IT]]),2) + DL + DB_DATA.L1_INGESTED_FILENAME[RES[IT]]
        STATUS = GET_SSV_BAND_VALUES_FROM_NCDF_INGESTION_FILE(NCDF_FILENAME, SSV_BAND, SSV_BAND_VALUES=SSV_BAND_VALUES, NPIX=NPIX)
        
        IF STATUS NE 1 THEN CONTINUE
  
  
;     ID = WHERE(ABS(SENSOR_L1B_REF_PIX[0,*]-DB_DATA.DECIMAL_YEAR[RES[IT]]) LE TOL AND $
;             SENSOR_L1B_REF_PIX[NUM_NON_REF+SSV_BAND,*] NE -999., NPIX)
;     IF NPIX EQ 0 THEN CONTINUE

;----------------------------------------
; DEAL WITH SEVERAL DIRECTION OR POSSIBLE DOUBLONS IN DB BY TAKING LAST PIXELS
; THIS IS AN APPROXIMATION AS INFO ON NUMBER OF PIXEL PER DIRECTION IS UNKNOWN

;     IF NPIX NE FIX(DB_DATA.ROI_PIX_NUM[RES[IT]]) THEN BEGIN
;       ID=ID[NPIX-FIX(DB_DATA.ROI_PIX_NUM[RES[IT]]):NPIX-1]
;       NPIX = FIX(DB_DATA.ROI_PIX_NUM[RES[IT]])
;     ENDIF

;----------------------------------------
; COMPUTE STANDARD-DEVIATION ON SUBSAMPLED GRIDS

     N = FIX(SQRT(NPIX))
;     TAB = REFORM(SENSOR_L1B_REF_PIX[NUM_NON_REF+SSV_BAND,ID[0:N*N-1]],N,N)
     TAB = REFORM(SSV_BAND_VALUES[0:N*N-1],N,N)

     STDEV = FLTARR(N-2)
     FOR I=2, N-1 DO STDEV[I-2]=STDDEV(CONGRID(TAB,I,I,/INTER,/CENTER,/MINUS_ONE))
     X = INDGEN(N-2)+2.

;----------------------------------------
; APPLY FIT OF ALL CLASSES AND FIND BEST ONE
     
     CHI  = FLTARR(N_CLASS)
     YMAX = MAX(STDEV)

     FOR ICLASS=0, N_CLASS-1 DO BEGIN
        CHI[ICLASS] = SQRT(TOTAL((STDEV-A_SSV[ICLASS]*X^B_SSV[ICLASS])*(STDEV-A_SSV[ICLASS]*X^B_SSV[ICLASS])))
        YMAX = MAX([YMAX,A_SSV[ICLASS]*X^B_SSV[ICLASS]])
     ENDFOR
     TMP = MIN(CHI, IBEST)

;----------------------------------------
; PLOT CLASS ANALYSIS
     
     PLOT, X, STDEV, BACKGROUND=255, YRANGE=[0.,YMAX], PSYM=4, XTITLE='Pixel subsampling size', YTITLE='STD-DEV('+STRTRIM(SSV_WAV,2)+')'
     FOR ICLASS=0, N_CLASS -1 DO OPLOT, X, A_SSV[ICLASS]*X^B_SSV[ICLASS], COLOR=COLOUR_CLASS[ICLASS]
     OPLOT, X, STDEV, PSYM=4, COLOR=COLOUR_CLASS[IBEST]
     LEGEND, [CLASS,'CURRENT DATA'], COLORS=[COLOUR_CLASS,COLOUR_CLASS[IBEST]], TEXTCOLORS=[COLOUR_CLASS,0],PSYM=[BYTARR(N_CLASS),4], /RIGHT_LEGEND

     TEMP = TVRD(TRUE=1)
     FILENAME = DB_DATA.L1_FILENAME[RES[IT]]
     POS  = STRPOS(FILENAME,'.',/REVERSE_SEARCH)
     STRPUT,FILENAME,'_',POS
     JPEG=FILENAME+'_SSV.JPG'
     OUT_JPEG=FILEPATH(JPEG, ROOT_DIR=OUTPUT_FOLDER)
     WRITE_JPEG,OUT_JPEG,TEMP,TRUE=1,QUALITY=100  


;========== TO UNCOMMENT =======================================================
;========== AND 
;========== REPLACE SSV_CS_SCORE BY VALUE WHICH CONTAINS SSV CLOUD SCREENING SCORE
        
        ;----------------------
        ; UPDATE CT DATABASE WITH SSV SCORE

;        DB_DATA.SSV_CS_MEAN[RES[IT]] = SSV_CS_SCORE
        
        ;----------------------
        ; SAVE RESULT IN NCDF FILE

;        NCDF_FILENAME = IDIR + DL + STRTRIM(STRING(DB_DATA.YEAR[RES[IT]]),2) + DL + DB_DATA.L1_INGESTED_FILENAME[RES[IT]]

;        IF KEYWORD_SET(VERBOSE) THEN PRINT, FCT_NAME + ': NCDF FILE UPDATED WITH SSV RESULT (' + NCDF_FILENAME + ')'
;        ncid = NCDF_OPEN(NCDF_FILENAME, /WRITE)
;        NCDF_ATTPUT, ncid , 'SSV_CS_MEAN' , SSV_CS_SCORE , /GLOBAL
;        NCDF_CLOSE, ncid

;==============================================================================================================

  ENDFOR

;-----------------------------------------------
; RETURN DEVISE WINDOW TO NOMINAL SETTING

  IF KEYWORD_SET(VERBOSE) THEN PRINT, FCT_NAME+': RESETTING DEVICE WINDOW PROPERTIES'
  SET_PLOT, MACHINE_WINDOW

RETURN, STATUS_OK

END
