;**************************************************************************************
;**************************************************************************************
;*
;* NAME:
;*      INGEST_PARASOL_PRODUCT       
;* 
;* PURPOSE:
;*      INGESTS PARASOL L1B DATA INTO DIMITRI DATABASE. MULTIPLE PRODUCT 
;*	    EXTRACTION IS AVAILABLE BUT IT EXPECTS ALL FILES TO BE THE SAME REGION/PROCESSING. 
;*      OUTPUTS QUICKLOOK IMAGES, UPDATES DATABASE AND APPENDS DATA TO SAV FILE FOR 
;*      SPECIFIED REGION AND PROCESSING.
;* 
;* CALLING SEQUENCE:
;*      RES = INGEST_PARASOL_PRODUCT(IFILES)      
;* 
;* INPUTS:
;*      IFILES -  A STRING OR STRING ARRAY OF THE FULL PATH FILENAMES OF PRODUCTS 
;*                FOR INGESTION.      
;*
;* KEYWORDS:
;*      INPUT_FOLDER      - A STRING CONTAINING THE FULL PATH OF THE 'INPUT' FOLDER, IF 
;*                          NOT PROVIDED THEN IT IS DERIVED FROM THE FILENAME
;*      ICOORDS           - A FOUR ELEMENT FLOATING-POINT ARRAY CONTAINING THE NORTH, SOUTH, 
;*                          EAST AND WEST COORDINATES OF THE ROI, E.G [50.,45.,10.,0.]
;*      INGEST_SUNGLINST  - LOGICAL VALUE TO INGEST L1B PRODUCT IN SUNGLINT MODE (=1) 
;*                           > SUNGLINT AREA DETECTED ACCORDING VIEW/SUN ANGLES
;*                           > OTHERWISE (=0) ANALYSIS PERFORM ONLY ON SITE COORDS
;*      NB_PIX_THRESHOLD  - NUMBER OF PIXELS WITHIN ROI TO BE ACCEPTED
;*      ENDIAN_SZE        - MACHINE ENDIAN SIZE (0: LITTLE, 1: BIG), IF NOT PROVIDED 
;*                          THEN COMPUTED.
;*      COLOUR_TABLE      - USER DEFINED IDL COLOUR TABLE INDEX (DEFAULT IS 39)
;*      PLOT_XSIZE        - WIDTH OF GENERATED PLOTS (DEFAULT IS 700PX)
;*      PLOT_YSIZE        - HEIGHT OF GENERATED PLOTS (DEFAULT IS 400PX)
;*      NO_ZBUFF          - IF SET THEN PLOTS ARE GENERATED IN WINDOWS AND NOT 
;*                          WIHTIN THE Z-BUFFER.
;*      NO_QUICKLOOK      - IF SET THEN QUICKLOOKS ARE NOT GENERATED FOR IFILES.
;*      VERBOSE           - PROCESSING STATUS OUTPUTS
;*
;* OUTPUTS:
;*      STATUS  - 1: NO ERRORS REPORTED, (-1) OR 0: ERRORS DURING INGESTION	
;*
;* COMMON BLOCKS:
;*      NONE
;*
;* MODIFICATION HISTORY:
;*        04 JUL 2005 - M BOUVET  - PROTOTYPE DIMITRI VERSION
;*        16 DEC 2010 - C KENT    - DIMITRI-2 V1.0
;*        20 DEC 2010 - C KENT    - UPDATED COMMENTS AND HEADER INFORMATION
;*        10 JAN 2011 - C KENT    - CHANGED SAVED OUTPUT VARIABLE TO SENSOR_L1B_REF 
;*        21 MAR 2011 - C KENT    - MODIFIED FILE DEFINITION TO USE GET_DIMITRI_LOCATION
;*        22 MAR 2011 - C KENT    - ADDED CONFIGURAITON FILE DEPENDENCE
;*        14 MAY 2011 - C KENT    - ADDED GLOBCARBON CLOUD SCREENING
;*        21 JUN 2011 - C KENT    - UPDATED RAA HANDLING
;*        01 JUL 2011 - C KENT    - ADDED ANGLE CORRECTOR
;*        04 JUL 2011 - C KENT    - ADDED AUX INFO TO OUTPUT SAV
;*        14 JUL 2011 - C KENT    - UPDATED TIME EXTRACTION SECTION
;*        14 SEP 2011 - C KENT    - ADDED NETCDF OUTPUT STRUCTURE
;*        08 MAR 2012 - C KENT    - ADDED ROI COVERAGE
;*        20 MAY 2014 - BBT/PML / MAGELLIUM   - ADDED SUNGLINT AREA ANALYSIS
;*        10 FEB 2015 - NCG / MAGELLIUM   - UPDATE WITH DIMITRI V4 SPECIFICATION
;*
;* VALIDATION HISTORY:
;*        16 DEC 2010 - C KENT    - WINDOWS 32BIT MACHINE, COMPILATION AND EXECUTION 
;*                                  SUCCESSFUL. TESTED MULTIPLE OPTIONS ON MULTIPLE 
;*                                  PRODUCTS
;*        12 APR 2011 - C KENT    - LINUX 64BIT MACHINE IDL 8.0: COMPILATION AND OPERATION SUCCESSFUL 
;*        20 MAY 2014 - PML / MAGELLIUM       - LINUX 64BIT MACHINE IDL 8.0: COMPILATION AND OPERATION SUCCESSFUL 
;*      20 JAN 2015 - NCG / MAGELLIUM      - WINDOWS 64BIT MACHINE IDL 8.0: COMPILATION AND OPERATION SUCCESSFUL 
;*      30 MAR 2015 - NCG / MAGELLIUM      - WINDOWS 64BIT MACHINE IDL 8.0: COMPILATION AND OPERATION SUCCESSFUL (DIMITRI V4.0) 

;**************************************************************************************
;**************************************************************************************

FUNCTION INGEST_PARASOL_PRODUCT,IFILES,INPUT_FOLDER=INPUT_FOLDER,ICOORDS=ICOORDS,INGEST_SUNGLINT=INGEST_SUNGLINT,$
         ENDIAN_SZE=ENDIAN_SIZE,COLOUR_TABLE=COLOUR_TABLE,$
         PLOT_XSIZE=PLOT_XSIZE,PLOT_YSIZE=PLOT_YSIZE,NO_ZBUFF=NO_ZBUFF,NO_QUICKLOOK=NO_QUICKLOOK,$
         VERBOSE=VERBOSE

	DEBUG_MODE  = 0       ; SET TO 1 IF WANT TO DEBUG THIS PROCEDURE
	 
	FCT_NAME = 'INGEST_PARASOL_PRODUCT'

	STATUS_OK = GET_DIMITRI_LOCATION('STATUS_OK')
	STATUS_ERROR = GET_DIMITRI_LOCATION('STATUS_ERROR')

	;------------------------
	; KEYWORD PARAMETER CHECK - NOTE, ASSUMES ALL PRODUCT ARE RELATED TO THE SAME REGION/PROCESSING

	IF STRCMP(STRING(IFILES[0]),'') THEN BEGIN
		PRINT, FCT_NAME + ' - ERROR, NO INPUT FILES PROVIDED, RETURNING...'
		RETURN, STATUS_ERROR
	ENDIF  
	IF N_ELEMENTS(INPUT_FOLDER) EQ 0 THEN INPUT_FOLDER = GET_DIMITRI_LOCATION('INPUT')

	DL = GET_DIMITRI_LOCATION('DL')
	MISSING_VALUE_FLT=FLOAT(GET_DIMITRI_LOCATION('NCDF_MISSING_VALUE'))
	MISSING_VALUE_DBL=DOUBLE(GET_DIMITRI_LOCATION('NCDF_MISSING_VALUE'))
	MISSING_VALUE_LONG=LONG(GET_DIMITRI_LOCATION('NCDF_MISSING_VALUE'))
	SG_THETA_N_MIN=GET_DIMITRI_LOCATION('MIN_THETA_N_SG_PROCESS') 
	SG_THETA_N_MAX=GET_DIMITRI_LOCATION('MAX_THETA_N_SG_PROCESS') 
	SG_THETA_R_MAX=GET_DIMITRI_LOCATION('MAX_THETA_R_SG_PROCESS')
	MIN_NIR_SG_CS_PROCESS=GET_DIMITRI_LOCATION('MIN_NIR_SG_CS_PROCESS')
  MIN_PIXEL_NB_INGEST_PROCESS = GET_DIMITRI_LOCATION('MIN_PIXEL_NB_INGEST_PROCESS')
  OUTPUT_FOLDER = GET_DIMITRI_LOCATION('INGESTION_OUTPUT')
  AUTO_CS_1_NAME = GET_DIMITRI_LOCATION('AUTO_CS_1_NAME')
  AUTO_CS_2_NAME = GET_DIMITRI_LOCATION('AUTO_CS_2_NAME')
  
	TEMP = STRSPLIT(IFILES[0],DL,/EXTRACT)

	TEMP_INF  = WHERE(STRCMP(TEMP,'Input') EQ 1)
	TEMP_INF  = TEMP_INF(N_ELEMENTS(TEMP_INF)-1)
	IREGION   = TEMP[TEMP_INF+1]
	IREGION   = STRMID(IREGION,5,STRLEN(IREGION)) 
	SENSOR    = TEMP[TEMP_INF+2]
	IPROC     = TEMP[TEMP_INF+3]
	IPROC     = STRMID(IPROC,5,STRLEN(IPROC)) 
	CFIG_DATA = GET_DIMITRI_CONFIGURATION()
	SITE_TYPE = GET_SITE_TYPE(IREGION,VERBOSE=VERBOSE) 

	IF N_ELEMENTS(ICOORDS) EQ 0 THEN BEGIN
		PRINT, FCT_NAME + ' - NO ROI COORDINATES PROVIDED, USING DEFAULT OF [90.,-90,180.0,-180.0]'
		ICOORDS = [90.,-90.,180.0,-180.0]
	ENDIF
	IF N_ELEMENTS(COLOUR_TABLE) EQ 0 THEN BEGIN
		PRINT, FCT_NAME + ' - NO COLOR_TABLE SET, USING DEFAULT OF 39'
		COLOUR_TABLE = CFIG_DATA.(1)[2]
	ENDIF
	IF N_ELEMENTS(PLOT_XSIZE) EQ 0 THEN BEGIN
		PRINT, FCT_NAME + ' - PLOT_XSIZE NOT SET, USING DEFAULT OF 700'
		PLOT_XSIZE = CFIG_DATA.(1)[0]
	ENDIF
	IF N_ELEMENTS(PLOT_YSIZE) EQ 0 THEN BEGIN
		PRINT, FCT_NAME + ' - PLOT_YSIZE NOT SET, USING DEFAULT OF 400'
		PLOT_YSIZE = CFIG_DATA.(1)[1]
	ENDIF  

	;------------------------------------------------
	; IF ENDIAN SIZE NOT PROVIDED THEN GET VALUE

	IF N_ELEMENTS(ENDIAN_SIZE) EQ 0 THEN BEGIN
	IF KEYWORD_SET(VERBOSE) THEN PRINT, FCT_NAME + ' - NO ENDIAN SIZE PROVIDED, RETRIEVING...'
		ENDIAN_SIZE = GET_ENDIAN_SIZE(VERBOSE=VERBOSE)
	ENDIF

	;------------------------
	; GET NUMBER OF IFILES 

	NB_FILES = N_ELEMENTS(IFILES)

	;-----------------------------------------------
	; GET THE DATABASE STRUCTURE 

	DB_DATA=GET_DIMITRI_TEMPLATE(NB_FILES,/DB)

	;-----------------------------------------------  
	; ADD DATA OF INGESTION TO DB_DATA

	TEMP = SYSTIME()
	TEMP = STRMATCH(STRMID(TEMP,8,1),' ') ? '0'+STRUPCASE(STRING(STRMID(TEMP,9,1)+'-'+STRMID(TEMP,4,3)+'-'+STRMID(TEMP,20,4))) : STRUPCASE(STRING( STRMID(TEMP,8,2)+'-'+STRMID(TEMP,4,3)+'-'+STRMID(TEMP,20,4)))
	DB_DATA.DIMITRI_DATE = TEMP 

	;-----------------------------------------------
	; ADD REGION, SENSOR AND PROC VERSION TO DB_DATA

	DB_DATA.SITE_NAME = IREGION
  DB_DATA.SITE_TYPE = SITE_TYPE
  DB_DATA.SITE_COORDINATES = 'NONE'
	DB_DATA.SENSOR = SENSOR
	DB_DATA.PROCESSING_VERSION = IPROC

	;-----------------------------------------
	; SET INITIAL VALUES 

  DB_DATA.L1_INGESTED_FILENAME = 'NONE'
  DB_DATA.ROI_STATUS = -1
  DB_DATA.ROI_PIX_NUM = -1
  DB_DATA.THETA_N_MEAN = -1
  DB_DATA.THETA_R_MEAN = -1
  DB_DATA.AUTO_CS_1_NAME = AUTO_CS_1_NAME
  DB_DATA.AUTO_CS_1_MEAN = -1
  DB_DATA.ROI_CS_1_CLEAR_PIX_NUM = -1
  DB_DATA.AUTO_CS_2_NAME = AUTO_CS_2_NAME
  DB_DATA.AUTO_CS_2_MEAN = -1
  DB_DATA.ROI_CS_2_CLEAR_PIX_NUM = -1
  DB_DATA.BRDF_CS_MEAN = -1
  DB_DATA.SSV_CS_MEAN = -1
  DB_DATA.MANUAL_CS = -1 
  DB_DATA.ERA_WIND_SPEED_MEAN = -1
  DB_DATA.ERA_WIND_DIR_MEAN = -1
  DB_DATA.ERA_OZONE_MEAN = -1
  DB_DATA.ERA_PRESSURE_MEAN = -1
  DB_DATA.ERA_WATERVAPOUR_MEAN = -1
  DB_DATA.ESA_CHLOROPHYLL_MEAN = -1
     
	;----------------------------------
	; DEFINE SPECIFIC PARAMETERS 

	NB_BANDS = SENSOR_BAND_INFO('PARASOL') 
	NB_BANDS = NB_BANDS[0]
	BAND_INDEX =[0,1,3,4,5,6,7,8,2]
	BAND_OFFSET = 11
  NB_DIRECTIONS = SENSOR_DIRECTION_INFO(SENSOR)
	NB_DIRECTIONS = NB_DIRECTIONS[0]

	;----------------------------------
	; DEFINE THE STATISTICAL ARRAYS

	ROI_AVG_TOA_REF= MAKE_ARRAY(NB_BANDS,NB_FILES*NB_DIRECTIONS,/FLOAT,VALUE=MISSING_VALUE_FLT)
	ROI_STD_TOA_REF= MAKE_ARRAY(NB_BANDS,NB_FILES*NB_DIRECTIONS,/FLOAT,VALUE=MISSING_VALUE_FLT)
	NB_ROI_PX        = FLTARR(NB_FILES*NB_DIRECTIONS)
	GOOD_RECORD      = MAKE_ARRAY(NB_FILES*NB_DIRECTIONS,/INTEGER,VALUE=0)
	IFILE_DATE 	   = DBLARR(5,NB_FILES*NB_DIRECTIONS);CONTAINS YEAR,MONTH,DAY,DOY,DECIMEL_YEAR
	IFILE_VIEW 	   = DBLARR(4,NB_FILES*NB_DIRECTIONS);CONTAINS SENSOR ZENITH,SENSOR AZIMUTH,SOLAR ZENITH,SOLAR AZIMUTH
	IFILE_AUX        = FLTARR(12,NB_FILES*NB_DIRECTIONS);CONTAINS OZONE,PRESSURE,RELHUMIDITY,WIND_ZONAL,WIND_MERID, AND WVAP (MU AND SIGMA)

	IF KEYWORD_SET(VERBOSE) THEN BEGIN
		PRINT, FCT_NAME + ' - DEFINITION OF OUTPUT ARRAYS:'
		HELP, ROI_AVG_TOA_REF,ROI_STD_TOA_REF,NB_ROI_PX,GOOD_RECORD,IFILE_DATE,IFILE_VIEW
	ENDIF

	;---------------------------------
	; ADD DATA TO NETCDF OUTPUT STRUCTURE

	NCDF_OUT = GET_DIMITRI_EXTRACT_NCDF_DATA_STRUCTURE(NB_FILES,NB_BANDS,NB_DIRECTIONS)
	NCDF_OUT.ATT_FNAME  = 'Site_'+IREGION+'_'+SENSOR+'_'+'Proc_'+IPROC+'.nc'
	NCDF_OUT.ATT_TOOL   = GET_DIMITRI_LOCATION('TOOL')
	NCDF_OUT.ATT_SENSOR = SENSOR
	NCDF_OUT.ATT_PROCV  = IPROC
	NCDF_OUT.ATT_PRES   = STRTRIM(STRING(SENSOR_PIXEL_SIZE(SENSOR)),2)+' KM'
	NCDF_OUT.ATT_NBANDS = STRTRIM(STRING(NB_BANDS),2)
	NCDF_OUT.ATT_NDIRS  = STRTRIM(STRING(NB_DIRECTIONS),2)
	NCDF_OUT.ATT_SITEN  = IREGION
	NCDF_OUT.ATT_SITEC  = STRJOIN(STRTRIM(STRING(ICOORDS),2),' ')
	NCDF_OUT.ATT_SITET  = SITE_TYPE

	;----------------------------------
	; START MAIN LOOP OVER EACH IFILE

	IF KEYWORD_SET(VERBOSE) THEN PRINT, FCT_NAME + ' - STARTING INGESTION LOOP ON PARASOL PRODUCTS'
	FOR IN_FNAME=0,NB_FILES-1 DO BEGIN; IN_FNAME IS RESERVED FOR LOOPS WITHIN THE INGESTION ROUTINES

		TEMP = STRSPLIT(IFILES[IN_FNAME],DL,/EXTRACT)
		DB_DATA.L1_FILENAME[IN_FNAME] = TEMP[N_ELEMENTS(TEMP)-1]
		
		;------------------------------------------
		; RETRIEVE PRODUCT DATA

		IF KEYWORD_SET(VERBOSE) THEN PRINT, FCT_NAME + ' - RETRIEVING HEADER AND L1B DATA'
		L1B_HEADER = GET_PARASOL_L1B_HEADER(IFILES[IN_FNAME],VERBOSE=VERBOSE)
		L1B_DATA = GET_PARASOL_L1B_DATA(IFILES[IN_FNAME],ENDIAN_SIZE=ENDIAN_SIZE,VERBOSE=VERBOSE)

		;------------------------------------------
		; RETRIEVE AUX DATA FILENAMES FOR DB_DATA

		TEMP = 'NONE'
		DB_DATA.AUX_DATA_1[IN_FNAME] = L1B_HEADER.SOFTWARE_VERSION
		DB_DATA.AUX_DATA_2[IN_FNAME] = L1B_HEADER.DEM_MODEL 
		DB_DATA.AUX_DATA_3[IN_FNAME] = L1B_HEADER.RAD_DATE 
		DB_DATA.AUX_DATA_4[IN_FNAME] = L1B_HEADER.GEO_DATE 
		DB_DATA.AUX_DATA_5[IN_FNAME] = TEMP 
		DB_DATA.AUX_DATA_6[IN_FNAME] = TEMP 
		DB_DATA.AUX_DATA_7[IN_FNAME] = TEMP 
		DB_DATA.AUX_DATA_8[IN_FNAME] = TEMP 
		DB_DATA.AUX_DATA_9[IN_FNAME] = TEMP 
		DB_DATA.AUX_DATA_10[IN_FNAME] = TEMP 

		
		;----------------------------------
		; RETRIEVE DATE INFORMATION

		IF KEYWORD_SET(VERBOSE) THEN PRINT, FCT_NAME + ' - RETRIEVING DATE INFORMATION'

		TDATE = L1B_HEADER.DATE[0]

		ACQ_YEAR  = STRMID(TDATE,0,4)
		ACQ_MONTH = STRMID(TDATE,4,2)
		ACQ_DAY   = STRMID(TDATE,6,2)

		IFILE_DATE[0,NB_DIRECTIONS*IN_FNAME:NB_DIRECTIONS*IN_FNAME+NB_DIRECTIONS-1]  = ACQ_YEAR+0.
		IFILE_DATE[1,NB_DIRECTIONS*IN_FNAME:NB_DIRECTIONS*IN_FNAME+NB_DIRECTIONS-1]  = ACQ_MONTH+0.
		IFILE_DATE[2,NB_DIRECTIONS*IN_FNAME:NB_DIRECTIONS*IN_FNAME+NB_DIRECTIONS-1]  = ACQ_DAY+0.

		IF FLOAT(IFILE_DATE[0,NB_DIRECTIONS*IN_FNAME]) MOD 4 EQ 0 THEN DIY = 366.0 ELSE DIY = 365.0

		DATE_HR  = STRMID(TDATE,8,2)
		DATE_MIN = STRMID(TDATE,10,2)
		DATE_SEC = STRMID(TDATE,12,2)

		THR = FLOAT(DATE_HR)
		TMM = FLOAT(DATE_MIN)
		TSS = FLOAT(DATE_SEC)
		TTIME = DOUBLE((THR/(DIY*24.))+(TMM/(DIY*60.*24.))+TSS/(DIY*60.*60.*24.))

		IFILE_DATE[3,NB_DIRECTIONS*IN_FNAME:NB_DIRECTIONS*IN_FNAME+NB_DIRECTIONS-1] =  JULDAY(IFILE_DATE[1,NB_DIRECTIONS*IN_FNAME],$
																										IFILE_DATE[2,NB_DIRECTIONS*IN_FNAME],$
																										IFILE_DATE[0,NB_DIRECTIONS*IN_FNAME])-$
																										JULDAY(1,0,IFILE_DATE[0,NB_DIRECTIONS*IN_FNAME])

		IFILE_DATE[4,NB_DIRECTIONS*IN_FNAME:NB_DIRECTIONS*IN_FNAME+NB_DIRECTIONS-1] =  FLOAT(IFILE_DATE[0,NB_DIRECTIONS*IN_FNAME])+$
																										DOUBLE(IFILE_DATE[3,NB_DIRECTIONS*IN_FNAME]/DIY) + TTIME

		;----------------------------------
		; ADD DATE INFORMATION TO DB_DATA

		DB_DATA.YEAR[IN_FNAME]  = IFILE_DATE[0,NB_DIRECTIONS*IN_FNAME]
		DB_DATA.MONTH[IN_FNAME] = IFILE_DATE[1,NB_DIRECTIONS*IN_FNAME]
		DB_DATA.DAY[IN_FNAME]   = IFILE_DATE[2,NB_DIRECTIONS*IN_FNAME]
		DB_DATA.DOY[IN_FNAME]   = IFILE_DATE[3,NB_DIRECTIONS*IN_FNAME]
		DB_DATA.DECIMAL_YEAR[IN_FNAME] = IFILE_DATE[4,NB_DIRECTIONS*IN_FNAME]
   	
		;----------------------------------
		; STORE DATE IN NETCDF STRUCTURE

		NCDF_OUT.VAR_PNAME[IN_FNAME]  = DB_DATA.L1_FILENAME[IN_FNAME] 
    NCDF_OUT.VAR_PTIME[IN_FNAME]  = ACQ_YEAR+ACQ_MONTH+ACQ_DAY+' '+DATE_HR+':'+DATE_MIN+':'+DATE_SEC
    NCDF_OUT.VAR_DTIME[IN_FNAME]  = DB_DATA.DECIMAL_YEAR[IN_FNAME]   	


		;----------------------------------
		; INITIALISATION OF SUNGLINT INGESTION VARIABLES
		NB_ROI_MAX=SIZE(L1B_DATA.VZA,/N_ELEMENTS)
		TOTAL_ROI = MAKE_ARRAY(NB_ROI_MAX,1,/LONG, VALUE=-1)  
		IINF=0
		ISUP=-1
		
		;----------------------------------
		; LOOP OVER DIRECTIONS FOR ROI ESTIMATION

    MEAN_THETA_N = 0.0
    MEAN_THETA_R = 0.0
		NB_PIX_MAX = MISSING_VALUE_LONG
		FOR IN_DIR = 0,NB_DIRECTIONS-1 DO BEGIN

			IF KEYWORD_SET(VERBOSE) THEN BEGIN
				PRINT, FCT_NAME + ' - ROI ESTIMATION - DIRECTION = ' + STRTRIM(STRING(IN_DIR),2)
			ENDIF    

			IF KEYWORD_SET(VERBOSE) THEN PRINT, FCT_NAME + ' - RETRIEVING VIEWING GEOMETRIES'
			TEMP_VAA = L1B_DATA.SAA-L1B_DATA.RAA[IN_DIR]  
			TEMP_ANGLES = DIMITRI_ANGLE_CORRECTOR(L1B_DATA.VZA[IN_DIR],TEMP_VAA,L1B_DATA.SZA[IN_DIR],L1B_DATA.SAA,VERBOSE=VERBOSE)

			LIGSG = L1B_DATA.LINE
			COLSG = L1B_DATA.COLUMN
			LATI  = L1B_DATA.LATITUDE
			LONGI = L1B_DATA.LONGITUDE

			;------------------------------------------
			; RETRIEVE SUNGLINT ANGLES FOR SUNGLINT OR OCEAN SITES   
			IF (INGEST_SUNGLINT EQ 1) OR STRCMP(DB_DATA.SITE_TYPE[IN_FNAME], 'OCEAN', /FOLD_CASE) THEN BEGIN

      	RES = GET_SUNGLINT_ANGLES( TEMP_ANGLES.SZA, TEMP_ANGLES.VZA, TEMP_ANGLES.SAA, TEMP_ANGLES.VAA, THETA_N=THETA_N, THETA_R=THETA_R)

        MEAN_THETA_N = MEAN_THETA_N + MEAN(THETA_N)
        MEAN_THETA_R = MEAN_THETA_R + MEAN(THETA_R)

        IF DEBUG_MODE EQ 1 THEN BEGIN
          PRINT, ' DEBUG_MODE - DIR = ', IN_DIR
          PRINT, ' DEBUG_MODE - THETA_N = ', MEAN(THETA_N)
          PRINT, ' DEBUG_MODE - THETA_R = ', MEAN(THETA_R)
        ENDIF
			ENDIF

			;------------------------------------------
			; PROCESS SELECTION FOR SUNGLINT DETECTION/INGESTION OR NOT
			IF (INGEST_SUNGLINT EQ 1) THEN BEGIN

				; FIND SUNGLINT SPOT
				ROI_INDEX=WHERE(THETA_N GT SG_THETA_N_MIN AND $
						THETA_N LE SG_THETA_N_MAX AND $
						TEMP_ANGLES.SZA GT 0 AND $
						LATI NE 0 AND $
						L1B_DATA.REF_443NP[IN_DIR] GT 0.0 , $
						NB_PIX, COMPLEMENT=IDNOSG, NCOMPLEMENT=COUNT_NOSG)

				IF NB_PIX GT 0 THEN BEGIN
					IINF=ISUP+1
					ISUP=ISUP+NB_PIX
					TOTAL_ROI[IINF:ISUP]=ROI_INDEX
				ENDIF
			
			ENDIF ELSE BEGIN
				; CLASSICAL INGEST / NOT FOR SUNGLINT
				ROI_INDEX = WHERE($
						LATI LT ICOORDS[0] AND $
						LATI GT ICOORDS[1] AND $
						LONGI LT ICOORDS[2] AND $
						LONGI GT ICOORDS[3] AND $
						L1B_DATA.REF_443NP[IN_DIR] GT 0.0 , $
						NB_PIX $
						)
			ENDELSE

			NB_PIX_MAX = MAX([NB_PIX_MAX, NB_PIX])

			IF NB_PIX LT MIN_PIXEL_NB_INGEST_PROCESS THEN BEGIN
				IFILE_VIEW[*,NB_DIRECTIONS*IN_FNAME+IN_DIR]= MISSING_VALUE_FLT
				IFILE_AUX[*,NB_DIRECTIONS*IN_FNAME+IN_DIR] = MISSING_VALUE_FLT
				ROI_AVG_TOA_REF(*,NB_DIRECTIONS*IN_FNAME+IN_DIR) = MISSING_VALUE_FLT
				ROI_STD_TOA_REF(*,NB_DIRECTIONS*IN_FNAME+IN_DIR) = MISSING_VALUE_FLT
			ENDIF

		ENDFOR 

    IF (INGEST_SUNGLINT EQ 1) OR STRCMP(DB_DATA.SITE_TYPE[IN_FNAME], 'OCEAN', /FOLD_CASE) THEN BEGIN
        DB_DATA.THETA_N_MEAN[IN_FNAME] = MEAN_THETA_N/NB_DIRECTIONS
        DB_DATA.THETA_R_MEAN[IN_FNAME] = MEAN_THETA_R/NB_DIRECTIONS
    ENDIF
    
		; CASE NO ROI FOUND   
		IF NB_PIX_MAX LT MIN_PIXEL_NB_INGEST_PROCESS THEN BEGIN  
			GOTO, NO_ROI_FILE ; NEXT FILE
		ENDIF  

		IF (INGEST_SUNGLINT EQ 1) THEN BEGIN  

			; FIND UNIQUE INDEXES ACCROSS DIRECTIONS
			ROI_UNIQ = TOTAL_ROI[UNIQ(TOTAL_ROI, SORT(TOTAL_ROI))]
			ID_ROI_UNIQ = WHERE(ROI_UNIQ GT 0 , NB_PIX, COMPLEMENT=IDROIUNIQ, NCOMPLEMENT=COUNT_NOROIUNIQ)  
			
			IF NB_PIX GE MIN_PIXEL_NB_INGEST_PROCESS THEN BEGIN
				
				ROI_INDEX = ROI_UNIQ[ID_ROI_UNIQ]
				
        ; 3D TABLE INITIALISATION FOR SUNGLINT CLOUD SCREENING
        THETA_R_3D = MAKE_ARRAY(NB_PIX, NB_DIRECTIONS, /FLOAT, VALUE=MISSING_VALUE_FLT)
        RTOA_NIR_3D = MAKE_ARRAY(NB_PIX, NB_DIRECTIONS, /FLOAT, VALUE=MISSING_VALUE_FLT)
        CS_LATLON_3D = MAKE_ARRAY(NB_PIX, NB_BANDS+2+6, NB_DIRECTIONS, /FLOAT, VALUE=MISSING_VALUE_FLT)
        CLOUD_MASK = MAKE_ARRAY(NB_PIX, /FLOAT, VALUE=MISSING_VALUE_FLT)
        
        NB_PIX_MAX = NB_PIX
        
			ENDIF ELSE BEGIN
			
				IFILE_VIEW[*,NB_DIRECTIONS*IN_FNAME:NB_DIRECTIONS*IN_FNAME+NB_DIRECTIONS-1]= MISSING_VALUE_FLT
				IFILE_AUX[*,NB_DIRECTIONS*IN_FNAME:NB_DIRECTIONS*IN_FNAME+NB_DIRECTIONS-1] = MISSING_VALUE_FLT
				ROI_AVG_TOA_REF(*,NB_DIRECTIONS*IN_FNAME:NB_DIRECTIONS*IN_FNAME+NB_DIRECTIONS-1) = MISSING_VALUE_FLT
				ROI_STD_TOA_REF(*,NB_DIRECTIONS*IN_FNAME:NB_DIRECTIONS*IN_FNAME+NB_DIRECTIONS-1) = MISSING_VALUE_FLT

				GOTO, NO_ROI_FILE ; NEXT FILE
				
			ENDELSE

		ENDIF

		; GET NCDF INGESTION OUTPUT STRUCTURE
		;------------------------------------

		NCDF_INGEST_STRUCT = GET_NCDF_INGEST_STRUCT( NB_PIX_MAX, NB_DIRECTIONS, NB_BANDS, VERBOSE=VERBOSE)
		NCDF_INGEST_STRUCT.GLOBAL_ATT.SITE_NAME = DB_DATA.SITE_NAME[IN_FNAME]
		NCDF_INGEST_STRUCT.GLOBAL_ATT.SITE_TYPE = DB_DATA.SITE_TYPE[IN_FNAME]
		NCDF_INGEST_STRUCT.GLOBAL_ATT.SENSOR = DB_DATA.SENSOR[IN_FNAME]
		NCDF_INGEST_STRUCT.GLOBAL_ATT.PROCESSING_VERSION = DB_DATA.PROCESSING_VERSION[IN_FNAME]
		NCDF_INGEST_STRUCT.GLOBAL_ATT.ACQUISITION_DATE = ACQ_YEAR + '-' + ACQ_MONTH + '-' + ACQ_DAY + ' ' + DATE_HR + ':' + DATE_MIN
		NCDF_INGEST_STRUCT.GLOBAL_ATT.L1_FILENAME = DB_DATA.L1_FILENAME[IN_FNAME] 


		;----------------------------------
		; LOOP OVER DIRECTIONS
		MEAN_THETA_N = 0.0
		MEAN_THETA_R = 0.0
		NB_DIR_THETA = 0
		COUNT_CS_CLEAR_PIX_ARG_MIN = 2147483647L ; LONG MAX VALUE
    COUNT_CS_CLEAR_PIX_MAG_MIN = 2147483647L ; LONG MAX VALUE

		FOR IN_DIR = 0,NB_DIRECTIONS-1 DO BEGIN

			CUR_DIR = 'DIR' + STRING(FORMAT="(I2.2)",IN_DIR)
			IF KEYWORD_SET(VERBOSE) THEN BEGIN
				PRINT, FCT_NAME + ' [' + STRTRIM(STRING(IN_FNAME+1),1) + ' / ' + STRTRIM(STRING(NB_FILES),1) + '] : ' + DB_DATA.L1_FILENAME[IN_FNAME] + ' / DIRECTION = ' + CUR_DIR
			ENDIF    

			;------------------------------------------
			; RETRIEVE VIEWING GEOMETRIES

			TEMP_VAA = L1B_DATA.SAA - L1B_DATA.RAA[IN_DIR]  
			TEMP_ANGLES = DIMITRI_ANGLE_CORRECTOR(L1B_DATA.VZA[IN_DIR], TEMP_VAA, L1B_DATA.SZA[IN_DIR], L1B_DATA.SAA)

			;------------------------------------------
			; PROCESS SELECTION FOR SUNGLINT DETECTION/INGESTION OR NOT

			IF (INGEST_SUNGLINT EQ 1) THEN BEGIN  

				; SUNGLINT DETECTION
				
				NB_PIX=NB_PIX_MAX

				; OTHERWISE ROI IN SUNGLINT SPOT

				DB_DATA.ROI_PIX_NUM[IN_FNAME] = NB_PIX
				
				; NORTH HEMISPHERE 
				ICOORDS[0]=MAX(LATI(ROI_INDEX))
				ICOORDS[1]=MIN(LATI(ROI_INDEX))
				; WEST HEMISPHERE  
				ICOORDS[2]=MAX(LONGI(ROI_INDEX))
				ICOORDS[3]=MIN(LONGI(ROI_INDEX))     

				; UPDATE OF NETCDF FILES WITH SUNGLINT SPOT COORDINATES
				COORDINATES = STRJOIN(STRTRIM(STRING(ICOORDS),2),' ') ; NORTH SOUTH EAST WEST      
				DB_DATA.SITE_COORDINATES[IN_FNAME] = COORDINATES
				NCDF_OUT.ATT_SITEC  = COORDINATES

			ENDIF ELSE BEGIN
				; CLASSICAL INGEST / NOT FOR SUNGLINT

				; RETRIEVE INDEX OF NOMINAL DATA WITHIN ROI
				IF KEYWORD_SET(VERBOSE) THEN PRINT, FCT_NAME + ' - RETRIEVING INDEX OF PIXELS WITHIN ROI'
				ROI_INDEX = WHERE(LATI LT ICOORDS[0] AND $
													LATI GT ICOORDS[1] AND $
													LONGI LT ICOORDS[2] AND $
													LONGI GT ICOORDS[3] AND $
													L1B_DATA.REF_443NP[IN_DIR] GT 0.0 , $
													NB_PIX )

				; IF NO PIXELS IN ROI THEN DO NOT RETRIEVE TOA REFLECTANCE
				IF NB_PIX EQ 0 THEN GOTO, NO_ROI ; NEXT DIRECTION

				IF KEYWORD_SET(VERBOSE) THEN BEGIN
					PRINT, ' SITE AREA FOUND >> RAW PIXELS NB = ' + STRTRIM(STRING(NB_PIX),1)
				ENDIF  

				DB_DATA.ROI_PIX_NUM[IN_FNAME] = NB_PIX
				DB_DATA.SITE_COORDINATES[IN_FNAME] = NCDF_OUT.ATT_SITEC      

			ENDELSE

			;-----------------------------------------
			; CHECK ROI COVERAGE

			IF NB_PIX GT MIN_PIXEL_NB_INGEST_PROCESS THEN BEGIN
				IF INGEST_SUNGLINT EQ 0 THEN BEGIN
				  DB_DATA.ROI_STATUS[IN_FNAME] = CHECK_ROI_COVERAGE(L1B_DATA.LATITUDE,L1B_DATA.LONGITUDE,ROI_INDEX,ICOORDS,VERBOSE=VERBOSE)
        ENDIF
			ENDIF ELSE BEGIN
				DB_DATA.ROI_STATUS[IN_FNAME] = 0
				GOTO, NO_ROI
			ENDELSE  

			GOOD_RECORD[IN_FNAME]=1

			;------------------------------------------
			; GENERATE A QUICKLOOK WITH THE ROI OVERLAID

			IF N_ELEMENTS(NO_QUICKLOOK) EQ 0 THEN BEGIN

				OUTPUT_QL_FOLDER   = OUTPUT_FOLDER+'Site_'+IREGION+DL+SENSOR+DL+'Proc_'+IPROC+DL+ ACQ_YEAR + DL
				OUTPUT_QL_FILENAME = OUTPUT_QL_FOLDER + IREGION + '_' + SENSOR + '_' + IPROC +  '_' + ACQ_YEAR + ACQ_MONTH + ACQ_DAY + '_' + DATE_HR + DATE_MIN

				OUT_FOLDER_INFO = FILE_INFO(OUTPUT_QL_FOLDER)
				IF OUT_FOLDER_INFO.DIRECTORY EQ 0 THEN BEGIN
					FILE_MKDIR, OUTPUT_QL_FOLDER
					IF KEYWORD_SET(VERBOSE) THEN BEGIN      
						PRINT, FCT_NAME + ' - WARNING, OUTPUT YEAR FOLDER ''' + OUTPUT_QL_FOLDER + ''' NOT FOUND >> CREATED'
					ENDIF
				ENDIF

				IF KEYWORD_SET(VERBOSE) THEN PRINT, FCT_NAME + ' - GENERATE QUICKLOOK OF PRODUCT'
				OUTPUT_QL_FILENAME = OUTPUT_QL_FILENAME + '_' + CUR_DIR + '.jpg'
				IF FIX(CFIG_DATA.(1)[3]) EQ 1 THEN QL_STATUS =  GET_PARASOL_QUICKLOOK(IFILES[IN_FNAME],OUTPUT_QL_FILENAME,L1B_DATA=L1B_DATA,/ROI,/RGB,ICOORDS=ICOORDS,QL_QUALITY=QL_QUALITY,ENDIAN_SIZE=ENDIAN_SIZE,VERBOSE=VERBOSE,QL_DIR=IN_DIR) $
																			ELSE QL_STATUS =  GET_PARASOL_QUICKLOOK(IFILES[IN_FNAME],OUTPUT_QL_FILENAME,L1B_DATA=L1B_DATA,/ROI,ICOORDS=ICOORDS,QL_QUALITY=QL_QUALITY,ENDIAN_SIZE=ENDIAN_SIZE,VERBOSE=VERBOSE,QL_DIR=IN_DIR)

				IF KEYWORD_SET(VERBOSE) THEN $
					IF QL_STATUS EQ STATUS_ERROR THEN PRINT, FCT_NAME + ' - QUICKLOOK GENERATION FAILED - ',IFILES[IN_FNAME] $
														           ELSE PRINT, FCT_NAME + ' - QUICKLOOK GENERATION SUCCESS' 
			ENDIF   

			;------------------------------------------
			; INDEX OF ROW/COLUM IN THE IMAGE 
			; 
			s = SIZE(L1B_DATA.LATITUDE)
			NCOL = s(1)
			CS_COL = ROI_INDEX MOD NCOL
			CS_ROW = ROI_INDEX / NCOL

			;------------------------------------------
			; DEFINE ARRAY TO HOLD CS RHO      
			ADDBANDS=2   ; LAT + LON INDICES

			CS_RHO = MAKE_ARRAY(NB_PIX,NB_BANDS+ADDBANDS,/FLOAT,VALUE=BADVAL)

			;------------------------------------------
			; DEFINE ARRAY TO HOLD LAT/LON
			ADDANG=6  ; LAT/LON + 4 ANGLES (SZA, SAA, VZA, VAA)
      NBCOL_CS_LATLON = NB_BANDS + ADDBANDS + ADDANG
			
			CS_LATLON = FLTARR(NB_PIX,NBCOL_CS_LATLON)

			CS_LATLON[*,0] = L1B_DATA[ROI_INDEX].LATITUDE
			CS_LATLON[*,1] = L1B_DATA[ROI_INDEX].LONGITUDE

			;------------------------------------------
			; RETRIEVE VIEWING GEOMETRIES

			IFILE_VIEW[0,NB_DIRECTIONS*IN_FNAME+IN_DIR]=MEAN(TEMP_ANGLES.VZA[ROI_INDEX])
			IFILE_VIEW[1,NB_DIRECTIONS*IN_FNAME+IN_DIR]=MEAN(TEMP_ANGLES.VAA[ROI_INDEX])
			IFILE_VIEW[2,NB_DIRECTIONS*IN_FNAME+IN_DIR]=MEAN(TEMP_ANGLES.SZA[ROI_INDEX])
			IFILE_VIEW[3,NB_DIRECTIONS*IN_FNAME+IN_DIR]=MEAN(TEMP_ANGLES.SAA[ROI_INDEX])
			
  		;----------------------------------   
    
			CS_LATLON[*,2]=TEMP_ANGLES.SZA[ROI_INDEX] ; SZA  
			CS_LATLON[*,3]=TEMP_ANGLES.SAA[ROI_INDEX] ; SAA   
			CS_LATLON[*,4]=TEMP_ANGLES.VZA[ROI_INDEX] ; VZA   
			CS_LATLON[*,5]=TEMP_ANGLES.VAA[ROI_INDEX] ; VAA  

			TEMP_SZA = TEMP_ANGLES.SZA

			;------------------------------------- 
			;  SUNGLINT DETECTION ON MEAN VALUES (USED FOR CLOUD SCREENING CRITERIA)

			SUNGLINT_STATUS = 0    
			IF (INGEST_SUNGLINT EQ 1) OR STRCMP(DB_DATA.SITE_TYPE[IN_FNAME], 'OCEAN', /FOLD_CASE) THEN BEGIN

        RES = GET_SUNGLINT_ANGLES( TEMP_ANGLES.SZA, TEMP_ANGLES.VZA, TEMP_ANGLES.SAA, TEMP_ANGLES.VAA, THETA_N=THETA_N, THETA_R=THETA_R)      

				THETA_N = MEAN(THETA_N[ROI_INDEX])
				THETA_R = MEAN(THETA_R[ROI_INDEX])

        IF (THETA_R LE SG_THETA_R_MAX AND THETA_R GT 0.0) THEN SUNGLINT_STATUS = 2   ; RAYLEIGH CASE
        IF (THETA_N LE SG_THETA_N_MAX AND THETA_N GT 0.0) THEN SUNGLINT_STATUS = 1   ; SUNGLINT CASE

				IF (INGEST_SUNGLINT EQ 1) THEN $
				  IF (SUNGLINT_STATUS EQ 1) THEN DB_DATA.ROI_STATUS[IN_FNAME] = 1 $
				                            ELSE DB_DATA.ROI_STATUS[IN_FNAME] = 0
        IF DEBUG_MODE EQ 1 THEN BEGIN
          PRINT, ' DEBUG_MODE - DIR = ', IN_DIR
          PRINT, ' DEBUG_MODE - THETA_N = ', THETA_N
          PRINT, ' DEBUG_MODE - THETA_R = ', THETA_R
        ENDIF
        
        MEAN_THETA_N = MEAN_THETA_N + THETA_N
        MEAN_THETA_R = MEAN_THETA_R + THETA_R
        NB_DIR_THETA = NB_DIR_THETA + 1
        
			ENDIF

			;----------------------------------------
			; SET AUX INFORMATION AS MISSING

			IFILE_AUX[*,NB_DIRECTIONS*IN_FNAME+IN_DIR] = MISSING_VALUE_FLT

			;----------------------------------------
			; COMPUTE TOA REFLECTANCE FOR EACH BAND 

			IF KEYWORD_SET(VERBOSE) THEN PRINT, FCT_NAME + ' - STARTING LOOP OVER EACH BAND'

			FOR IN_BAND=0,NB_BANDS-1 DO BEGIN

				IN_BAND_INDEX = BAND_INDEX[IN_BAND]+BAND_OFFSET
				TEMP_REF = L1B_DATA.(IN_BAND_INDEX)[IN_DIR]
				TEMP_REF = TEMP_REF/COS(TEMP_SZA*!DTOR)

				VALID = WHERE(TEMP_REF(ROI_INDEX) GT 0.0 AND TEMP_REF(ROI_INDEX) LT 1.0,COUNT)

				IF VALID[0] GT -1 THEN BEGIN

					CS_RHO[VALID,IN_BAND] = FLOAT(TEMP_REF(ROI_INDEX[VALID]))

					ROI_AVG_TOA_REF(IN_BAND,NB_DIRECTIONS*IN_FNAME+IN_DIR) = MEAN(TEMP_REF(ROI_INDEX[VALID]))
					ROI_STD_TOA_REF(IN_BAND,NB_DIRECTIONS*IN_FNAME+IN_DIR) = STDDEV(TEMP_REF(ROI_INDEX[VALID]))

					NCDF_OUT.VAR_PIX[IN_BAND,IN_FNAME,IN_DIR] = COUNT
				ENDIF

			ENDFOR  ;END OF LOOP ON BANDS

			;-----------------------------------------
			; STORE DATA IN NETCDF STRUCTURE

			NCDF_OUT.VAR_VZA[IN_DIR,IN_FNAME]      = IFILE_VIEW[0,NB_DIRECTIONS*IN_FNAME+IN_DIR]
			NCDF_OUT.VAR_VAA[IN_DIR,IN_FNAME]      = IFILE_VIEW[1,NB_DIRECTIONS*IN_FNAME+IN_DIR]
			NCDF_OUT.VAR_SZA[IN_DIR,IN_FNAME]      = IFILE_VIEW[2,NB_DIRECTIONS*IN_FNAME+IN_DIR]
			NCDF_OUT.VAR_SAA[IN_DIR,IN_FNAME]      = IFILE_VIEW[3,NB_DIRECTIONS*IN_FNAME+IN_DIR]

			NCDF_OUT.VAR_RHOMU[*,IN_FNAME,IN_DIR]    = ROI_AVG_TOA_REF(*,NB_DIRECTIONS*IN_FNAME+IN_DIR)
			NCDF_OUT.VAR_RHOSD[*,IN_FNAME,IN_DIR]    = ROI_STD_TOA_REF(*,NB_DIRECTIONS*IN_FNAME+IN_DIR)
			NCDF_OUT.VAR_OZONEMU[IN_FNAME]  = IFILE_AUX[0,NB_DIRECTIONS*IN_FNAME+IN_DIR]
			NCDF_OUT.VAR_OZONESD[IN_FNAME]  = IFILE_AUX[1,NB_DIRECTIONS*IN_FNAME+IN_DIR]
			NCDF_OUT.VAR_PRESSMU[IN_FNAME]  = IFILE_AUX[2,NB_DIRECTIONS*IN_FNAME+IN_DIR]
			NCDF_OUT.VAR_PRESSSD[IN_FNAME]  = IFILE_AUX[3,NB_DIRECTIONS*IN_FNAME+IN_DIR]
			NCDF_OUT.VAR_RHUMMU[IN_FNAME]   = IFILE_AUX[4,NB_DIRECTIONS*IN_FNAME+IN_DIR]
			NCDF_OUT.VAR_RHUMSD[IN_FNAME]   = IFILE_AUX[5,NB_DIRECTIONS*IN_FNAME+IN_DIR]
			NCDF_OUT.VAR_ZONALMU[IN_FNAME]  = IFILE_AUX[6,NB_DIRECTIONS*IN_FNAME+IN_DIR]
			NCDF_OUT.VAR_ZONALSD[IN_FNAME]  = IFILE_AUX[7,NB_DIRECTIONS*IN_FNAME+IN_DIR]
			NCDF_OUT.VAR_MERIDMU[IN_FNAME]  = IFILE_AUX[8,NB_DIRECTIONS*IN_FNAME+IN_DIR]
			NCDF_OUT.VAR_MERIDSD[IN_FNAME]  = IFILE_AUX[9,NB_DIRECTIONS*IN_FNAME+IN_DIR]
			NCDF_OUT.VAR_WVAPMU[IN_FNAME]   = IFILE_AUX[10,NB_DIRECTIONS*IN_FNAME+IN_DIR]
			NCDF_OUT.VAR_WVAPSD[IN_FNAME]   = IFILE_AUX[11,NB_DIRECTIONS*IN_FNAME+IN_DIR]

			; ADD LAT/LON INDICES
			CS_RHO[*,NB_BANDS]    = CS_COL
			CS_RHO[*,NB_BANDS+1]  = CS_ROW

			CS_LATLON[*,6:NBCOL_CS_LATLON-1]=CS_RHO

			;----------------------------------
			; APPLY ARGANS CLOUD SCREENING
			CS_METHOD_ARG = 'GLOBCARBON_P'
			CS_PARASOL_ARG = DIMITRI_CLOUD_SCREENING(SENSOR, SITE_TYPE, CS_RHO, CS_LATLON[*,2:5], CS_METHOD_ARG, $
																		SUNGLINT_STATUS=SUNGLINT_STATUS, CS_CLASSIF_MATRIX=CS_CLASSIF_MATRIX_ARG, VERBOSE=VERBOSE)				
      
			; DETERMINATE PIXEL NUMBER DECLARED AS CS_VALID :: 'cloud screening valid indexes'
			INDX_CS_VALID_PIX_ARG = WHERE(CS_CLASSIF_MATRIX_ARG(*,0) NE MISSING_VALUE_LONG, COUNT_CS_VALID_PIX_ARG)
			; DETERMINATE PIXEL NUMBER DECLARED AS CS_CLEAR (NO CLOUD)
			; IN CS_TOTAL_PIXEL_CLASSIF : cloud =1 / clear =0 :: 'final cloud screening classification'
			INDX_CS_CLEAR_PIX_ARG = WHERE(CS_CLASSIF_MATRIX_ARG(*,1) EQ 0, COUNT_CS_CLEAR_PIX_ARG)    

			COUNT_CS_CLEAR_PIX_ARG_MIN = MIN( [ COUNT_CS_CLEAR_PIX_ARG_MIN, COUNT_CS_CLEAR_PIX_ARG ] )			

			IF KEYWORD_SET(VERBOSE) THEN BEGIN
				PRINT, ' CS ARGANS    - NB CLEAR PIXELS = ' + STRTRIM(STRING(COUNT_CS_CLEAR_PIX_ARG),1) + '/' + STRTRIM(STRING(COUNT_CS_VALID_PIX_ARG),1)
			ENDIF

			;----------------------------------
			; DATABASE STRUCTURE COMPLETION

      DB_DATA.AUTO_CS_1_NAME[IN_FNAME] = AUTO_CS_1_NAME + ' - ' + CS_METHOD_ARG
			DB_DATA.AUTO_CS_1_MEAN[IN_FNAME] = MAX( [ DB_DATA.AUTO_CS_1_MEAN[IN_FNAME], CS_PARASOL_ARG ] )
			DB_DATA.ROI_CS_1_CLEAR_PIX_NUM[IN_FNAME] = COUNT_CS_CLEAR_PIX_ARG_MIN

			;----------------------------------
			; NCDF INGESTION OUTPUT STRUCTURE COMPLETION

			NCDF_INGEST_STRUCT.VARIABLES.AUTO_CS_1_VALID_INDEX(0:NB_PIX-1, IN_DIR) = CS_CLASSIF_MATRIX_ARG(*,0)
			NCDF_INGEST_STRUCT.VARIABLES.AUTO_CS_1_MASK(0:NB_PIX-1, IN_DIR)        = CS_CLASSIF_MATRIX_ARG(*,1)
			
			;----------------------------------
			; APPLY MAGELLIUM CLOUD SCREENING
			
      IF INGEST_SUNGLINT EQ 1 THEN BEGIN
      
				;-----------------------------------------
        ; COMPLETE 3D TABLE FOR SUNGLINT CLOUD SCREENING PROCESS
        
        NIR_BAND = 7
        RTOA_NIR_3D[*,IN_DIR] = CS_RHO[*,NIR_BAND-1]
        THETA_R_3D[*,IN_DIR]  = THETA_R[ROI_INDEX]
        CS_LATLON_3D[*,*,IN_DIR] = CS_LATLON
        
      ENDIF ELSE BEGIN             
  
				;----------------------------------
				; APPLY MAGELLIUM CLOUD SCREENING
  			IF STRCMP(SITE_TYPE,'OCEAN',/FOLD_CASE) THEN BEGIN
  				CS_METHOD_MAG = 'PARASOL_OCEAN'
  				CS_PARASOL_MAG = DIMITRI_CLOUD_SCREENING(SENSOR, SITE_TYPE, CS_RHO, CS_LATLON[*,2:5], CS_METHOD_MAG, $
  																			SUNGLINT_STATUS=SUNGLINT_STATUS, CS_CLASSIF_MATRIX=CS_CLASSIF_MATRIX_MAG, VERBOSE=VERBOSE)     
  			ENDIF ELSE IF STRCMP(SITE_TYPE,'DESERT',/FOLD_CASE) THEN BEGIN
  				CS_METHOD_MAG = 'PARASOL_DESERT'
  				CS_PARASOL_MAG = DIMITRI_CLOUD_SCREENING(SENSOR, SITE_TYPE, CS_RHO, CS_LATLON[*,0:5], CS_METHOD_MAG, $
  																			CS_CLASSIF_MATRIX=CS_CLASSIF_MATRIX_MAG, VERBOSE=VERBOSE, $
  																			SITE_NAME=IREGION)
  			ENDIF ELSE BEGIN
  				CS_METHOD_MAG = 'GLOBCARBON_P'
  				CS_PARASOL_MAG = CS_PARASOL_ARG
          CS_CLASSIF_MATRIX_MAG = CS_CLASSIF_MATRIX_ARG
  			ENDELSE
  
				; DETERMINATE PIXEL NUMBER DECLARED AS CS_VALID :: 'cloud screening valid indexes'
				INDX_CS_VALID_PIX_MAG = WHERE(CS_CLASSIF_MATRIX_MAG(*,0) NE MISSING_VALUE_LONG, COUNT_CS_VALID_PIX_MAG)
				; DETERMINATE PIXEL NUMBER DECLARED AS CS_CLEAR (NO CLOUD)
				; IN CS_TOTAL_PIXEL_CLASSIF : cloud =1 / clear =0 :: 'final cloud screening classification'
				INDX_CS_CLEAR_PIX_MAG = WHERE(CS_CLASSIF_MATRIX_MAG(*,1) EQ 0, COUNT_CS_CLEAR_PIX_MAG)    

				COUNT_CS_CLEAR_PIX_MAG_MIN = MIN( [ COUNT_CS_CLEAR_PIX_MAG_MIN, COUNT_CS_CLEAR_PIX_MAG ] )
				
				IF KEYWORD_SET(VERBOSE) THEN BEGIN
					PRINT, ' CS MAGELLIUM - NB CLEAR PIXELS = ' + STRTRIM(STRING(COUNT_CS_CLEAR_PIX_MAG),1) + '/' + STRTRIM(STRING(COUNT_CS_VALID_PIX_MAG),1)
				ENDIF

				;----------------------------------
				; DATABASE STRUCTURE COMPLETION

        DB_DATA.AUTO_CS_2_NAME[IN_FNAME] = AUTO_CS_2_NAME + ' - ' + CS_METHOD_MAG
				DB_DATA.AUTO_CS_2_MEAN[IN_FNAME] = MAX( [ DB_DATA.AUTO_CS_2_MEAN[IN_FNAME], CS_PARASOL_MAG ] )
				DB_DATA.ROI_CS_2_CLEAR_PIX_NUM[IN_FNAME] = COUNT_CS_CLEAR_PIX_MAG_MIN
  
				;----------------------------------
				; NCDF INGESTION OUTPUT STRUCTURE COMPLETION

				NCDF_INGEST_STRUCT.VARIABLES.AUTO_CS_2_VALID_INDEX(0:NB_PIX-1, IN_DIR) = CS_CLASSIF_MATRIX_MAG(*,0)
				NCDF_INGEST_STRUCT.VARIABLES.AUTO_CS_2_MASK(0:NB_PIX-1, IN_DIR)        = CS_CLASSIF_MATRIX_MAG(*,1)
			
			ENDELSE
				
			;----------------------------------
			; NCDF INGESTION OUTPUT STRUCTURE COMPLETION

			NCDF_INGEST_STRUCT.GLOBAL_ATT.SITE_COORDINATES = DB_DATA.SITE_COORDINATES[IN_FNAME]
			NCDF_INGEST_STRUCT.GLOBAL_ATT.ROI_PIX_NUM = NB_PIX_MAX
      NCDF_INGEST_STRUCT.GLOBAL_ATT.AUTO_CS_1_NAME = DB_DATA.AUTO_CS_1_NAME[IN_FNAME]
			NCDF_INGEST_STRUCT.GLOBAL_ATT.AUTO_CS_1_MEAN = DB_DATA.AUTO_CS_1_MEAN[IN_FNAME]
			NCDF_INGEST_STRUCT.GLOBAL_ATT.ROI_CS_1_CLEAR_PIX_NUM = DB_DATA.ROI_CS_1_CLEAR_PIX_NUM[IN_FNAME]
      NCDF_INGEST_STRUCT.GLOBAL_ATT.AUTO_CS_2_NAME = DB_DATA.AUTO_CS_2_NAME[IN_FNAME]
			NCDF_INGEST_STRUCT.GLOBAL_ATT.AUTO_CS_2_MEAN = DB_DATA.AUTO_CS_2_MEAN[IN_FNAME]
			NCDF_INGEST_STRUCT.GLOBAL_ATT.ROI_CS_2_CLEAR_PIX_NUM = DB_DATA.ROI_CS_2_CLEAR_PIX_NUM[IN_FNAME]

			NCDF_INGEST_STRUCT.VARIABLES.ROI_STATUS[IN_DIR] = DB_DATA.ROI_STATUS[IN_FNAME]
			NCDF_INGEST_STRUCT.VARIABLES.ROI_PIXEL_NUMBER[IN_DIR] = NB_PIX

			NCDF_INGEST_STRUCT.VARIABLES.LAT(0:NB_PIX-1, IN_DIR) = CS_LATLON[*,0]
			NCDF_INGEST_STRUCT.VARIABLES.LON(0:NB_PIX-1, IN_DIR) = CS_LATLON[*,1]
			NCDF_INGEST_STRUCT.VARIABLES.SZA(0:NB_PIX-1, IN_DIR) = CS_LATLON[*,2]
			NCDF_INGEST_STRUCT.VARIABLES.SAA(0:NB_PIX-1, IN_DIR) = CS_LATLON[*,3]
			NCDF_INGEST_STRUCT.VARIABLES.VZA(0:NB_PIX-1, IN_DIR) = CS_LATLON[*,4]
			NCDF_INGEST_STRUCT.VARIABLES.VAA(0:NB_PIX-1, IN_DIR) = CS_LATLON[*,5]
			FOR BAND=0, NB_BANDS-1 DO BEGIN
				NCDF_INGEST_STRUCT.VARIABLES.REFL_BAND(0:NB_PIX-1, IN_DIR,BAND) = CS_LATLON[*,6+BAND]
			ENDFOR
			NCDF_INGEST_STRUCT.VARIABLES.PIXEL_COLUMN_INDICE(0:NB_PIX-1, IN_DIR) = CS_LATLON[*,6+NB_BANDS]
			NCDF_INGEST_STRUCT.VARIABLES.PIXEL_ROW_INDICE(0:NB_PIX-1, IN_DIR)    = CS_LATLON[*,6+NB_BANDS+1]

			;----------------------------------
			; METEO AUXILIARY DATA RETREIVING

			ACQUI_DATE = JULDAY(ACQ_MONTH,ACQ_DAY,ACQ_YEAR,DATE_HR,DATE_MIN,0)
			STATUS = GET_ALL_METEO_AUX_DATA( ACQUI_DATE, CS_LATLON[*,0], CS_LATLON[*,1], AUX_DATA_STRUCT=AUX_DATA_STRUCT, VERBOSE=VERBOSE)
			IF STATUS NE STATUS_OK THEN BEGIN
				; IF KEYWORD_SET(VERBOSE) THEN PRINT, FCT_NAME + ' - ERROR WHEN RETRIEVING METEO AUX DATA, DIRECTION SKIPPED'
				; GOTO, NO_ROI
        IF KEYWORD_SET(VERBOSE) THEN PRINT, FCT_NAME + ' - ERROR WHEN RETRIEVING METEO AUX DATA >> RETURNING'
				RETURN, STATUS_ERROR
			ENDIF    
			WIND_SPEED     = GET_CHANNEL_STRUCT(AUX_DATA_STRUCT,'WIND_SPEED')
			WIND_DIRECTION = GET_CHANNEL_STRUCT(AUX_DATA_STRUCT,'WIND_DIRECTION')
			OZONE          = GET_CHANNEL_STRUCT(AUX_DATA_STRUCT,'OZONE')
			PRESSURE       = GET_CHANNEL_STRUCT(AUX_DATA_STRUCT,'PRESSURE')
			WATERVAPOUR    = GET_CHANNEL_STRUCT(AUX_DATA_STRUCT,'WATERVAPOUR')
			CHLOROPHYLL    = GET_CHANNEL_STRUCT(AUX_DATA_STRUCT,'CHLOROPHYLL')

			NCDF_INGEST_STRUCT.VARIABLES.ERA_WIND_SPEED(0:NB_PIX-1, IN_DIR) = WIND_SPEED
			NCDF_INGEST_STRUCT.VARIABLES.ERA_WIND_DIR(0:NB_PIX-1, IN_DIR) = WIND_DIRECTION
			NCDF_INGEST_STRUCT.VARIABLES.ERA_OZONE(0:NB_PIX-1, IN_DIR) = OZONE
			NCDF_INGEST_STRUCT.VARIABLES.ERA_PRESSURE(0:NB_PIX-1, IN_DIR) = PRESSURE
			NCDF_INGEST_STRUCT.VARIABLES.ERA_WATERVAPOUR(0:NB_PIX-1, IN_DIR) = WATERVAPOUR
			NCDF_INGEST_STRUCT.VARIABLES.ESA_CHLOROPHYLL(0:NB_PIX-1, IN_DIR) = CHLOROPHYLL

			DB_DATA.ERA_WIND_SPEED_MEAN[IN_FNAME]  = MEAN(WIND_SPEED)
			DB_DATA.ERA_WIND_DIR_MEAN[IN_FNAME]    = MEAN(WIND_DIRECTION)
			DB_DATA.ERA_OZONE_MEAN[IN_FNAME]       = MEAN(OZONE)
			DB_DATA.ERA_PRESSURE_MEAN[IN_FNAME]    = MEAN(PRESSURE)
			DB_DATA.ERA_WATERVAPOUR_MEAN[IN_FNAME] = MEAN(WATERVAPOUR)
			DB_DATA.ESA_CHLOROPHYLL_MEAN[IN_FNAME] = MEAN(CHLOROPHYLL)
      
			NO_ROI:; IF ROI IS NOT WITHIN THE PRODUCT OR THERE ARE TOO FEW PIXELS
			
		ENDFOR
		; END OF LOOP ON DIRECTIONS
		
    IF (INGEST_SUNGLINT EQ 1) OR STRCMP(DB_DATA.SITE_TYPE[IN_FNAME], 'OCEAN', /FOLD_CASE) THEN BEGIN
  		DB_DATA.THETA_N_MEAN[IN_FNAME] = MEAN_THETA_N/DOUBLE(NB_DIR_THETA)
      DB_DATA.THETA_R_MEAN[IN_FNAME] = MEAN_THETA_R/DOUBLE(NB_DIR_THETA)
      NCDF_INGEST_STRUCT.VARIABLES_ATT.THETA_N_MEAN = DB_DATA.THETA_N_MEAN[IN_FNAME]
      NCDF_INGEST_STRUCT.VARIABLES_ATT.THETA_R_MEAN = DB_DATA.THETA_R_MEAN[IN_FNAME]
    ENDIF
    
    IF INGEST_SUNGLINT EQ 1 THEN BEGIN 
    
      ;-------------------------------------------------
      ; SUNGLINT CASE - MAGELLIUM CLOUD SCREENING WITH 3D PROCESS
      
      CS_METHOD_MAG = 'PARASOL_SUNGLINT'
      
      ; CLOUD MASK IMPROVMENT 
      ; IF THETA_R > 36 AND RTOA_NIR > 4,5% THEN CLOUD=1
      ; LOOP ON THE PIXELS
      NB_PIX = NB_PIX[0]
      FOR NUM_PT = 0, NB_PIX-1 DO BEGIN
        
        RES = WHERE( THETA_R_3D[NUM_PT,*] GT SG_THETA_R_MAX $
                   AND RTOA_NIR_3D[NUM_PT,*] GT MIN_NIR_SG_CS_PROCESS, COUNT_VIEW_IN_CLOUD)
        
        ; AS SOON AS A PIXEL IS DETECTED IN CLOUD (=1) IN ONE DIRECTION > THIS PIXEL IS DETECTED CLOUDY
        IF COUNT_VIEW_IN_CLOUD GT 3 THEN CLOUD_MASK[NUM_PT] = 1 $
                                    ELSE CLOUD_MASK[NUM_PT] = 0
                                    
      ENDFOR
      
      ; DETERMINATE PIXEL NUMBER DECLARED AS CS_VALID :: 'cloud screening valid indexes'
      COUNT_CS_VALID_PIX_MAG = NB_PIX
      ; DETERMINATE PIXEL NUMBER DECLARED AS CS_CLEAR (NO CLOUD)
      ; IN CS_TOTAL_PIXEL_CLASSIF : cloud =1 / clear =0 :: 'final cloud screening classification'
      INDX_CS_CLEAR_PIX_MAG = WHERE(CLOUD_MASK EQ 0, COUNT_CS_CLEAR_PIX_MAG, NCOMPLEMENT=COUNT_CS_CLOUD_PIX_MAG)    
  
			IF KEYWORD_SET(VERBOSE) THEN BEGIN
				PRINT, ' CS MAGELLIUM - NB CLEAR PIXELS = ' + STRTRIM(STRING(COUNT_CS_CLEAR_PIX_MAG),1) + '/' + STRTRIM(STRING(COUNT_CS_VALID_PIX_MAG),1)
			ENDIF

			;----------------------------------
			; DATABASE STRUCTURE COMPLETION

      DB_DATA.AUTO_CS_2_NAME[IN_FNAME] = AUTO_CS_2_NAME + ' - ' + CS_METHOD_MAG
			DB_DATA.AUTO_CS_2_MEAN[IN_FNAME] = FLOAT(COUNT_CS_CLOUD_PIX_MAG) / FLOAT(NB_PIX)
			DB_DATA.ROI_CS_2_CLEAR_PIX_NUM[IN_FNAME] = COUNT_CS_CLEAR_PIX_MAG

			;----------------------------------
			; NCDF INGESTION OUTPUT STRUCTURE COMPLETION

			NCDF_INGEST_STRUCT.GLOBAL_ATT.AUTO_CS_2_NAME = DB_DATA.AUTO_CS_2_NAME[IN_FNAME]
      NCDF_INGEST_STRUCT.GLOBAL_ATT.AUTO_CS_2_MEAN = DB_DATA.AUTO_CS_2_MEAN[IN_FNAME]
			NCDF_INGEST_STRUCT.GLOBAL_ATT.ROI_CS_2_CLEAR_PIX_NUM = DB_DATA.ROI_CS_2_CLEAR_PIX_NUM[IN_FNAME]

      FOR IN_DIR=0, NB_DIRECTIONS-1 DO BEGIN
			  NCDF_INGEST_STRUCT.VARIABLES.AUTO_CS_2_VALID_INDEX(0:NB_PIX-1, IN_DIR) = INDGEN(NB_PIX, /LONG)
        NCDF_INGEST_STRUCT.VARIABLES.AUTO_CS_2_MASK(0:NB_PIX-1, IN_DIR)        = CLOUD_MASK
      ENDFOR
          
    ENDIF
    
    ;----------------------------------
    ; NCDF INGESTION OUTPUT FILE WRITING

		STATUS = NETCDFWRITE_INGEST_OUTPUT(NCDF_INGEST_STRUCT, NCDF_FILENAME=NCDF_FILENAME, VERBOSE=VERBOSE)
		IF STATUS NE STATUS_OK THEN BEGIN
			IF KEYWORD_SET(VERBOSE) THEN PRINT, FCT_NAME + ' - ISSUE DURING NCDF INGESTION OUTPUT WRITING'
			RETURN, STATUS_ERROR
		ENDIF     

		DB_DATA.L1_INGESTED_FILENAME[IN_FNAME] = NCDF_FILENAME
    DB_DATA.ROI_STATUS[IN_FNAME] = MAX( [ DB_DATA.ROI_STATUS[IN_FNAME], NCDF_INGEST_STRUCT.VARIABLES.ROI_STATUS[*] ] )

		NCDF_OUT.VAR_CLOUD_AUT_1[IN_FNAME] = DB_DATA.AUTO_CS_1_MEAN[IN_FNAME]
		NCDF_OUT.VAR_CLOUD_AUT_2[IN_FNAME] = DB_DATA.AUTO_CS_2_MEAN[IN_FNAME]
		NCDF_OUT.VAR_CLOUD_MAN[IN_FNAME] = -1
		NCDF_OUT.VAR_ROI[IN_FNAME] = DB_DATA.ROI_STATUS[IN_FNAME]

		IF KEYWORD_SET(VERBOSE) THEN PRINT, FCT_NAME + ' - END OF LOOP ON PRODUCT'

    NO_ROI_FILE:
    
	ENDFOR; END OF FILE ANALYSIS

	;------------------------
	; DEFINE REPORT OUTPUT FOLDER

  OUTPUT_DIR_REPORT = STRING(OUTPUT_FOLDER+'Site_'+IREGION+DL+SENSOR+DL+'Proc_'+IPROC+DL+'REPORT'+DL)
  OUT_FOLDER_INFO = FILE_INFO(OUTPUT_DIR_REPORT)
  IF OUT_FOLDER_INFO.DIRECTORY EQ 0 THEN BEGIN
    FILE_MKDIR, OUTPUT_DIR_REPORT
    IF KEYWORD_SET(VERBOSE) THEN BEGIN      
      PRINT, FCT_NAME + ' - WARNING, OUTPUT REPORT FOLDER ''' + OUTPUT_DIR_REPORT + ''' NOT FOUND >> CREATED'
    ENDIF
  ENDIF

	;------------------------------------
	; SAVE DATA TO NETCDF REPORT FILE

  NCDF_MULTIFILE_FILENAME = OUTPUT_DIR_REPORT + IREGION + '_' + SENSOR + '_Proc_' + IPROC + '.nc'
  RES = DIMITRI_INTERFACE_EXTRACT_TOA_NCDF(NCDF_OUT,NCDF_MULTIFILE_FILENAME)  

	;------------------------------------
	; GENERATE PLOTS WITH NEW TIME SERIES DATA

  TAB_DIR = 'DIR' + STRING(FORMAT="(I2.2)",INDGEN(NB_DIRECTIONS)+1)
  RES = GET_INGESTION_TIMESERIES_PLOTS(NCDF_MULTIFILE_FILENAME,SENSOR,DIR_STR=TAB_DIR,COLOUR_TABLE=COLOUR_TABLE,PLOT_XSIZE=PLOT_XSIZE,PLOT_YSIZE=PLOT_YSIZE,VERBOSE=VERBOSE)

	;------------------------------------
	; AMEND DATA TO DATABASE

  IF KEYWORD_SET(VERBOSE) THEN PRINT, FCT_NAME + ' - SENDING DATA TO UPDATE DATABASE'
  RES = UPDATE_DIMITRI_DATABASE(DB_DATA,/SORT_DB,VERBOSE=VERBOSE)

	RETURN, STATUS_OK 
END