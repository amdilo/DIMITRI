;**************************************************************************************
;**************************************************************************************
;*
;* NAME:
;*      DIMITRI_INTERFACE_DESERT       
;* 
;* PURPOSE:
;*      MAIN DESERT CALIBRATION ROUTINES BASED ON L1B PRODUCT DATA
;* 
;* CALLING SEQUENCE:
;*      RES = DIMITRI_INTERFACE_DESERT(SITE_NAME,SENSOR,PROC_VERSION)      
;* 
;* INPUTS:
;*      SITE_NAME = A STRING CONTAINING THE NAME OF THE REGION TO BE USED
;*      SENSOR = A STRING CONTAINING THE NAME OF THE SENSOR TO BE USED
;*      PROC_VERSION = A STRING CONTAINING THE NAME OF THE PROCESSING_VERSION TO BE USED
;*
;* KEYWORDS:
;*      ALL      - SET TO SEARCH FOR ALL DIMITRI PRODUCTS
;*      YEAR     - A STRING OF THE YEAR TO BE INGESTED (E.G. '2002')
;*      VERBOSE  - PROCESSING STATUS OUTPUTS
;*
;* OUTPUTS:
;*      STATUS   - 1: NOMINAL, (-1): ERROR, 0: NO PRODUCTS FOUND
;*
;* COMMON BLOCKS:
;*      NONE
;*
;* MODIFICATION HISTORY:
;*      04 DEC 2013 - PML / MAGELLIUM - CREATION
;*      17 FEB 2015 - NCG / MAGELLIUM - UPDATE WITH DIMITRI V4.0 SPECIFICATIONS
;*
;* VALIDATION HISTORY:
;*      17 APR 2014 - PML / MAGELLIUM - WINDOWS 64-BIT MACHINE IDL 8.2.3 : COMPILATION AND CALLING SUCCESSFUL
;*      20 JAN 2015 - NCG / MAGELLIUM - WINDOWS 64BIT MACHINE IDL 8.0: COMPILATION AND OPERATION SUCCESSFUL 
;*      30 MAR 2015 - NCG / MAGELLIUM      - WINDOWS 64BIT MACHINE IDL 8.0: COMPILATION AND OPERATION SUCCESSFUL (DIMITRI V4.0) 
;*
;**************************************************************************************
;**************************************************************************************

FUNCTION DIMITRI_INTERFACE_DESERT,SITE_NAME,SENSOR,PROC_VERSION,ALL=ALL,YEAR=YEAR,VERBOSE=VERBOSE

  DEBUG_MODE = 0      ; SET TO 1 IF WANT TO DEBUG THIS PROCEDURE
  
  FCT_NAME = 'DIMITRI_INTERFACE_DESERT'
  
  METHOD = 'DESERT_MAG'
  
  STATUS_OK = GET_DIMITRI_LOCATION('STATUS_OK')
  STATUS_ERROR = GET_DIMITRI_LOCATION('STATUS_ERROR')

  ;----------------------
  DL            = GET_DIMITRI_LOCATION('DL')
  DIMITRI_DB    = GET_DIMITRI_LOCATION('DATABASE',VERBOSE=VERBOSE)
  INPUT_FOLDER  = GET_DIMITRI_LOCATION('INGESTION_OUTPUT')
  OUTPUT_FOLDER = GET_DIMITRI_LOCATION('OUTPUT')
  MISSING_VALUE_FLT = FLOAT(GET_DIMITRI_LOCATION('NCDF_MISSING_VALUE'))
  MIN_PIXEL_NB_CALIB_PROCESS=GET_DIMITRI_LOCATION('MIN_PIXEL_NB_CALIB_PROCESS')
  PRESSURE_CSTE = FLOAT(GET_DIMITRI_LOCATION('PRESSURE_CSTE')) ; PRESSURE AS CONSTANTE VALUE / USED IN SMAC CALC
  TAUP_550 = FLOAT(GET_DIMITRI_LOCATION('TAUP_550')) ; AEROSOL OPTICAL THICKNESS
        
  ;---------------------
  ; SEARCH FOR DATA PRODUCTS

  IF KEYWORD_SET(VERBOSE) THEN PRINT, FCT_NAME + ': RETRIEVING PRODUCT SEARCH FILTER'
  SEARCH_FOLDER = INPUT_FOLDER + DL + 'Site_' + SITE_NAME + DL + SENSOR + DL + 'Proc_' + PROC_VERSION + DL
  SEARCH_FILTER = SITE_NAME + '_' + SENSOR + '_' + PROC_VERSION + '_*.nc'
  
  ;----------------------
  ;  READ THE DIMITRI DATABASE 

  IF KEYWORD_SET(VERBOSE) THEN PRINT, FCT_NAME + ': CHECKING EXISTENCE OF DATABASE FILE'  
  DB_TEMPLATE = GET_DIMITRI_TEMPLATE(1,/TEMPLATE)   
  DB_TEMP = FILE_INFO(DIMITRI_DB)
  IF DB_TEMP.EXISTS EQ 0 THEN BEGIN
    DB_CHECK = 0
    IF KEYWORD_SET(VERBOSE) THEN PRINT, FCT_NAME + ': DATABASE FILE NOT FOUND'
  ENDIF ELSE BEGIN
    DB_CHECK = 1
    DB_DATA = READ_ASCII(DIMITRI_DB,TEMPLATE=DB_TEMPLATE)
  ENDELSE

  ;----------------------
  ; GET FILES FROM DATABASE
  
  IF KEYWORD_SET(ALL) THEN BEGIN
    ; WITHOUT YEAR FILTERING
    IDX_FILES = WHERE( STRCMP(DB_DATA.SENSOR,SENSOR,/FOLD_CASE) EQ 1 AND $
                       STRCMP(DB_DATA.SITE_NAME,SITE_NAME,/FOLD_CASE) EQ 1 AND $
                       STRCMP(DB_DATA.PROCESSING_VERSION,PROC_VERSION,/FOLD_CASE) EQ 1 AND $
                       DB_DATA.ROI_STATUS EQ 1 , NB_FILES) 

  ENDIF ELSE BEGIN
    ; WITH YEAR FILTERING
    IDX_FILES = WHERE( STRCMP(DB_DATA.SENSOR,SENSOR,/FOLD_CASE) EQ 1 AND $
                       STRCMP(DB_DATA.SITE_NAME,SITE_NAME,/FOLD_CASE) EQ 1 AND $
                       STRCMP(DB_DATA.PROCESSING_VERSION,PROC_VERSION,/FOLD_CASE) EQ 1 AND $
                       DB_DATA.ROI_STATUS EQ 1 AND $
                       DB_DATA.YEAR EQ LONG(YEAR) , NB_FILES)        
  ENDELSE

  IF NB_FILES EQ 0 THEN BEGIN
    PRINT, FCT_NAME + ': NO PRODUCTS FOR CALIBRATION'
    RETURN, 0
  ENDIF

  ;----------------------
  ; GET INGESTION OUTPUT FILENAME FROM DATABASE
  
  I_FILES = SEARCH_FOLDER + DL + STRTRIM(STRING(DB_DATA.YEAR[IDX_FILES]),2) + DL + DB_DATA.L1_INGESTED_FILENAME[IDX_FILES]
  FILE_RESULT = FILE_SEARCH(I_FILES, COUNT=NB_FILES_SEARCH)
  
  IF NB_FILES_SEARCH NE NB_FILES THEN BEGIN
    IF KEYWORD_SET(VERBOSE) THEN PRINT, FCT_NAME + ': THE NUMBER OF INGESTION PRODUCTS ON DISK (', NB_FILES_SEARCH, $
                                                    ') DOES NOT MATCH THE NUMBER OF INGESTED PRODUCT IN THE DATABASE (', NB_FILES, ')'
    RETURN, STATUS_ERROR
  ENDIF
  
  ;----------------------
  ; GET BAND INFO STRUCTURE (NB_BANDS, BAND_ID, BAND_LABEL_STD, BAND_WAVELENGTH)
  
  CUR_SENSOR_BAND_INFOS = GET_SENSOR_BAND_INFO(SENSOR)
  MODIS_SENSOR_BAND_INFOS = GET_SENSOR_BAND_INFO('MODISA')
   
  NB_BANDS_SENSOR  = CUR_SENSOR_BAND_INFOS.NB_BAND
  NB_DIRECTIONS = SENSOR_DIRECTION_INFO(SENSOR)
  NB_DIRECTIONS = NB_DIRECTIONS[0]

  SENSOR_CONFIG = GET_SENSOR_BAND_CONFIG(SENSOR) ; GET USED CHANNELS / STD LABELS / SMAC FILENAME / LUT FILENAME

  ;-------------------
  ; COMPUTE SENSOR BAND WAVELENGTH TO PROCESS 
  
  SENSOR_BAND_WAVELENGTH = CUR_SENSOR_BAND_INFOS.BAND_WAVELENGTH
  MODIS_BRDF_INFOS = GET_MODIS_BRDF_INFOS()
  BAND_WAVELENGTH_MODIS_MIN = MIN(MODIS_BRDF_INFOS.BAND, MAX=BAND_WAVELENGTH_MODIS_MAX)
  IDX_BANDS_SENSOR_PROCESS = WHERE(SENSOR_BAND_WAVELENGTH GE BAND_WAVELENGTH_MODIS_MIN $
                                AND SENSOR_BAND_WAVELENGTH LE BAND_WAVELENGTH_MODIS_MAX, NB_BANDS_SENSOR_PROCESS)

  IF NB_BANDS_SENSOR_PROCESS EQ 0 THEN BEGIN
    IF KEYWORD_SET(VERBOSE) THEN PRINT, ': NO SENSOR BAND WAVELENGTHS INSIDE THE MODIS WAVELENGTH RANGE >> RETURNING'
    RETURN, STATUS_ERROR
  ENDIF
  
  ;----------------------
  ; GET SMAC COEFFICIENTS
  ; SMAC_FILE_STRUCT = { SMAC_FILE_EXIST, SMAC_FILE_LABEL, SMAC_COEFFS }
  
  IF KEYWORD_SET(VERBOSE) THEN PRINT, FCT_NAME + ': READ SMAC COEFFICIENTS FOR SENSOR : ' + SENSOR
  STATUS = GET_SMAC_COEFFICIENTS(SENSOR, SMAC_FILE_STRUCT=SMAC_FILE_STRUCT, VERBOSE=VERBOSE)
  IF STATUS NE STATUS_OK THEN BEGIN
    IF KEYWORD_SET(VERBOSE) THEN PRINT, FCT_NAME + ': ERROR DURING SMAC COEFFICIENTS RETRIEVING >> RETURNING'
    RETURN, STATUS
  ENDIF

  IDX_SMAC_FILE_EXIST = WHERE(SMAC_FILE_STRUCT.SMAC_FILE_EXIST EQ 1, COUNT_SMAC_FILE)
  IF COUNT_SMAC_FILE EQ 0 THEN BEGIN
    IF KEYWORD_SET(VERBOSE) THEN PRINT, FCT_NAME + ': NO SMAC FILE AVAILABLE FOR SENSOR ', SENSOR, ' >> RETURNING'
    RETURN, STATUS_ERROR
  ENDIF
    
  ;----------------------
  ; GET THE SOLAR IRRADIANCE AND THE SPECTRAL RESPONSE (6S)
  
  SOLAR_IRRADIANCE = GET_SOLAR_IRRADIANCE(VERBOSE=VERBOSE)
  SOLAR_WAV_MIN = MIN( SOLAR_IRRADIANCE.WAVELENGTH, MAX=SOLAR_WAV_MAX)
  
;  REP6S = GET_SPECTRAL_RESPONSE(SENSOR, VERBOSE=VERBOSE)
  REP6S = FLTARR(N_ELEMENTS(SOLAR_IRRADIANCE.WAVELENGTH), NB_BANDS_SENSOR+1)
  REP6S[*,0] = SOLAR_IRRADIANCE.WAVELENGTH
  RSR_TEMPLATE  = GET_DIMITRI_RSR_TEMPLATE()
  
  SPECTRAL_RESAMPLING = 2.5 ; NM
  
  FOR NUM_BAND=0, NB_BANDS_SENSOR-1 DO BEGIN
    
    ; DEFINE NAME OF THE SPECTRAL RESPONSE FILE
    FILTER_FILENAME = GET_DIMITRI_LOCATION('RSR')+SENSOR+DL+'RSR_'+SENSOR+'_BAND_'+STRTRIM(NUM_BAND, 2)+'.txt'
    RES = FILE_INFO(FILTER_FILENAME)
    IF RES.EXISTS EQ 0 THEN BEGIN
      IF KEYWORD_SET(VERBOSE) THEN PRINT, FCT_NAME + ': WARNING, SPECTRAL RESPONSE FILE NOT FOUND', FILTER_FILENAME
      GOTO, NEXT_SPECTRAL_BAND
    ENDIF

    ; READ THE SPECTRAL RESPONSE
    SPECTRAL_RESPONSE = READ_ASCII(FILTER_FILENAME, TEMPLATE=RSR_TEMPLATE)
    
    MIN = MIN(SPECTRAL_RESPONSE.WAVELENGTH, MAX=MAX)
    
    IF (MIN MOD SPECTRAL_RESAMPLING) EQ 0.0 THEN GRID_MIN = MIN $
                                            ELSE GRID_MIN = FIX( MIN / SPECTRAL_RESAMPLING ) * SPECTRAL_RESAMPLING + SPECTRAL_RESAMPLING

    IF (MAX MOD SPECTRAL_RESAMPLING) EQ 0.0 THEN GRID_MAX = MAX $
                                            ELSE GRID_MAX = FIX( MAX / SPECTRAL_RESAMPLING ) * SPECTRAL_RESAMPLING
    
    ; CHECK THE EXTENTOF THE WAVELENGTH REGARDING THE EXTENT OF THE SOLAR WAVELENGTH TABLE
    GRID_MIN = MAX( [ SOLAR_WAV_MIN*1000.0, GRID_MIN ] )
    GRID_MAX = MIN( [ SOLAR_WAV_MAX*1000.0, GRID_MAX ] )
    IF GRID_MAX LT GRID_MIN THEN BEGIN
      IF KEYWORD_SET(VERBOSE) THEN PRINT, FCT_NAME + ': WARNING, SPECTRAL RESPONSE OUT OF SOLAR IRRADIANCE WAVELENGTH TABLE (BAND ', STRTRIM(NUM_BAND+1, 2), ')'
      GOTO, NEXT_SPECTRAL_BAND
    ENDIF
    
    GRID = INDGEN(CEIL((GRID_MAX-GRID_MIN)/SPECTRAL_RESAMPLING))*SPECTRAL_RESAMPLING+GRID_MIN
    NBWAV = N_ELEMENTS(GRID)
    
    ; INTERPOLATE THE SPECTRAL RESPONSE WITH THE SOLAR IRRADIANCE GRID
    RESAMPLED_SPECTRAL_RESPONSE=INTERPOL(SPECTRAL_RESPONSE.RESPONSE, SPECTRAL_RESPONSE.WAVELENGTH, GRID)

    GRID = GRID/1000.0
    IDX_MIN = WHERE(REP6S[*,0] EQ GRID_MIN/1000.0, COUNT)
    IF COUNT EQ 0 THEN RETURN, ERROR_STATUS
    IDX_MIN = IDX_MIN[0]
    
    REP6S[IDX_MIN:IDX_MIN+NBWAV-1,NUM_BAND+1] = RESAMPLED_SPECTRAL_RESPONSE
    
    NEXT_SPECTRAL_BAND:
    
  ENDFOR  
  

  ;----------------------
  ; SET OUTPUT CALIB FOLDER
  
  CALDAT, SYSTIME(/UTC,/JULIAN),TMM,TDD,TYY,THR,TMN,TSS

  TYY = STRTRIM(STRING(TYY),2)
  TMM = TMM LT 10 ? '0'+STRTRIM(STRING(TMM),2) : STRTRIM(STRING(TMM),2)
  TDD = TDD LT 10 ? '0'+STRTRIM(STRING(TDD),2) : STRTRIM(STRING(TDD),2)
  THR = THR LT 10 ? '0'+STRTRIM(STRING(THR),2) : STRTRIM(STRING(THR),2)
  TMN = TMN LT 10 ? '0'+STRTRIM(STRING(TMN),2) : STRTRIM(STRING(TMN),2)
  TSS = TSS LT 10 ? '0'+STRTRIM(STRING(TSS,FORMAT='(I)'),2) : STRTRIM(STRING(TSS,FORMAT='(I)'),2)

  PROCESS_DATE = TYY+TMM+TDD+'-'+THR+TMN

  OUT_FILEPATH = OUTPUT_FOLDER + DL + METHOD + '_' + PROCESS_DATE + DL + 'Site_'+ SITE_NAME + DL + SENSOR + DL + 'Proc_' + PROC_VERSION + DL
  OUT_FILENAME_BASE =  SITE_NAME + '_' + SENSOR + '_' + PROC_VERSION + '_' + METHOD 
          
  ;----------------------
  ; LOOP OVER NCDF FILE IN PROCESSING DATASET
  
  FOR IDX_FILE=0, NB_FILES-1 DO BEGIN

    NCDF_FILENAME = FILE_RESULT[IDX_FILE]
    NCDF_INFOS = FILE_INFO(NCDF_FILENAME)
    
    IF NCDF_INFOS.EXISTS EQ 0 OR STRLEN(NCDF_FILENAME) EQ 0 THEN BEGIN
      IF KEYWORD_SET(VERBOSE) THEN PRINT,FCT_NAME + ': FILE ',NCDF_FILENAME,' IS MISSING, PLEASE CHECK YOUR INGESTION PROGRESS'
      GOTO, NEXT_IFILES
    ENDIF

    CUR_NCFILE = FILE_BASENAME(NCDF_FILENAME)
    
    ;----------------------
    ; GET ACQUISITION DATE FROM NCDF FILE
    CUR_NCDF_DATE = STRTRIM(GET_NCDF_GLOBAL_ATT(NCDF_FILENAME, 'ACQUISITION_DATE'))
    NCDF_YEAR_STR=STRMID(CUR_NCDF_DATE,0,4)
    NCDF_MONTH_STR=STRMID(CUR_NCDF_DATE,5,2)
    NCDF_DAY_STR=STRMID(CUR_NCDF_DATE,8,2)
    NCDF_HOURS_STR=STRMID(CUR_NCDF_DATE,11,2)
    NCDF_MINUTES_STR=STRMID(CUR_NCDF_DATE,14,2)
    
    NCDF_YEAR=UINT(NCDF_YEAR_STR)
    NCDF_MONTH=UINT(NCDF_MONTH_STR)
    NCDF_DAY=UINT(NCDF_DAY_STR)
    NCDF_HOURS=UINT(NCDF_HOURS_STR)
    NCDF_MINUTES=UINT(NCDF_MINUTES_STR)
    
    ACQUI_DATE = JULDAY(NCDF_MONTH,NCDF_DAY,NCDF_YEAR,NCDF_HOURS,NCDF_MINUTES,0)
    
    IF KEYWORD_SET(VERBOSE) THEN BEGIN
      PRINT, '[' + STRTRIM(STRING(IDX_FILE+1),1) + '/' + STRTRIM(STRING(NB_FILES),1) + '] > ' + FCT_NAME + ' ' + CUR_NCFILE + ' :: ' + CUR_NCDF_DATE
    ENDIF
    
    ;----------------------
    ; CHECK ACQUISITION DATE WITH BRDF PERIOD
    BRDF_FILE_REF_2008_01_01=JULDAY(01,01,2008) ; BRDF FILES ARE DEFINED ON PERIOD 2008-2012
    BRDF_FILE_REF_2012_12_31=JULDAY(12,31,2012) ; BRDF FILES ARE DEFINED ON PERIOD 2008-2012  
    
    IF ACQUI_DATE LT BRDF_FILE_REF_2008_01_01 OR ACQUI_DATE GT BRDF_FILE_REF_2012_12_31 THEN BEGIN
      IF KEYWORD_SET(VERBOSE) THEN BEGIN
        PRINT, FCT_NAME + ': FILE ', FILE_BASENAME(NCDF_FILENAME),' IS SKIPPED, DESERT VICARIOUS CALIBRATION IS ONLY AVAILABLE IN PERIOD [2008-2012]'
      ENDIF
      GOTO, NEXT_IFILES
    ENDIF          
    
    ;----------------------
    ; READ INPUT INGESTION FILE
    
    STATUS = NETCDFREAD_INGEST_OUTPUT( NCDF_FILENAME, NCDF_INGEST_STRUCT=NCDF_INGEST_STRUCT, VERBOSE=VERBOSE)
    IF STATUS NE STATUS_OK THEN BEGIN
      IF KEYWORD_SET(VERBOSE) THEN BEGIN
        PRINT, FCT_NAME + ': ERROR DURING ', FILE_BASENAME(NCDF_FILENAME),' FILE READING >> FILE SKIPPED'
      ENDIF
      GOTO, NEXT_IFILES
    ENDIF  
        
    IF NB_DIRECTIONS NE NCDF_INGEST_STRUCT.DIMENSIONS.VIEWDIR_NUMBER THEN BEGIN
      IF KEYWORD_SET(VERBOSE) THEN BEGIN
        PRINT, FCT_NAME + ': NUMBER OF VIEWING DIRECTIONS IN NCDF FILE (', NCDF_INGEST_STRUCT.DIMENSIONS.VIEWDIR_NUMBER, $
                              ') DOES NOT MATCH TO THE NUMBER OF SENSOR VIEWING DIRECTION (', NB_DIRECTIONS, ') >> FILE SKIPPED'
      ENDIF
      GOTO, NEXT_IFILES
    ENDIF
         
    ;----------------------
    ; COMPUTE MAXIMAL COUNT PIXEL CLEAR ACROSS DIRECTION FOR AN ESTIMATION OF VALID CALIBRATION PIXELS

    COUNT_CS_CLEAR_PIX_MAX = 0
    FOR NUM_DIR=0, NB_DIRECTIONS-1 DO BEGIN
      INDX_CS_MASK_CLEAR = WHERE(NCDF_INGEST_STRUCT.VARIABLES.AUTO_CS_2_MASK(*,NUM_DIR) EQ 0, COUNT_CS_CLEAR_PIX)
      COUNT_CS_CLEAR_PIX_MAX = MAX( [ COUNT_CS_CLEAR_PIX_MAX, COUNT_CS_CLEAR_PIX ] )
    ENDFOR
    
    IF COUNT_CS_CLEAR_PIX_MAX LT MIN_PIXEL_NB_CALIB_PROCESS THEN BEGIN
      IF KEYWORD_SET(VERBOSE) THEN BEGIN
        PRINT, ' NB_CLEAR_PIX = ' + STRTRIM(STRING(COUNT_CS_CLEAR_PIX_MAX),1) + ' < MIN_PIXEL_NB_CALIB_PROCESS : FILE SKIPPED FOR DESERT CALIBRATION'
      ENDIF 
      GOTO, NEXT_IFILES
    ENDIF 
    
    ;----------------------
    ; GET NCDF STRUCTURE FOR CALIBRATION OUTPUT
    
    CALIB_PIXEL_NUMBER = COUNT_CS_CLEAR_PIX_MAX
    
    NCDF_CALIB_STRUCT = GET_NCDF_CALIB_STRUCT(CALIB_PIXEL_NUMBER, NCDF_INGEST_STRUCT.DIMENSIONS.ROI_PIXEL_NUMBER, NB_DIRECTIONS, NB_BANDS_SENSOR_PROCESS, VERBOSE=VERBOSE)
    NCDF_CALIB_STRUCT.GLOBAL_ATT.CALIBRATION_METHOD = METHOD
    NCDF_CALIB_STRUCT.VARIABLES.REFL_BAND_IDS = IDX_BANDS_SENSOR_PROCESS
    
    ;----------------------
    ; COPY COMMON INFOS FROM INGESTION NCDF TO CALIBRATION NCDF
    STATUS = COPY_INGESTION_TO_CALIBRATION_NCDF_STRUCTURE(NCDF_INGEST_STRUCT=NCDF_INGEST_STRUCT, NCDF_CALIB_STRUCT=NCDF_CALIB_STRUCT, VERBOSE=VERBOSE)
    IF STATUS NE STATUS_OK THEN RETURN, STATUS
    
    ;----------------------
    ; LOOP OVER VIEWING DIRECTION
    
    AT_LEAST_ONE_DIR = 0
    
    FOR NUM_DIR=0, NB_DIRECTIONS-1 DO BEGIN
                  
      IF NUM_DIR+1 LT 10 THEN DIR_ID = 'DIR0' + STRTRIM(STRING(NUM_DIR+1),2) $
                         ELSE DIR_ID = 'DIR' + STRTRIM(STRING(NUM_DIR+1),2)
                          
      IF KEYWORD_SET(VERBOSE) THEN BEGIN
        PRINT, FCT_NAME + ': ----- PROCESS DIRECTION [' + DIR_ID + '/' + STRTRIM(STRING(NB_DIRECTIONS),1) + ']'
      ENDIF
      
      IF NCDF_INGEST_STRUCT.VARIABLES.ROI_STATUS[NUM_DIR] EQ 0 THEN BEGIN
        IF KEYWORD_SET(VERBOSE) THEN BEGIN
          PRINT, FCT_NAME + ': ROI STATUS WITH 0 VALUE >> DIRECTION SKIPPED'
        ENDIF
        GOTO, NEXT_DIR
      ENDIF
      
      ;----------------------
      ; CHECK COUNT_CS_CLEAR_PIX 
      
      ; CLOUD SCREENING RESULT 1=CLOUD 0=CLEAR
      CLOUD_MASK = NCDF_INGEST_STRUCT.VARIABLES.AUTO_CS_2_MASK(*,NUM_DIR)

      ; IDENTIFY AND SELECT CLEAR PIXELS ACCORDING CLOUD SCREENING MASK
      INDX_CS_MASK_CLEAR = WHERE(CLOUD_MASK EQ 0, COUNT_CS_CLEAR_PIX)
      
      IF COUNT_CS_CLEAR_PIX LT MIN_PIXEL_NB_CALIB_PROCESS THEN BEGIN
        IF KEYWORD_SET(VERBOSE) THEN BEGIN
          PRINT, ' NB_CLEAR_PIX = ' + STRTRIM(STRING(COUNT_CS_CLEAR_PIX),1) + ' < MIN_PIXEL_NB_CALIB_PROCESS : DIRECTION SKIPPED FOR DESERT CALIBRATION'
        ENDIF 
        GOTO, NEXT_DIR
      ENDIF 

      NB_PIX = COUNT_CS_CLEAR_PIX
      NCDF_CALIB_STRUCT.VARIABLES.CALIB_PIXEL_NUMBER(NUM_DIR) = NB_PIX
      
      ;----------------------
      ; GET VARIABLES FROM NCDF DATA STRUCTURE
      
      LAT = NCDF_INGEST_STRUCT.VARIABLES.LAT(*,NUM_DIR)    ; LATITUDE
      LON = NCDF_INGEST_STRUCT.VARIABLES.LON(*,NUM_DIR)    ; LONGITUDE
      
      THETA_S = NCDF_INGEST_STRUCT.VARIABLES.SZA(*,NUM_DIR) ; SUN ZENITH ANGLE
      PHI_S   = NCDF_INGEST_STRUCT.VARIABLES.SAA(*,NUM_DIR) ; SUN AZIMUTH ANGLE
      THETA_V = NCDF_INGEST_STRUCT.VARIABLES.VZA(*,NUM_DIR) ; VIEWING ZENITH ANGLE
      PHI_V   = NCDF_INGEST_STRUCT.VARIABLES.VAA(*,NUM_DIR) ; VIEWING AZIMUTH ANGLE
      
      ; GET METEO AUX_DATA 
      WATERVAPOUR = NCDF_INGEST_STRUCT.VARIABLES.ERA_WATERVAPOUR(*,NUM_DIR)
      OZONE = NCDF_INGEST_STRUCT.VARIABLES.ERA_OZONE(*,NUM_DIR)
      PRESSURE = NCDF_INGEST_STRUCT.VARIABLES.ERA_PRESSURE(*,NUM_DIR)
          
      ;----------------------
      ; LIMIT INPUT DATA TO CS CLEAR PIXELS
      
      LAT_VLD     = LAT(INDX_CS_MASK_CLEAR)
      LON_VLD     = LON(INDX_CS_MASK_CLEAR)
      THETA_S_VLD = THETA_S(INDX_CS_MASK_CLEAR)
      PHI_S_VLD   = PHI_S(INDX_CS_MASK_CLEAR)
      THETA_V_VLD = THETA_V(INDX_CS_MASK_CLEAR)
      PHI_V_VLD   = PHI_V(INDX_CS_MASK_CLEAR)
      WATERVAPOUR_VLD = WATERVAPOUR(INDX_CS_MASK_CLEAR)
      OZONE_VLD = OZONE(INDX_CS_MASK_CLEAR)
      PRESSURE_VLD = PRESSURE(INDX_CS_MASK_CLEAR)
      
      DPHI_VLD = ABS(PHI_S_VLD - PHI_V_VLD)
      INDX_DPHI_INV=WHERE(DPHI_VLD GT 180, COUNT_DPHI_INV)
      IF COUNT_DPHI_INV GT 0 THEN DPHI_VLD(INDX_DPHI_INV) = 360 - DPHI_VLD(INDX_DPHI_INV)
      
      IF KEYWORD_SET(VERBOSE) THEN BEGIN
        PRINT, ' NB_CLEAR_PIX = ' + STRTRIM(STRING(COUNT_CS_CLEAR_PIX),1)
        PRINT, ' SITE: ' + SITE_NAME + ' / NORTH: ' + STRTRIM(STRING(MAX(LAT_VLD)),1) $
                    + '° / SOUTH: ' + STRTRIM(STRING(MIN(LAT_VLD)),1) $
                    + '° / EAST: ' + STRTRIM(STRING(MAX(LON_VLD)),1) $
                    + '° / WEST: ' + STRTRIM(STRING(MIN(LON_VLD)),1) + '°'
      ENDIF

      ;-------------------
      ; GET BRDF MODIS INFOS 

      ; BRDF_MODIS_VALUES.BAND - BAND in wavelength
      ; BRDF_MODIS_VALUES.BAND_ID - BAND Number in Product
      ; BRDF_MODIS_VALUES.BRDF_REF_VALUES - BRDF REFERENCE (MODIS) Values per BAND

      BRDF_MODIS = GET_MODIS_BRDF(ACQUI_DATE, SITE_NAME, LAT_VLD, LON_VLD, THETA_S_VLD, THETA_V_VLD, DPHI_VLD, VERBOSE=VERBOSE)
      
      IDX_MODIS_INCREASE_NM = BRDF_MODIS.BAND_ID_PRODUCT_BRDF-1
      BAND_WAVELENGTH_MODIS_MICROM = DOUBLE(BRDF_MODIS.BAND(IDX_MODIS_INCREASE_NM))/1000
;      IDX_LABELS_MODIS_INCREASE_NM = BRDF_MODIS.BAND_ID_PRODUCT_L1B(IDX_MODIS_INCREASE_NM)-1 
;      LABELS_MODIS_INCREASE_NM = MODIS_SENSOR_BAND_INFOS.BAND_LABEL_STD(IDX_LABELS_MODIS_INCREASE_NM)

      ; INITIALISATION OF THE INTERPOLATED SENSOR SPECTRUM
      SENSOR_SPECTRUM=MAKE_ARRAY(NB_PIX, NB_BANDS_SENSOR_PROCESS, /FLOAT)
             
      ;-------------------
      ; LOOP ON THE VALID PIXELS
      
      FOR NUM_PIX=0, NB_PIX-1 DO BEGIN
      
        ; ORGANIZATION OF THE BRDF VALUES DEPENDING ON SPECTRAL VALUES
        MODIS_SPECTRUM = BRDF_MODIS.BRDF_REF_VALUES(NUM_PIX,*) ; ALREADY IN PROPER INCREASING ORDER IN FUNCTION GET_MODIS_BRDF
        
        ; SPLINE INTERPOLATION OF THE MODIS SPECTRUM OVER SENSOR BAND WAVELENGTH         
        MODIS_INTERP = INTERPOL(MODIS_SPECTRUM, BAND_WAVELENGTH_MODIS_MICROM, SOLAR_IRRADIANCE.WAVELENGTH, /SPLINE)
        MODIS_SOLAR = MODIS_INTERP * SOLAR_IRRADIANCE.SOLAR_IRRADIANCE
        
        FOR NUM_BAND=0, NB_BANDS_SENSOR_PROCESS-1 DO BEGIN

          CUR_BAND_REP6S = REP6S(*, IDX_BANDS_SENSOR_PROCESS[NUM_BAND]+1)
          INDX_DIV_VALID = WHERE(CUR_BAND_REP6S GT 0, COUNT)
          IF COUNT EQ 0 THEN BEGIN
            IF KEYWORD_SET(VERBOSE) THEN PRINT, FCT_NAME + ': WARNING, NO SENSOR SPECTRUM COMPUTED FOR BAND ', SENSOR_CONFIG.BAND_REF_LABEL[IDX_BANDS_SENSOR_PROCESS[NUM_BAND]]
            GOTO, NEXT_BAND_SENSOR_SPECTRUM
          ENDIF
                        
          CUR_BAND_MODIS_SOLAR = MODIS_SOLAR * CUR_BAND_REP6S
          CUR_BAND_MODIS_SOLAR_IRRADIANCE = SOLAR_IRRADIANCE.SOLAR_IRRADIANCE * CUR_BAND_REP6S
          ; PROTECTION AGAINST ZERO DIVISION
          CUR_BAND_MODIS_SOLAR = CUR_BAND_MODIS_SOLAR(INDX_DIV_VALID)
          CUR_BAND_MODIS_SOLAR_IRRADIANCE = CUR_BAND_MODIS_SOLAR_IRRADIANCE(INDX_DIV_VALID)
          CUR_BAND_MODIS_WAVELENGTH = SOLAR_IRRADIANCE.WAVELENGTH(INDX_DIV_VALID)

          SENSOR_SPECTRUM(NUM_PIX,NUM_BAND) = INT_TABULATED(CUR_BAND_MODIS_WAVELENGTH, CUR_BAND_MODIS_SOLAR) $
                                                / INT_TABULATED(CUR_BAND_MODIS_WAVELENGTH, CUR_BAND_MODIS_SOLAR_IRRADIANCE)
          ; SENSOR_SPECTRUM IN MODIS INCREASING BAND
          
          NEXT_BAND_SENSOR_SPECTRUM:
          
        ENDFOR ; ENDFOR BAND
        
      ENDFOR ; ENDFOR PIXEL
            
      ; SET CALIB_VALID_INDEX 
      NCDF_CALIB_STRUCT.VARIABLES.CALIB_VALID_INDEX(0:NB_PIX-1,NUM_DIR) = INDX_CS_MASK_CLEAR
       
      ;-------------------
      ; LOOP ON SENSOR BANDS
      
      FOR NUM_BAND=0, NB_BANDS_SENSOR_PROCESS-1 DO BEGIN
  
        IDX_NUM_BAND = IDX_BANDS_SENSOR_PROCESS[NUM_BAND]
       
        IF IDX_NUM_BAND+1 LT 10 THEN BAND_ID = '0' + STRTRIM(STRING(IDX_NUM_BAND+1),2) $
                                ELSE BAND_ID = STRTRIM(STRING(IDX_NUM_BAND+1),2)

        WAVELENGTH = STRTRIM(STRING(SENSOR_CONFIG.BAND_WAVELENGTH[IDX_NUM_BAND]),2)
       
        IF KEYWORD_SET(VERBOSE) THEN PRINT, SENSOR + ' :: ID : ' + STRTRIM(STRING(SENSOR_CONFIG.BAND_ID[IDX_NUM_BAND]),1) + $
                                              ', LABEL_STD : ' + SENSOR_CONFIG.BAND_LABEL_STD[IDX_NUM_BAND] + $
                                              ', REF_LABEL : ' + SENSOR_CONFIG.BAND_REF_LABEL[IDX_NUM_BAND] + $
                                              ', WAVELENGTH : ' + WAVELENGTH
       
        IF SMAC_FILE_STRUCT.SMAC_FILE_EXIST(IDX_NUM_BAND) EQ 0 THEN GOTO, NEXT_BAND
       
        RTOA_OBS = NCDF_INGEST_STRUCT.VARIABLES.REFL_BAND[*,NUM_DIR, IDX_NUM_BAND]
        RTOA_OBS = RTOA_OBS(INDX_CS_MASK_CLEAR)
                          
        TG = GET_SMAC_GT_VALUES(SMAC_FILE_STRUCT.SMAC_COEFFS(*,IDX_NUM_BAND), THETA_S = THETA_S_VLD, THETA_V = THETA_V_VLD, $
              PRESSURE = PRESSURE_VLD, OZONE = OZONE_VLD, WATERVAPOUR = WATERVAPOUR_VLD)
        
        INDX_NAN = WHERE(RTOA_OBS EQ MISSING_VALUE_FLT, COUNT_MISSING_VALUE, NCOMPLEMENT=COUNT_VALID, COMPLEMENT=IDX_VALID)
        IF COUNT_MISSING_VALUE GT 0 THEN RTOA_OBS(INDX_NAN)=!VALUES.F_NAN          
        IF COUNT_VALID EQ 0 THEN BEGIN
          PRINT, FCT_NAME + ': WARNING, NO VALID VALUE FOR BAND ', SENSOR_CONFIG.BAND_REF_LABEL[IDX_NUM_BAND], ', RESULTS SET AS MISSING VALUE FOR THIS BAND'
          GOTO, NEXT_BAND
        ENDIF 
        
        RTOA_TG_RATIO = RTOA_OBS / TG
        
        RTOA_TG_RATIO_ESTIM = GET_SMAC_VALUES(SENSOR_SPECTRUM(*,NUM_BAND), SMAC_FILE_STRUCT.SMAC_COEFFS(*,IDX_NUM_BAND), $
                                              THETA_S = THETA_S_VLD, THETA_V = THETA_V_VLD, $
                                              PHI_S = PHI_S_VLD, PHI_V = PHI_V_VLD, TAUP = TAUP_550, $
                                              PRESSURE = PRESSURE_VLD, OZONE = OZONE_VLD, WATERVAPOUR = WATERVAPOUR_VLD, VERBOSE=VERBOSE)
        
        REF_TO_SIM_RATIO = RTOA_TG_RATIO/DOUBLE(RTOA_TG_RATIO_ESTIM)
      
        RTOA_OBS_VLD = RTOA_OBS(IDX_VALID)
        TG_VLD = TG(IDX_VALID)
        RTOA_TG_RATIO_VLD = RTOA_TG_RATIO(IDX_VALID)
        RTOA_TG_RATIO_ESTIM_VLD = RTOA_TG_RATIO_ESTIM(IDX_VALID)
        REF_TO_SIM_RATIO_VLD = REF_TO_SIM_RATIO(IDX_VALID)
      
        IF DEBUG_MODE EQ 1 THEN BEGIN
          PRINT, ' ------ ', NCDF_CALIB_STRUCT.VARIABLES.REFL_BAND_IDS[NUM_BAND]
          PRINT, ' DEBUG MODE - MIN/MAX/MEAN(RTOA_OBS) = ', MIN(RTOA_OBS_VLD), '/', MAX(RTOA_OBS_VLD), '/', MEAN(RTOA_OBS_VLD)
          PRINT, ' DEBUG MODE - MIN/MAX/MEAN(TG) = ', MIN(TG_VLD), '/', MAX(TG_VLD), '/', MEAN(TG_VLD)
          PRINT, ' DEBUG MODE - MIN/MAX/MEAN(RTOA_TG_RATIO_ESTIM) = ', MIN(RTOA_TG_RATIO_ESTIM_VLD), '/', MAX(RTOA_TG_RATIO_ESTIM_VLD), '/', MEAN(RTOA_TG_RATIO_ESTIM_VLD)
          PRINT, ' DEBUG MODE - MIN/MAX/MEAN(REF_TO_SIM_RATIO) = ', MIN(REF_TO_SIM_RATIO_VLD), '/', MAX(REF_TO_SIM_RATIO_VLD), MEAN(REF_TO_SIM_RATIO_VLD)
          PRINT, ' ------ '
        ENDIF
        
        IF NB_DIRECTIONS GT 1 THEN BEGIN
          OUT_FIG_FILENAME = OUT_FILEPATH + NCDF_YEAR_STR + DL + OUT_FILENAME_BASE + '_' + NCDF_YEAR_STR + NCDF_MONTH_STR + NCDF_DAY_STR $
                                        + '_' + NCDF_HOURS_STR + NCDF_MINUTES_STR $
                                        + '_' + DIR_ID $
                                        + '_' + SENSOR_CONFIG.BAND_REF_LABEL[IDX_NUM_BAND] $
                                        + '_' + WAVELENGTH $
                                        + '.jpg'
        ENDIF ELSE BEGIN
          OUT_FIG_FILENAME = OUT_FILEPATH + NCDF_YEAR_STR + DL + OUT_FILENAME_BASE + '_' + NCDF_YEAR_STR + NCDF_MONTH_STR + NCDF_DAY_STR $
                                        + '_' + NCDF_HOURS_STR + NCDF_MINUTES_STR $
                                        + '_' + SENSOR_CONFIG.BAND_REF_LABEL[IDX_NUM_BAND] $
                                        + '_' + WAVELENGTH $
                                        + '.jpg'
        ENDELSE                                
           
        RES = GET_SENSOR_TO_SIMULATION_PRODUCT_PLOTS(OUT_FIG_FILENAME, RTOA_TG_RATIO_VLD, RTOA_TG_RATIO_ESTIM_VLD, REF_TO_SIM_RATIO_VLD)
        
        ;-------------------
        ; COMPLETE NCDF CALIBRATION STRUCTURE
        
        NB_PIX = NCDF_CALIB_STRUCT.VARIABLES.CALIB_PIXEL_NUMBER(NUM_DIR)
        NCDF_CALIB_STRUCT.VARIABLES.BAND_GAZ_TRANS(0:NB_PIX-1,NUM_DIR,NUM_BAND)        = TG
        NCDF_CALIB_STRUCT.VARIABLES.BAND_RHO_SIM(0:NB_PIX-1,NUM_DIR,NUM_BAND)          = RTOA_TG_RATIO_ESTIM
      ;  NCDF_CALIB_STRUCT.VARIABLES.BAND_RHO_SIM_UNCERT(0:NB_PIX-1,NUM_DIR,NUM_BAND)   = BAND_RHO_SIM_UNCERT
        NCDF_CALIB_STRUCT.VARIABLES.BAND_REF_TO_SIM_RATIO(0:NB_PIX-1,NUM_DIR,NUM_BAND) = REF_TO_SIM_RATIO
        NCDF_CALIB_STRUCT.VARIABLES.BAND_VALID_INDEX(0:COUNT_VALID-1,NUM_DIR,NUM_BAND) = IDX_VALID
  
        NEXT_BAND:
         
      ENDFOR ; END LOOP ON BANDS
      
      AT_LEAST_ONE_DIR = 1
      
      NEXT_DIR:
      
    ENDFOR ; END LOOP ON VIEWING DIRECTIONS
    
    ; CHECK IF AT LEAST ONE DIRECTION HAS BEEN PROCESSED 
    IF AT_LEAST_ONE_DIR EQ 1 THEN BEGIN
      
      ;----------------------
      ; WRITE CALIBRATION OUTPUT
      
      STATUS = NETCDFWRITE_CALIB_OUTPUT(PROCESS_DATE, NCDF_CALIB_STRUCT, NCDF_FILENAME=NCDF_FILENAME, VERBOSE=VERBOSE)
      IF STATUS NE STATUS_OK THEN BEGIN
        IF KEYWORD_SET(VERBOSE) THEN PRINT, FCT_NAME + ': ERROR DURING OUTPUT CALIBRATION WRITING >> RETURNING'    
        RETURN, STATUS_ERROR
      ENDIF
      
    ENDIF ELSE IF KEYWORD_SET(VERBOSE) THEN PRINT, FCT_NAME + ': NO DIRECTION PROCESSED >> OUTPUT CALIBRATION NOT WRITTEN' 
            
    NEXT_IFILES:
          
  ENDFOR ;  END LOOP ON FILES
    
  NO_IFILES:
        
  PRINT, FCT_NAME + ': ***** PROCESS COMPLETED SUCCESSFULLY *****'
  RETURN, STATUS_OK

  END_PROCESS:
  IF (STATUS NE STATUS_OK) AND (KEYWORD_SET(VERBOSE)) THEN PRINT, FCT_NAME + ': ERROR DURING PROCESSING'
  RETURN, STATUS_ERROR
  
END