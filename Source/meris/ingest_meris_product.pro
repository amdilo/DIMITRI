;**************************************************************************************
;**************************************************************************************
;*
;* NAME:
;*      INGEST_MERIS_PRODUCT       
;* 
;* PURPOSE:
;*      INGESTS MERIS L1B DATA INTO DIMITRI DATABASE. MULTIPLE PRODUCT 
;*	    EXTRACTION IS AVAILABLE BUT IT EXPECTS ALL FILES TO BE THE SAME REGION/PROCESSING. 
;*      OUTPUTS QUICKLOOK IMAGES, UPDATES DATABASE AND APPENDS DATA TO SAV FILE FOR 
;*      SPECIFIED REGION AND PROCESSING.
;* 
;* CALLING SEQUENCE:
;*      RES = INGEST_MERIS_PRODUCT(IFILES)      
;* 
;* INPUTS:
;*      IFILES -  A STRING OR STRING ARRAY OF THE FULL PATH FILENAMES OF PRODUCTS 
;*                FOR INGESTION.      
;*
;* KEYWORDS:
;*      INPUT_FOLDER      - A STRING CONTAINING THE FULL PATH OF THE 'INPUT' FOLDER, IF 
;*                          NOT PROVIDED THEN IT IS DERIVED FROM THE FILENAME
;*      ICOORDS           - A FOUR ELEMENT FLOATING-POINT ARRAY CONTAINING THE NORTH, SOUTH, 
;*                          EAST AND WEST COORDINATES OF THE ROI, E.G [50.,45.,10.,0.]
;*      ENDIAN_SZE        - MACHINE ENDIAN SIZE (0: LITTLE, 1: BIG), IF NOT PROVIDED 
;*                          THEN COMPUTED.
;*      COLOUR_TABLE      - USER DEFINED IDL COLOUR TABLE INDEX (DEFAULT IS 39)
;*      PLOT_XSIZE        - WIDTH OF GENERATED PLOTS (DEFAULT IS 700PX)
;*      PLOT_YSIZE        - HEIGHT OF GENERATED PLOTS (DEFAULT IS 400PX)
;*      NO_ZBUFF          - IF SET THEN PLOTS ARE GENERATED IN WINDOWS AND NOT 
;*                          WIHTIN THE Z-BUFFER.
;*      NO_QUICKLOOK      - IF SET THEN QUICKLOOKS ARE NOT GENERATED FOR IFILES.
;*      VERBOSE           - PROCESSING STATUS OUTPUTS
;*
;* OUTPUTS:
;*      STATUS  - 1: NO ERRORS REPORTED, (-1) OR 0: ERRORS DURING INGESTION	
;*
;* COMMON BLOCKS:
;*      NONE
;*
;* MODIFICATION HISTORY:
;*        04 JUL 2005 - M BOUVET  - PROTOTYPE DIMITRI VERSION
;*        09 NOV 2010 - C KENT    - DIMITRI-2 V1.0
;*        20 NOV 2010 - C KENT    - UPDATED TO ALLOW SINGULAR USAGE (REMOVED COMMON BLOCKS)
;*        22 NOV 2010 - C KENT    - ADDED VERBOSE KEYWORD OPTION
;*        02 DEC 2010 - C KENT    - UPDATED PROGRAMMING AND SZA TO PIXEL DATA INSTEAD OF 
;*                                  AVERAGE WHEN COMPTING TOA REFLECTANCE. 
;*                                  HEADER ALSO UPDATED
;*        03 DEC 2010 - C KENT    - REMOVED NB_PIX THRESHOLD, ALL PRODUCT APPENDED TO DATABASE, 
;*                                  NO DATA FILES ARE SET TO -1
;*        20 DEC 2010 - C KENT    - UPDATED COMMENTS AND HEADER INFORMATION
;*        10 JAN 2011 - C KENT    - CHANGED SAVED OUTPUT VARIABLE TO SENSOR_L1B_REF
;*        12 JAN 2011 - C KENT    - OUTPUT RGB QUICKLOOKS AS DEFUALT, UPDATED OUTPUT DATA 
;*                                  WITH SAA AND VAA (REMOVED RAA) 
;*        21 MAR 2011 - C KENT    - MODIFIED FILE DEFINITION TO USE GET_DIMITRI_LOCATION
;*        22 MAR 2011 - C KENT    - ADDED CONFIGURAITON FILE DEPENDENCE
;*        01 JUL 2011 - C KENT    - ADDED ANGLE CORRECTOR
;*        04 JUL 2011 - C KENT    - UPDATED TO INCLUDE NEW AUXILARY INFORMATION, 
;*                                  AND CODE REVISION TO IMPROVE PERFORMANCE (SOLAR IRRADIANCE COMPUTATION)
;*        12 JUL 2011 - C KENT    - FIXED AUX INFO BUG
;*        14 JUL 2011 - C KENT    - UPDATED TIME EXTRACTION SECTION
;*        23 AUG 2011 - C KENT    - ADD NETCDF OUTPUT FUNCTIONALITY
;*        24 AUG 2011 - C KENT    - UPDATED NETCDF OUTPUT FUNCTIONALITY
;*        30 AUG 2011 - C KENT    - ADDED MANUAL CLOUD SCREENING OUTPUT TO NETCDF
;*        12 SEP 2011 - C KENT    - UPDATED NETCDF OUTPUT
;*        08 MAR 2012 - C KENT    - ADDED ROI COVERAGE
;*        09 FEB 2015 - NCG / MAGELLIUM   - UPDATE WITH DIMITRI V4 SPECIFICATION
;*        15 JUN 2015 - NCG / MAGELLIUM   - ADD SECONDS IN ACQUISITION DATE
;*                                          CORRECTION OF DECIMAL YEAR VALUE (USE OF 'DATETIME_TO_DECIMAL_YEAR' FUNCTION)
;*
;* VALIDATION HISTORY:
;*        02 DEC 2010 - C KENT    - WINDOWS 32BIT MACHINE IDL 7.1: COMPILATION AND EXECUTION 
;*                                  SUCCESSFUL. TESTED MULTIPLE OPTIONS ON MULTIPLE 
;*                                  PRODUCTS
;*        12 APR 2011 - C KENT    - LINUX 64BIT MACHINE IDL 8.0: COMPILATION AND OPERATION SUCCESSFUL 
;*        20 JAN 2015 - NCG / MAGELLIUM      - WINDOWS 64BIT MACHINE IDL 8.0: COMPILATION AND OPERATION SUCCESSFUL 
;*      30 MAR 2015 - NCG / MAGELLIUM      - WINDOWS 64BIT MACHINE IDL 8.0: COMPILATION AND OPERATION SUCCESSFUL (DIMITRI V4.0) 
;*
;**************************************************************************************
;**************************************************************************************

FUNCTION INGEST_MERIS_PRODUCT,IFILES,INPUT_FOLDER=INPUT_FOLDER,ICOORDS=ICOORDS,INGEST_SUNGLINT=INGEST_SUNGLINT,$
         ENDIAN_SZE=ENDIAN_SIZE,COLOUR_TABLE=COLOUR_TABLE,$
         PLOT_XSIZE=PLOT_XSIZE,PLOT_YSIZE=PLOT_YSIZE,NO_ZBUFF=NO_ZBUFF,NO_QUICKLOOK=NO_QUICKLOOK,$
         VERBOSE=VERBOSE

  FCT_NAME = 'INGEST_MERIS_PRODUCT'

	STATUS_OK = GET_DIMITRI_LOCATION('STATUS_OK')
	STATUS_ERROR = GET_DIMITRI_LOCATION('STATUS_ERROR')

	;------------------------
	; KEYWORD PARAMETER CHECK - NOTE, ASSUMES ALL PRODUCT ARE RELATED TO THE SAME REGION/PROCESSING

  IF STRCMP(STRING(IFILES[0]),'') THEN BEGIN
    PRINT, FCT_NAME + ' - ERROR, NO INPUT FILES PROVIDED, RETURNING...'
    RETURN, STATUS_ERROR
  ENDIF  
  IF N_ELEMENTS(INPUT_FOLDER) EQ 0 THEN INPUT_FOLDER = GET_DIMITRI_LOCATION('INPUT')

  ; GET THE CONFIGURATION VALUES (THRESHOLDS AND STRING VALUES)
  DL = GET_DIMITRI_LOCATION('DL')
  MISSING_VALUE_FLT=FLOAT(GET_DIMITRI_LOCATION('NCDF_MISSING_VALUE'))
  MISSING_VALUE_DBL=DOUBLE(GET_DIMITRI_LOCATION('NCDF_MISSING_VALUE'))
  MISSING_VALUE_LONG=LONG(GET_DIMITRI_LOCATION('NCDF_MISSING_VALUE'))
  SG_THETA_N_MIN=GET_DIMITRI_LOCATION('MIN_THETA_N_SG_PROCESS')               ; DEFAULT = 0°
  SG_THETA_N_MAX=GET_DIMITRI_LOCATION('MAX_THETA_N_SG_PROCESS')               ; DEFAULT = 4°
  SG_THETA_R_MAX=GET_DIMITRI_LOCATION('MAX_THETA_R_SG_PROCESS')               ; DEFAULT = 36°
  MIN_PIXEL_NB_INGEST_PROCESS = GET_DIMITRI_LOCATION('MIN_PIXEL_NB_INGEST_PROCESS')
  OUTPUT_FOLDER = GET_DIMITRI_LOCATION('INGESTION_OUTPUT')
  
  TEMP = STRSPLIT(IFILES[0],DL,/EXTRACT) 
 
  TEMP_INF  = WHERE(STRCMP(TEMP,'Input') EQ 1)
  TEMP_INF  = TEMP_INF(N_ELEMENTS(TEMP_INF)-1)
  IREGION   = TEMP[TEMP_INF+1]
  IREGION   = STRMID(IREGION,5,STRLEN(IREGION)) 
  SENSOR    = TEMP[TEMP_INF+2]
  IPROC     = TEMP[TEMP_INF+3]
  IPROC     = STRMID(IPROC,5,STRLEN(IPROC)) 
  CFIG_DATA = GET_DIMITRI_CONFIGURATION()
  SITE_TYPE = GET_SITE_TYPE(IREGION,VERBOSE=VERBOSE)
  
  IF N_ELEMENTS(ICOORDS) EQ 0 THEN BEGIN
    PRINT, FCT_NAME + ' - NO ROI COORDINATES PROVIDED, USING DEFAULT OF [90.,-90,180.0,-180.0]'
    ICOORDS = [90.,-90.,180.0,-180.0]
  ENDIF
  IF N_ELEMENTS(COLOUR_TABLE) EQ 0 THEN BEGIN
    PRINT, FCT_NAME + ' - NO COLOR_TABLE SET, USING DEFAULT OF 39'
    COLOUR_TABLE = CFIG_DATA.(1)[2]
  ENDIF
  IF N_ELEMENTS(PLOT_XSIZE) EQ 0 THEN BEGIN
    PRINT, FCT_NAME + ' - PLOT_XSIZE NOT SET, USING DEFAULT OF 700'
    PLOT_XSIZE = CFIG_DATA.(1)[0]
  ENDIF
  IF N_ELEMENTS(PLOT_YSIZE) EQ 0 THEN BEGIN
    PRINT, FCT_NAME + ' - PLOT_YSIZE NOT SET, USING DEFAULT OF 400'
    PLOT_YSIZE = CFIG_DATA.(1)[1]
  ENDIF  

	;------------------------------------------------
	; IF ENDIAN SIZE NOT PROVIDED THEN GET VALUE

  IF N_ELEMENTS(ENDIAN_SIZE) EQ 0 THEN BEGIN
    IF KEYWORD_SET(VERBOSE) THEN PRINT, FCT_NAME + ' - NO ENDIAN SIZE PROVIDED, RETRIEVING...'
    ENDIAN_SIZE = GET_ENDIAN_SIZE(VERBOSE=VERBOSE)
  ENDIF

	;------------------------
	; GET NUMBER OF IFILES 

  NB_FILES = N_ELEMENTS(IFILES)

	;-----------------------------------------------
	; GET THE DATABASE STRUCTURE 

  DB_DATA=GET_DIMITRI_TEMPLATE(NB_FILES,/DB)

	;-----------------------------------------------  
	; ADD DATA OF INGESTION TO DB_DATA - NEEDS REWORKING INTO YYYYMMDD
  TEMP = SYSTIME()
  TEMP = STRMATCH(STRMID(TEMP,8,1),' ') ? '0'+STRUPCASE(STRING(STRMID(TEMP,9,1)+'-'+STRMID(TEMP,4,3)+'-'+STRMID(TEMP,20,4))) : STRUPCASE(STRING( STRMID(TEMP,8,2)+'-'+STRMID(TEMP,4,3)+'-'+STRMID(TEMP,20,4)))
  DB_DATA.DIMITRI_DATE = TEMP 

	;-----------------------------------------------
	; ADD REGION, SENSOR AND PROC VERSION TO DB_DATA
  DB_DATA.SITE_NAME = IREGION
  DB_DATA.SITE_TYPE = SITE_TYPE
  DB_DATA.SITE_COORDINATES = 'NONE'
  DB_DATA.SENSOR = SENSOR
  DB_DATA.PROCESSING_VERSION = IPROC

	;-----------------------------------------
	; SET INITIAL VALUES 

  DB_DATA.L1_INGESTED_FILENAME = 'NONE'
  DB_DATA.ROI_STATUS = -1
  DB_DATA.ROI_PIX_NUM = -1
  DB_DATA.THETA_N_MEAN = -1
  DB_DATA.THETA_R_MEAN = -1
  DB_DATA.AUTO_CS_1_NAME = GET_DIMITRI_LOCATION('AUTO_CS_1_NAME')
  DB_DATA.AUTO_CS_1_MEAN = -1
  DB_DATA.ROI_CS_1_CLEAR_PIX_NUM = -1
  DB_DATA.AUTO_CS_2_NAME = GET_DIMITRI_LOCATION('AUTO_CS_2_NAME')
  DB_DATA.AUTO_CS_2_MEAN = -1
  DB_DATA.ROI_CS_2_CLEAR_PIX_NUM = -1
  DB_DATA.BRDF_CS_MEAN = -1
  DB_DATA.SSV_CS_MEAN = -1
  DB_DATA.MANUAL_CS = -1 
  DB_DATA.ERA_WIND_SPEED_MEAN = -1
  DB_DATA.ERA_WIND_DIR_MEAN = -1
  DB_DATA.ERA_OZONE_MEAN = -1
  DB_DATA.ERA_PRESSURE_MEAN = -1
  DB_DATA.ERA_WATERVAPOUR_MEAN = -1
  DB_DATA.ESA_CHLOROPHYLL_MEAN = -1

	;----------------------------------
	; DEFINE MERIS SPECIFIC PARAMETERS 
  NB_BANDS = SENSOR_BAND_INFO('MERIS') 
  NB_BANDS = NB_BANDS[0]
  FNAME_STR = 'MER_RR__1'
  NB_DIRECTIONS = SENSOR_DIRECTION_INFO(SENSOR)
	NB_DIRECTIONS = NB_DIRECTIONS[0]
	
	;----------------------------------
	; DEFINE THE STATISTICAL ARRAYS

  ROI_AVG_TOA_REF  = MAKE_ARRAY(NB_BANDS,NB_FILES*NB_DIRECTIONS,/FLOAT,VALUE=MISSING_VALUE_FLT)
  ROI_STD_TOA_REF  = MAKE_ARRAY(NB_BANDS,NB_FILES*NB_DIRECTIONS,/FLOAT,VALUE=MISSING_VALUE_FLT) 
  NB_ROI_PX        = FLTARR(NB_DIRECTIONS*NB_FILES)
  GOOD_RECORD      = MAKE_ARRAY(NB_DIRECTIONS*NB_FILES,/INTEGER,VALUE=0)
  IFILE_DATE 	     = DBLARR(5,NB_DIRECTIONS*NB_FILES);CONTAINS YEAR,MONTH,DAY,DOY,DECIMEL_YEAR
  IFILE_VIEW 	     = DBLARR(4,NB_DIRECTIONS*NB_FILES);CONTAINS SENSOR ZENITH,SENSOR AZIMUTH,SOLAR ZENITH,SOLAR AZIMUTH
  IFILE_AUX        = FLTARR(12,NB_DIRECTIONS*NB_FILES);CONTAINS OZONE,PRESSURE,RELHUMIDITY,WIND_ZONAL,WIND_MERID, AND WVAP (MU AND SIGMA)

	;---------------------------------
	; IF ONLY 1 PRODUCT FOR INGESTION THEN REFORM ARRAYS
  IF NB_FILES EQ 1 THEN BEGIN
    ROI_AVG_TOA_REF  = REFORM(ROI_AVG_TOA_REF,NB_BANDS,NB_FILES)
    ROI_STD_TOA_REF  = REFORM(ROI_STD_TOA_REF,NB_BANDS,NB_FILES)
    IFILE_DATE       = REFORM(IFILE_DATE,5,NB_FILES)
    IFILE_VIEW       = REFORM(IFILE_VIEW,4,NB_FILES)
    IFILE_AUX        = REFORM(IFILE_AUX,12,NB_FILES)
  ENDIF

  IF KEYWORD_SET(VERBOSE) THEN BEGIN
    PRINT, FCT_NAME + ' - DEFINITION OF OUTPUT ARRAYS:'
    HELP, ROI_AVG_TOA_REF,ROI_STD_TOA_REF,NB_ROI_PX,GOOD_RECORD,IFILE_DATE,IFILE_VIEW
  ENDIF

	;---------------------------------
	; ADD DATA TO NETCDF OUTPUT STRUCTURE
	
  NCDF_OUT = GET_DIMITRI_EXTRACT_NCDF_DATA_STRUCTURE(NB_FILES,NB_BANDS,NB_DIRECTIONS)
  NCDF_OUT.ATT_FNAME  = 'Site_'+IREGION+'_'+SENSOR+'_'+'Proc_'+IPROC+'.nc'
  NCDF_OUT.ATT_TOOL   = GET_DIMITRI_LOCATION('TOOL')
  NCDF_OUT.ATT_SENSOR = SENSOR
  NCDF_OUT.ATT_PROCV  = IPROC
  NCDF_OUT.ATT_PRES   = STRTRIM(STRING(SENSOR_PIXEL_SIZE(SENSOR)),2)+' KM'
  NCDF_OUT.ATT_NBANDS = STRTRIM(STRING(NB_BANDS),2)
  NCDF_OUT.ATT_NDIRS  = STRTRIM(STRING(NB_DIRECTIONS),2)
  NCDF_OUT.ATT_SITEN  = IREGION
  NCDF_OUT.ATT_SITEC  = STRJOIN(STRTRIM(STRING(ICOORDS),2),' ')
  NCDF_OUT.ATT_SITET  = SITE_TYPE

	;----------------------------------
	; START MAIN LOOP OVER EACH IFILE

  IF KEYWORD_SET(VERBOSE) THEN PRINT, FCT_NAME + ' - STARTING INGESTION LOOP ON MERIS PRODUCTS' 
	FOR IN_FNAME=0,NB_FILES-1 DO BEGIN; IN_FNAME IS RESERVED FOR LOOPS WITHIN THE INGESTION ROUTINES

		TEMP = STRSPLIT(IFILES[IN_FNAME],DL,/EXTRACT)
		DB_DATA.L1_FILENAME[IN_FNAME] = TEMP[N_ELEMENTS(TEMP)-1] 

		IF KEYWORD_SET(VERBOSE) THEN BEGIN
			PRINT, FCT_NAME + ' [' + STRTRIM(STRING(IN_FNAME+1),1) + ' / ' + STRTRIM(STRING(NB_FILES),1) + '] : ' + DB_DATA.L1_FILENAME[IN_FNAME]
		ENDIF

		;------------------------------------------
		; RETRIEVE AUX DATA FILENAMES FOR DB_DATA

		TEMP = GET_MERIS_AUX_FILES(IFILES[IN_FNAME],VERBOSE=VERBOSE)	

		DB_DATA.AUX_DATA_1[IN_FNAME] = TEMP[0]
		DB_DATA.AUX_DATA_2[IN_FNAME] = TEMP[1] 
		DB_DATA.AUX_DATA_3[IN_FNAME] = TEMP[2] 
		DB_DATA.AUX_DATA_4[IN_FNAME] = TEMP[3] 
		DB_DATA.AUX_DATA_5[IN_FNAME] = TEMP[4] 
		DB_DATA.AUX_DATA_6[IN_FNAME] = TEMP[5] 
		DB_DATA.AUX_DATA_7[IN_FNAME] = TEMP[6] 
		DB_DATA.AUX_DATA_8[IN_FNAME] = TEMP[7] 
		DB_DATA.AUX_DATA_9[IN_FNAME] = TEMP[8] 
		DB_DATA.AUX_DATA_10[IN_FNAME] = TEMP[9] 

		;----------------------------------
		; RETRIEVE DATE INFORMATION

		IF KEYWORD_SET(VERBOSE) THEN PRINT, FCT_NAME + ' - RETRIEVING DATE INFORMATION'
		STR_POS 		            = STRPOS(IFILES[IN_FNAME],FNAME_STR, /REVERSE_SEARCH)

    ACQ_YEAR  = STRMID(IFILES[IN_FNAME],STR_POS+14,4)
    ACQ_MONTH = STRMID(IFILES[IN_FNAME],STR_POS+18,2)
    ACQ_DAY   = STRMID(IFILES[IN_FNAME],STR_POS+20,2)
    DATE_HR   = STRMID(IFILES[IN_FNAME],STR_POS+23,2) 
    DATE_MIN  = STRMID(IFILES[IN_FNAME],STR_POS+25,2) 
    DATE_SEC  = STRMID(IFILES[IN_FNAME],STR_POS+27,2) 

		IFILE_DATE[0,IN_FNAME]	= ACQ_YEAR+0.
		IFILE_DATE[1,IN_FNAME]	= ACQ_MONTH+0.
		IFILE_DATE[2,IN_FNAME]	= ACQ_DAY+0.

		IFILE_DATE[3,IN_FNAME]	= JULDAY(IFILE_DATE[1,IN_FNAME],IFILE_DATE[2,IN_FNAME],IFILE_DATE[0,IN_FNAME])-JULDAY(1,0,IFILE_DATE[0,IN_FNAME])
		IFILE_DATE[4,IN_FNAME]  = DATETIME_TO_DECIMAL_YEAR(FIX(ACQ_YEAR),FIX(ACQ_MONTH),FIX(ACQ_DAY),FIX(DATE_HR),FIX(DATE_MIN),FIX(DATE_SEC),VERBOSE=VERBOSE)

		;----------------------------------
		; ADD DATE INFORMATION TO DB_DATA

		DB_DATA.YEAR[IN_FNAME]  = IFILE_DATE[0,IN_FNAME]
		DB_DATA.MONTH[IN_FNAME] = IFILE_DATE[1,IN_FNAME]
		DB_DATA.DAY[IN_FNAME]   = IFILE_DATE[2,IN_FNAME]
		DB_DATA.DOY[IN_FNAME]   = IFILE_DATE[3,IN_FNAME]
		DB_DATA.DECIMAL_YEAR[IN_FNAME] = IFILE_DATE[4,IN_FNAME]

		;----------------------------------
		; STORE DATE IN NETCDF STRUCTURE

		NCDF_OUT.VAR_PNAME[IN_FNAME]  = DB_DATA.L1_FILENAME[IN_FNAME] 
		NCDF_OUT.VAR_PTIME[IN_FNAME]  = STRMID(IFILES[IN_FNAME],STR_POS+14,8)+' '+DATE_HR+':'+DATE_MIN+':'+DATE_SEC
		NCDF_OUT.VAR_DTIME[IN_FNAME]  = DB_DATA.DECIMAL_YEAR[IN_FNAME]   	


		;----------------------------------
		; RETRIEVE INPUT FILE L1B RADIANCE - BASE PIXEL VALIDITY ON B412

		IF KEYWORD_SET(VERBOSE) THEN PRINT, FCT_NAME + ' - RETRIEVING RADIANCE INFORMATION'
		IFILE_TOA = GET_MERIS_L1B_RADIANCE(IFILES[IN_FNAME],0,ENDIAN_SIZE=ENDIAN_SIZE,VERBOSE=VERBOSE)

		;----------------------------------
		; RETRIEVE INPUT FILE GEOLOCATION

		IF KEYWORD_SET(VERBOSE) THEN PRINT, FCT_NAME + ' - RETRIEVING GEOLOCATION INFORMATION'
		IFILE_GEO = GET_MERIS_LAT_LON(IFILES[IN_FNAME],ENDIAN_SIZE=ENDIAN_SIZE,VERBOSE=VERBOSE)

		;------------------------------------------
		; RETRIEVE VIEWING GEOMETRIES

		IF KEYWORD_SET(VERBOSE) THEN PRINT, FCT_NAME + ' - RETRIEVING VIEWING GEOMETRIES'
		TEMP = GET_MERIS_VIEWING_GEOMETRIES(IFILES[IN_FNAME],ENDIAN_SIZE=ENDIAN_SIZE,VERBOSE=VERBOSE)
		TEMP_ANGLES = DIMITRI_ANGLE_CORRECTOR(TEMP.VZA,TEMP.VAA,TEMP.SZA,TEMP.SAA)

		;----------------------------------
		; CORRECT LON AND LAT ALTITUDE

		RES = WHERE(TEMP_ANGLES.VAA GE 0. AND TEMP_ANGLES.VAA LT 180.,COUNT,COMPLEMENT=RSIGN,NCOMPLEMENT=RCOUNT)
		IF COUNT  GT 0 THEN IFILE_GEO.LON_CORR[RES]     =  1*ABS(IFILE_GEO.LON_CORR[RES])
		IF RCOUNT GT 0 THEN IFILE_GEO.LON_CORR[RSIGN]   = -1*ABS(IFILE_GEO.LON_CORR[RSIGN])
		LAT = IFILE_GEO.LAT+IFILE_GEO.LAT_CORR
		LON = IFILE_GEO.LON+IFILE_GEO.LON_CORR
		IFILE_GEO = 0

		;------------------------------------------
		; RETRIEVE SUNGLINT ANGLES FOR SUNGLINT OR OCEAN SITES

		IF (INGEST_SUNGLINT EQ 1) OR STRCMP(DB_DATA.SITE_TYPE[IN_FNAME], 'OCEAN', /FOLD_CASE) THEN BEGIN   
			RES = GET_SUNGLINT_ANGLES( TEMP_ANGLES.SZA, TEMP_ANGLES.VZA, TEMP_ANGLES.SAA, TEMP_ANGLES.VAA, THETA_N=THETA_N, THETA_R=THETA_R)      

			DB_DATA.THETA_N_MEAN[IN_FNAME] = MEAN(THETA_N)
			DB_DATA.THETA_R_MEAN[IN_FNAME] = MEAN(THETA_R)                

		ENDIF
		
		;------------------------------------------
		; PROCESS SELECTION FOR SUNGLINT DETECTION/INGESTION OR NOT

		IF (INGEST_SUNGLINT EQ 1) THEN BEGIN

			; SUNGLINT DETECTION
			LATI=LAT
			LONGI=LON
			
			; FIND SUNGLINT SPOT
			ROI_INDEX=WHERE(THETA_N GT SG_THETA_N_MIN AND $
					THETA_N LE SG_THETA_N_MAX AND $
					TEMP_ANGLES.SZA GT 0 AND $
					LATI NE 0 , $
					NB_PIX, COMPLEMENT=IDNOSG, NCOMPLEMENT=COUNT_NOSG)

			IF NB_PIX EQ 0 THEN BEGIN
			  IFILE_VIEW[*,IN_FNAME]= MISSING_VALUE_FLT
				IFILE_AUX[*,IN_FNAME] = MISSING_VALUE_FLT
				ROI_AVG_TOA_REF(*,IN_FNAME) = MISSING_VALUE_FLT
				ROI_STD_TOA_REF(*,IN_FNAME) = MISSING_VALUE_FLT
				
				GOTO, NO_ROI ; NEXT FILE     
		  ENDIF
			
			IF KEYWORD_SET(VERBOSE) THEN BEGIN
				PRINT, ' SUNGLINT AREA FOUND >> RAW PIXELS NB = ' + STRTRIM(STRING(NB_PIX),1)
			ENDIF

			; OTHERWISE ROI IN SUNGLINT SPOT
			DB_DATA.ROI_PIX_NUM[IN_FNAME] = NB_PIX 

			; NORTH HEMISPHERE 
			ICOORDS[0]=MAX(LATI(ROI_INDEX))
			ICOORDS[1]=MIN(LATI(ROI_INDEX))
			;WEST HEMISPHERE  
			ICOORDS[2]=MAX(LONGI(ROI_INDEX))
			ICOORDS[3]=MIN(LONGI(ROI_INDEX))

			IF (ICOORDS[2] < 0 ) THEN BEGIN
				ICOORDS[2]=MIN(LONGI(ROI_INDEX))
				ICOORDS[3]=MAX(LONGI(ROI_INDEX))
			ENDIF

			; UPDATE OF NETCDF FILES WITH SUNGLINT SPOT COORDINATES
			COORDINATES = STRJOIN(STRTRIM(STRING(ICOORDS),2),' ') ; NORTH SOUTH EAST WEST      
			DB_DATA.SITE_COORDINATES[IN_FNAME] = COORDINATES
			NCDF_OUT.ATT_SITEC  = COORDINATES
			
		ENDIF ELSE BEGIN
			; CLASSICAL INGEST / NOT FOR SUNGLINT

			; RETRIEVE INDEX OF NOMINAL DATA WITHIN ROI
			IF KEYWORD_SET(VERBOSE) THEN PRINT, FCT_NAME + ' - RETRIEVING INDEX OF PIXELS WITHIN ROI'
			ROI_INDEX = WHERE($
					LAT LT ICOORDS[0] AND $
					LAT GT ICOORDS[1] AND $
					LON LT ICOORDS[2] AND $
					LON GT ICOORDS[3] AND $
					IFILE_TOA GT 0.0    , $
					NB_PIX $
					)

			; IF NO PIXELS IN ROI THEN DO NOT RETRIEVE TOA REFLECTANCE
			IF NB_PIX EQ 0 THEN BEGIN
			  IFILE_VIEW[*,IN_FNAME]= MISSING_VALUE_FLT
				IFILE_AUX[*,IN_FNAME] = MISSING_VALUE_FLT
				ROI_AVG_TOA_REF(*,IN_FNAME) = MISSING_VALUE_FLT
				ROI_STD_TOA_REF(*,IN_FNAME) = MISSING_VALUE_FLT
				
				GOTO, NO_ROI ; NEXT FILE     
		  ENDIF

			IF KEYWORD_SET(VERBOSE) THEN BEGIN
				PRINT, ' SITE AREA FOUND >> RAW PIXELS NB = ' + STRTRIM(STRING(NB_PIX),1)
			ENDIF  

			DB_DATA.ROI_PIX_NUM[IN_FNAME] = NB_PIX
			DB_DATA.SITE_COORDINATES[IN_FNAME] = NCDF_OUT.ATT_SITEC      

		ENDELSE   

		;-----------------------------------------
		; CHECK ROI COVERAGE

		IF NB_PIX GT MIN_PIXEL_NB_INGEST_PROCESS THEN BEGIN
			DB_DATA.ROI_STATUS[IN_FNAME] = 1
			IF INGEST_SUNGLINT EQ 0 THEN DB_DATA.ROI_STATUS[IN_FNAME] = CHECK_ROI_COVERAGE(LAT,LON,ROI_INDEX,ICOORDS,VERBOSE=VERBOSE)
		ENDIF ELSE BEGIN
			DB_DATA.ROI_STATUS[IN_FNAME] = 0
			GOTO, NO_ROI
		ENDELSE  

		GOOD_RECORD[IN_FNAME]=1
		
    ; GET NCDF INGESTION OUTPUT STRUCTURE
    ;------------------------------------

    NCDF_INGEST_STRUCT = GET_NCDF_INGEST_STRUCT( NB_PIX, NB_DIRECTIONS, NB_BANDS, VERBOSE=VERBOSE)
    NCDF_INGEST_STRUCT.GLOBAL_ATT.SITE_NAME = DB_DATA.SITE_NAME[IN_FNAME]
    NCDF_INGEST_STRUCT.GLOBAL_ATT.SITE_TYPE = DB_DATA.SITE_TYPE[IN_FNAME]
    NCDF_INGEST_STRUCT.GLOBAL_ATT.SENSOR = DB_DATA.SENSOR[IN_FNAME]
    NCDF_INGEST_STRUCT.GLOBAL_ATT.PROCESSING_VERSION = DB_DATA.PROCESSING_VERSION[IN_FNAME]
    NCDF_INGEST_STRUCT.GLOBAL_ATT.ACQUISITION_DATE = ACQ_YEAR + '-' + ACQ_MONTH + '-' + ACQ_DAY + ' ' + DATE_HR + ':' + DATE_MIN + ':' + DATE_SEC
    NCDF_INGEST_STRUCT.GLOBAL_ATT.L1_FILENAME = DB_DATA.L1_FILENAME[IN_FNAME] 

		;------------------------------------------
		; GENERATE A QUICKLOOK WITH THE ROI OVERLAID

		IF N_ELEMENTS(NO_QUICKLOOK) EQ 0 THEN BEGIN

			OUTPUT_QL_FOLDER   = OUTPUT_FOLDER+'Site_'+IREGION+DL+SENSOR+DL+'Proc_'+IPROC+DL+ ACQ_YEAR + DL
			OUTPUT_QL_FILENAME = OUTPUT_QL_FOLDER + IREGION + '_' + SENSOR + '_' + IPROC +  '_' + ACQ_YEAR + ACQ_MONTH + ACQ_DAY + '_' + DATE_HR + DATE_MIN

			OUT_FOLDER_INFO = FILE_INFO(OUTPUT_QL_FOLDER)
			IF OUT_FOLDER_INFO.DIRECTORY EQ 0 THEN BEGIN
				FILE_MKDIR, OUTPUT_QL_FOLDER
				IF KEYWORD_SET(VERBOSE) THEN BEGIN      
					PRINT, FCT_NAME + ' - WARNING, OUTPUT YEAR FOLDER ''' + OUTPUT_QL_FOLDER + ''' NOT FOUND >> CREATED'
				ENDIF
			ENDIF

			IF KEYWORD_SET(VERBOSE) THEN PRINT, FCT_NAME + ' - GENERATE QUICKLOOK OF PRODUCT'
			OUTPUT_QL_FILENAME = OUTPUT_QL_FILENAME + '.jpg'
			IF FIX(CFIG_DATA.(1)[3]) EQ 1 THEN QL_STATUS =  GET_MERIS_QUICKLOOK(IFILES[IN_FNAME],OUTPUT_QL_FILENAME,/ROI,/RGB,ICOORDS=ICOORDS,QL_QUALITY=QL_QUALITY,ENDIAN_SIZE=ENDIAN_SIZE,VERBOSE=VERBOSE) $
																		ELSE QL_STATUS =  GET_MERIS_QUICKLOOK(IFILES[IN_FNAME],OUTPUT_QL_FILENAME,/ROI,ICOORDS=ICOORDS,QL_QUALITY=QL_QUALITY,ENDIAN_SIZE=ENDIAN_SIZE,VERBOSE=VERBOSE)

			IF KEYWORD_SET(VERBOSE) THEN $
				IF QL_STATUS EQ STATUS_ERROR THEN PRINT, FCT_NAME + ' - QUICKLOOK GENERATION FAILED - ',IFILES[IN_FNAME] $
													           ELSE PRINT, FCT_NAME + ' - QUICKLOOK GENERATION SUCCESS' 
		ENDIF   
	

		;--------------------------------
		; INDEX OF ROW/COLUM IN THE IMAGE 
		s = SIZE(LAT)
		NCOL = s(1)
		CS_COL = ROI_INDEX MOD NCOL
		CS_ROW = ROI_INDEX / NCOL      

		;------------------------------------------
		; DEFINE ARRAY TO HOLD CS RHO      
		ADDBANDS=2   ; LAT + LON INDICES
  	
  	CS_RHO = MAKE_ARRAY(NB_PIX,NB_BANDS+ADDBANDS,/FLOAT,VALUE=MISSING_VALUE_FLT)
  
		;------------------------------------------
		; DEFINE ARRAY TO HOLD LAT/LON
		ADDANG=6  ; LAT/LON + 4 ANGLES (SZA, SAA, VZA, VAA)
		NBCOL_CS_LATLON = NB_BANDS + ADDBANDS + ADDANG
		
		CS_LATLON = FLTARR(NB_PIX,NBCOL_CS_LATLON)
		
		CS_LATLON[*,0]=LAT(ROI_INDEX)
		CS_LATLON[*,1]=LON(ROI_INDEX)
	
		;------------------------------------------
		; RETRIEVE VIEWING GEOMETRIES
    
		IFILE_VIEW[0,IN_FNAME]=MEAN(TEMP_ANGLES.VZA[ROI_INDEX])
		IFILE_VIEW[1,IN_FNAME]=MEAN(TEMP_ANGLES.VAA[ROI_INDEX])
		IFILE_VIEW[2,IN_FNAME]=MEAN(TEMP_ANGLES.SZA[ROI_INDEX])
		IFILE_VIEW[3,IN_FNAME]=MEAN(TEMP_ANGLES.SAA[ROI_INDEX])
       
  	;----------------------------------   

		CS_LATLON[*,2]=TEMP_ANGLES.SZA[ROI_INDEX] ; SZA  
		CS_LATLON[*,3]=TEMP_ANGLES.SAA[ROI_INDEX] ; SAA   
		CS_LATLON[*,4]=TEMP_ANGLES.VZA[ROI_INDEX] ; VZA   
		CS_LATLON[*,5]=TEMP_ANGLES.VAA[ROI_INDEX] ; VAA  
    
 	  TEMP_SZA = TEMP_ANGLES.SZA[ROI_INDEX]
	
		;------------------------------------- 
		;  SUNGLINT DETECTION ON MEAN VALUES (USED FOR CLOUD SCREENING CRITERIA)

		SUNGLINT_STATUS = 0                
		IF (INGEST_SUNGLINT EQ 1) OR STRCMP(DB_DATA.SITE_TYPE[IN_FNAME], 'OCEAN', /FOLD_CASE) THEN BEGIN

			THETA_N = MEAN(THETA_N[ROI_INDEX])
			THETA_R = MEAN(THETA_R[ROI_INDEX])

			IF (THETA_R LE SG_THETA_R_MAX) THEN SUNGLINT_STATUS = 1
			IF (THETA_N LE SG_THETA_N_MAX) THEN SUNGLINT_STATUS = 2

			IF (SUNGLINT_STATUS EQ 1) AND (INGEST_SUNGLINT EQ 1) THEN DB_DATA.ROI_STATUS[IN_FNAME] = 1

			DB_DATA.THETA_N_MEAN[IN_FNAME]=DOUBLE(THETA_N)
			DB_DATA.THETA_R_MEAN[IN_FNAME]=DOUBLE(THETA_R)

		ENDIF
    
    TEMP=0
    TEMP_ANGLES = 0

    ;---------------------------------------
    ; RETRIEVE THE AUXILIARY INFORMATION

    TEMP = GET_MERIS_ECMWF_OZONE(IFILES[IN_FNAME],VERBOSE=VERBOSE)
    IFILE_AUX[0,IN_FNAME] = MEAN(TEMP[ROI_INDEX])
    IFILE_AUX[1,IN_FNAME] = STDEV(TEMP[ROI_INDEX])
  
    TEMP = GET_MERIS_ECMWF_PRESSURE(IFILES[IN_FNAME],VERBOSE=VERBOSE)
    IFILE_AUX[2,IN_FNAME] = MEAN(TEMP[ROI_INDEX])
    IFILE_AUX[3,IN_FNAME] = STDEV(TEMP[ROI_INDEX])
  
    TEMP = GET_MERIS_ECMWF_HUMIDITY(IFILES[IN_FNAME],VERBOSE=VERBOSE)
    IFILE_AUX[4,IN_FNAME] = MEAN(TEMP[ROI_INDEX])
    IFILE_AUX[5,IN_FNAME] = STDEV(TEMP[ROI_INDEX])
  
    TEMP = GET_MERIS_ECMWF_WIND(IFILES[IN_FNAME],VERBOSE=VERBOSE)
    IFILE_AUX[6,IN_FNAME] = MEAN(TEMP.ZONAL[ROI_INDEX])
    IFILE_AUX[7,IN_FNAME] = STDEV(TEMP.ZONAL[ROI_INDEX])
    IFILE_AUX[8,IN_FNAME] = MEAN(TEMP.MERID[ROI_INDEX])
    IFILE_AUX[9,IN_FNAME] = STDEV(TEMP.MERID[ROI_INDEX])
  
    IFILE_AUX[10,IN_FNAME] = MISSING_VALUE_FLT
    IFILE_AUX[11,IN_FNAME] = MISSING_VALUE_FLT
    TEMP=0

		;---------------------------------------
		; RETRIEVE THE DETECTOR INDEX

    IF KEYWORD_SET(VERBOSE) THEN PRINT, FCT_NAME + ' - RETRIEVING DETECTOR INDEX'
    CCD_INDEX = GET_MERIS_L1B_DETECTOR_INDEX(IFILES[IN_FNAME],ENDIAN_SIZE=ENDIAN_SIZE,VERBOSE=VERBOSE)
		
		CCD_INDEX = CCD_INDEX[ROI_INDEX]
		CCD_MIN   = MIN(CCD_INDEX,MAX=CCD_MAX)

		;---------------------------------------
		; RETRIEVE THE SOLAR SPECTRAL FLUX RESPONSE 

    IF KEYWORD_SET(VERBOSE) THEN PRINT, FCT_NAME + ' - RETRIEVING SOLAR FLUX RESPONSE'
    SOLAR_FLUX_RESPONSE = GET_MERIS_SOLAR_FLUX_RR(VERBOSE=VERBOSE)
		SFR_DIMS  = SIZE(SOLAR_FLUX_RESPONSE)

		;----------------------------------------
		; RETRIEVE F0 - SOLAR IRRADIANCE

    IF KEYWORD_SET(VERBOSE) THEN PRINT, FCT_NAME + ' - RETRIEVING SOLAR IRRADIANCE'
    SUN_IRR_F0 = GET_MERIS_L1B_F0(IFILES[IN_FNAME],ENDIAN_SIZE=ENDIAN_SIZE,VERBOSE=VERBOSE)

		;----------------------------------------
		; COMPUTE TOA REFLECTANCE FOR EACH BAND 

    IFILE_TOA = 0
    IF KEYWORD_SET(VERBOSE) THEN PRINT, FCT_NAME + ' - STARTING LOOP OVER EACH BAND'
		
		FOR IN_BAND=0,NB_BANDS-1 DO BEGIN

      IF KEYWORD_SET(VERBOSE) THEN PRINT, FCT_NAME + ' - RETRIEVING RADIANCE FOR BAND -',IN_BAND
      TOA_REF=GET_MERIS_L1B_RADIANCE(IFILES[IN_FNAME],IN_BAND,ENDIAN_SIZE=ENDIAN_SIZE,VERBOSE=VERBOSE)
			TOA_REF = TOA_REF[ROI_INDEX]
			
			;----------------------------------------
			; RETRIEVE F0 - SOLAR IRRADIANCE AT IN_BAND

			SUN_IRR_F0_BAND = SUN_IRR_F0[IN_BAND]

			;----------------------------------------
			; COMPUTE SOLAR IRRADIANCE OVER IMAGE

			IF KEYWORD_SET(VERBOSE) THEN PRINT, FCT_NAME + ' - COMPUTING SOLAR IRRADIANCE OVER IMAGE'
			SUN_IRR = FLTARR(N_ELEMENTS(ROI_INDEX))
			FOR IN_SIRR=CCD_MIN,CCD_MAX DO BEGIN
        TEMP = WHERE(CCD_INDEX EQ IN_SIRR)
        IF TEMP[0] GT -1 THEN BEGIN
          SUN_IRR[TEMP] = SOLAR_FLUX_RESPONSE[IN_BAND+1,IN_SIRR]
        ENDIF
      ENDFOR
	
			;----------------------------------------
			; CORRECT SOLAR IRRADIANCE FOR EARTH/SUN DISTANCE

      IF IFILE_DATE[0,IN_FNAME] MOD 4 EQ 0 THEN DIY = DOUBLE(366.0) $
                                           ELSE DIY = DOUBLE(365.0)
                         
      IF KEYWORD_SET(VERBOSE) THEN PRINT, FCT_NAME + ' - CORRECTING SOLAR IRRADIANCE FOR EARTH-SUN DISTANCE'
      SUN_IRR = SUN_IRR*(1.0+0.0167*COS(2.0*!DPI*(IFILE_DATE[3,IN_FNAME]-3.0)/DIY))^2
      
			;----------------------------------------
			; COMPUTE TOA REFLETANCE TAKING INTO ACCOUNT OF MERIS DETECTORS 

      IF KEYWORD_SET(VERBOSE) THEN PRINT, FCT_NAME + ' - COMPUTE TOA REFLECTANCE FOR BAND -',IN_BAND

			;-----------------------------------------      
			; CHANGE 0'S TO 0.0001 TO AVOID ARITHMETIC ERRORS - WILL NOT IMPACT ON ROI AVERAGE REFLECTANCES

      TEMP = WHERE(TOA_REF LE 0.0,TCOUNT)
      IF TCOUNT GT 0 THEN TOA_REF[TEMP] = 0.0001
      TEMP = WHERE(SUN_IRR LE 0.0,TCOUNT)
      IF TCOUNT GT 0 THEN SUN_IRR[TEMP] = 1000.0     
        
      TOA_REF = TOA_REF*!DPI/COS(TEMP_SZA*!DTOR)/SUN_IRR ; CORRECTS FOR SMILE EFFECT AND EARTH SUN DISTANCE
     
			;-----------------------------------------
			; ADD TOA REFLECTANCE TO OUTPUT ARRAY

      VALID = WHERE(TOA_REF GT 0.0 AND TOA_REF LT 1.0,COUNT)
      IF COUNT GT 0 THEN BEGIN
       ROI_AVG_TOA_REF(IN_BAND,IN_FNAME) = MEAN(TOA_REF[VALID])
       IF COUNT GE 2 THEN ROI_STD_TOA_REF(IN_BAND,IN_FNAME) = STDDEV(TOA_REF[VALID])
      ENDIF

      CS_RHO[VALID,IN_BAND] = FLOAT(TOA_REF[VALID])
     
			NCDF_OUT.VAR_PIX[IN_BAND,IN_FNAME,0] = COUNT

    	IF KEYWORD_SET(VERBOSE) THEN PRINT, FCT_NAME + ' - END OF LOOP ON BAND - ',IN_BAND
    	
		ENDFOR; END OF BAND ANALYSIS
		
		;-----------------------------------------
		; STORE DATA IN NETCDF STRUCTURE

		NCDF_OUT.VAR_VZA[0,IN_FNAME]      = IFILE_VIEW[0,IN_FNAME]
		NCDF_OUT.VAR_VAA[0,IN_FNAME]      = IFILE_VIEW[1,IN_FNAME]
		NCDF_OUT.VAR_SZA[0,IN_FNAME]      = IFILE_VIEW[2,IN_FNAME]
		NCDF_OUT.VAR_SAA[0,IN_FNAME]      = IFILE_VIEW[3,IN_FNAME]

		NCDF_OUT.VAR_RHOMU[*,IN_FNAME,0]    = ROI_AVG_TOA_REF(*,IN_FNAME)
		NCDF_OUT.VAR_RHOSD[*,IN_FNAME,0]    = ROI_STD_TOA_REF(*,IN_FNAME)
		NCDF_OUT.VAR_OZONEMU[IN_FNAME]  = IFILE_AUX[0,IN_FNAME]
		NCDF_OUT.VAR_OZONESD[IN_FNAME]  = IFILE_AUX[1,IN_FNAME]
		NCDF_OUT.VAR_PRESSMU[IN_FNAME]  = IFILE_AUX[2,IN_FNAME]
		NCDF_OUT.VAR_PRESSSD[IN_FNAME]  = IFILE_AUX[3,IN_FNAME]
		NCDF_OUT.VAR_RHUMMU[IN_FNAME]   = IFILE_AUX[4,IN_FNAME]
		NCDF_OUT.VAR_RHUMSD[IN_FNAME]   = IFILE_AUX[5,IN_FNAME]
		NCDF_OUT.VAR_ZONALMU[IN_FNAME]  = IFILE_AUX[6,IN_FNAME]
		NCDF_OUT.VAR_ZONALSD[IN_FNAME]  = IFILE_AUX[7,IN_FNAME]
		NCDF_OUT.VAR_MERIDMU[IN_FNAME]  = IFILE_AUX[8,IN_FNAME]
		NCDF_OUT.VAR_MERIDSD[IN_FNAME]  = IFILE_AUX[9,IN_FNAME]
		NCDF_OUT.VAR_WVAPMU[IN_FNAME]   = IFILE_AUX[10,IN_FNAME]
		NCDF_OUT.VAR_WVAPSD[IN_FNAME]   = IFILE_AUX[11,IN_FNAME]

    ; ADD LAT/LON INDICES
    CS_RHO[*,NB_BANDS]  	= CS_COL
    CS_RHO[*,NB_BANDS+1]  = CS_ROW
    
    CS_LATLON[*,6:NBCOL_CS_LATLON-1]=CS_RHO

    ;----------------------------------
    ; APPLY ARGANS CLOUD SCREENING
    CS_METHOD_ARG = 'GLOBCARBON'
    CS_MERIS_ARG = DIMITRI_CLOUD_SCREENING(SENSOR, SITE_TYPE, CS_RHO, CS_LATLON[*,2:5], CS_METHOD_ARG, $
                                          SUNGLINT_STATUS=SUNGLINT_STATUS, CS_CLASSIF_MATRIX=CS_CLASSIF_MATRIX_ARG, VERBOSE=VERBOSE)
    ;----------------------------------
    ; APPLY MAGELLIUM CLOUD SCREENING
    IF STRCMP(SITE_TYPE,'OCEAN', /FOLD_CASE) THEN BEGIN
        CS_METHOD_MAG = 'MERIS_OCEAN'
        CS_MERIS_MAG = DIMITRI_CLOUD_SCREENING(SENSOR, SITE_TYPE, CS_RHO, CS_LATLON[*,2:5], CS_METHOD_MAG, $
                                          SUNGLINT_STATUS=SUNGLINT_STATUS, CS_CLASSIF_MATRIX=CS_CLASSIF_MATRIX_MAG, VERBOSE=VERBOSE)
    ENDIF ELSE IF STRCMP(SITE_TYPE,'DESERT', /FOLD_CASE) THEN BEGIN
        CS_METHOD_MAG = 'MERIS_DESERT'
        CS_MERIS_MAG = DIMITRI_CLOUD_SCREENING(SENSOR, SITE_TYPE, CS_RHO, CS_LATLON[*,0:5], CS_METHOD_MAG, $
                                          CS_CLASSIF_MATRIX=CS_CLASSIF_MATRIX_MAG, VERBOSE=VERBOSE, $
                                          SITE_NAME=IREGION)
    ENDIF ELSE BEGIN
        CS_METHOD_MAG = 'GLOBCARBON'
        CS_MERIS_MAG = CS_MERIS_ARG
      	CS_CLASSIF_MATRIX_MAG = CS_CLASSIF_MATRIX_ARG
    ENDELSE

    ; DETERMINATE PIXEL NUMBER DECLARED AS CS_VALID :: 'cloud screening valid indexes'
    INDX_CS_VALID_PIX_ARG = WHERE(CS_CLASSIF_MATRIX_ARG(*,0) NE MISSING_VALUE_LONG, COUNT_CS_VALID_PIX_ARG)
    INDX_CS_VALID_PIX_MAG = WHERE(CS_CLASSIF_MATRIX_MAG(*,0) NE MISSING_VALUE_LONG, COUNT_CS_VALID_PIX_MAG)
    ; DETERMINATE PIXEL NUMBER DECLARED AS CS_CLEAR (NO CLOUD)
    ; IN CS_TOTAL_PIXEL_CLASSIF : cloud =1 / clear =0 :: 'final cloud screening classification'
    INDX_CS_CLEAR_PIX_ARG = WHERE(CS_CLASSIF_MATRIX_ARG(*,1) EQ 0, COUNT_CS_CLEAR_PIX_ARG)    
    INDX_CS_CLEAR_PIX_MAG = WHERE(CS_CLASSIF_MATRIX_MAG(*,1) EQ 0, COUNT_CS_CLEAR_PIX_MAG)    

    IF KEYWORD_SET(VERBOSE) THEN BEGIN
      PRINT, ' CS ARGANS    - NB CLEAR PIXELS = ' + STRTRIM(STRING(COUNT_CS_CLEAR_PIX_ARG),1) + '/' + STRTRIM(STRING(COUNT_CS_VALID_PIX_ARG),1)
      PRINT, ' CS MAGELLIUM - NB CLEAR PIXELS = ' + STRTRIM(STRING(COUNT_CS_CLEAR_PIX_MAG),1) + '/' + STRTRIM(STRING(COUNT_CS_VALID_PIX_MAG),1)
    ENDIF

    ;----------------------------------
    ; DATABASE STRUCTURE COMPLETION

    DB_DATA.AUTO_CS_1_NAME[IN_FNAME] = DB_DATA.AUTO_CS_1_NAME[IN_FNAME] + ' - ' + CS_METHOD_ARG
    DB_DATA.AUTO_CS_2_NAME[IN_FNAME] = DB_DATA.AUTO_CS_2_NAME[IN_FNAME] + ' - ' + CS_METHOD_MAG
    DB_DATA.AUTO_CS_1_MEAN[IN_FNAME] = CS_MERIS_ARG
    DB_DATA.AUTO_CS_2_MEAN[IN_FNAME] = CS_MERIS_MAG
    DB_DATA.ROI_CS_1_CLEAR_PIX_NUM[IN_FNAME] = COUNT_CS_CLEAR_PIX_ARG
    DB_DATA.ROI_CS_2_CLEAR_PIX_NUM[IN_FNAME] = COUNT_CS_CLEAR_PIX_MAG
    
    ;----------------------------------
    ; NCDF INGESTION OUTPUT STRUCTURE COMPLETION
    
    NCDF_INGEST_STRUCT.GLOBAL_ATT.SITE_COORDINATES = DB_DATA.SITE_COORDINATES[IN_FNAME]
    NCDF_INGEST_STRUCT.GLOBAL_ATT.ROI_PIX_NUM = NB_PIX
    NCDF_INGEST_STRUCT.GLOBAL_ATT.AUTO_CS_1_NAME = DB_DATA.AUTO_CS_1_NAME[IN_FNAME]
    NCDF_INGEST_STRUCT.GLOBAL_ATT.AUTO_CS_1_MEAN = DB_DATA.AUTO_CS_1_MEAN[IN_FNAME]
    NCDF_INGEST_STRUCT.GLOBAL_ATT.ROI_CS_1_CLEAR_PIX_NUM = DB_DATA.ROI_CS_1_CLEAR_PIX_NUM[IN_FNAME]
    NCDF_INGEST_STRUCT.GLOBAL_ATT.AUTO_CS_2_NAME = DB_DATA.AUTO_CS_2_NAME[IN_FNAME]
    NCDF_INGEST_STRUCT.GLOBAL_ATT.AUTO_CS_2_MEAN = DB_DATA.AUTO_CS_2_MEAN[IN_FNAME]
    NCDF_INGEST_STRUCT.GLOBAL_ATT.ROI_CS_2_CLEAR_PIX_NUM = DB_DATA.ROI_CS_2_CLEAR_PIX_NUM[IN_FNAME]
    
    NCDF_INGEST_STRUCT.VARIABLES.ROI_STATUS[0] = 1
    NCDF_INGEST_STRUCT.VARIABLES.ROI_PIXEL_NUMBER[0] = NB_PIX
    
    NCDF_INGEST_STRUCT.VARIABLES.LAT(*, 0) = CS_LATLON[*,0]
    NCDF_INGEST_STRUCT.VARIABLES.LON(*, 0) = CS_LATLON[*,1]
    NCDF_INGEST_STRUCT.VARIABLES.SZA(*, 0) = CS_LATLON[*,2]
    NCDF_INGEST_STRUCT.VARIABLES.SAA(*, 0) = CS_LATLON[*,3]
    NCDF_INGEST_STRUCT.VARIABLES.VZA(*, 0) = CS_LATLON[*,4]
    NCDF_INGEST_STRUCT.VARIABLES.VAA(*, 0) = CS_LATLON[*,5]
    FOR BAND=0, NB_BANDS-1 DO BEGIN
      NCDF_INGEST_STRUCT.VARIABLES.REFL_BAND(*, 0, BAND) = CS_LATLON[*,6+BAND]
    ENDFOR
    NCDF_INGEST_STRUCT.VARIABLES.PIXEL_COLUMN_INDICE(*, 0) = CS_LATLON[*,6+NB_BANDS]
    NCDF_INGEST_STRUCT.VARIABLES.PIXEL_ROW_INDICE(*, 0)    = CS_LATLON[*,6+NB_BANDS+1]
    NCDF_INGEST_STRUCT.VARIABLES.AUTO_CS_1_VALID_INDEX(*, 0) = CS_CLASSIF_MATRIX_ARG(*,0)
    NCDF_INGEST_STRUCT.VARIABLES.AUTO_CS_1_MASK(*, 0)        = CS_CLASSIF_MATRIX_ARG(*,1)
    NCDF_INGEST_STRUCT.VARIABLES.AUTO_CS_2_VALID_INDEX(*, 0) = CS_CLASSIF_MATRIX_MAG(*,0)
    NCDF_INGEST_STRUCT.VARIABLES.AUTO_CS_2_MASK(*, 0)        = CS_CLASSIF_MATRIX_MAG(*,1)
    
    NCDF_INGEST_STRUCT.VARIABLES_ATT.THETA_N_MEAN = DB_DATA.THETA_N_MEAN[IN_FNAME]
    NCDF_INGEST_STRUCT.VARIABLES_ATT.THETA_R_MEAN = DB_DATA.THETA_R_MEAN[IN_FNAME]

    WINDOUT = UV_2_WS_WD(NCDF_OUT.VAR_ZONALMU[IN_FNAME], NCDF_OUT.VAR_MERIDMU[IN_FNAME])
    NCDF_INGEST_STRUCT.VARIABLES_ATT.ERA_WIND_SPEED_MEAN_L1_AUX[0] = REFORM(WINDOUT.WIND_SPEED)
    NCDF_INGEST_STRUCT.VARIABLES_ATT.ERA_WIND_DIR_MEAN_L1_AUX[0] = REFORM(WINDOUT.WIND_DIRECTION)
    NCDF_INGEST_STRUCT.VARIABLES_ATT.ERA_OZONE_MEAN_L1_AUX[0] = NCDF_OUT.VAR_OZONEMU[IN_FNAME]
    NCDF_INGEST_STRUCT.VARIABLES_ATT.ERA_PRESSURE_MEAN_L1_AUX[0] = NCDF_OUT.VAR_PRESSMU[IN_FNAME]
    NCDF_INGEST_STRUCT.VARIABLES_ATT.ERA_WATERVAPOUR_MEAN_L1_AUX[0] = NCDF_OUT.VAR_WVAPMU[IN_FNAME]

    ;----------------------------------
    ; METEO AUXILIARY DATA RETREIVING
       
    ACQUI_DATE = JULDAY(ACQ_MONTH,ACQ_DAY,ACQ_YEAR,DATE_HR,DATE_MIN,0)
    STATUS = GET_ALL_METEO_AUX_DATA( ACQUI_DATE, CS_LATLON[*,0], CS_LATLON[*,1], AUX_DATA_STRUCT=AUX_DATA_STRUCT, VERBOSE=VERBOSE)
    IF STATUS NE STATUS_OK THEN BEGIN
      ; IF KEYWORD_SET(VERBOSE) THEN PRINT, FCT_NAME + ' - ERROR WHEN RETRIEVING METEO AUX DATA, DIRECTION SKIPPED'
      ; GOTO, NO_ROI
      IF KEYWORD_SET(VERBOSE) THEN PRINT, FCT_NAME + ' - ERROR WHEN RETRIEVING METEO AUX DATA >> RETURNING'
      RETURN, STATUS_ERROR
    ENDIF    
    WIND_SPEED     = GET_CHANNEL_STRUCT(AUX_DATA_STRUCT,'WIND_SPEED')
 		WIND_DIRECTION = GET_CHANNEL_STRUCT(AUX_DATA_STRUCT,'WIND_DIRECTION')
	  OZONE          = GET_CHANNEL_STRUCT(AUX_DATA_STRUCT,'OZONE')
	  PRESSURE       = GET_CHANNEL_STRUCT(AUX_DATA_STRUCT,'PRESSURE')
	  WATERVAPOUR    = GET_CHANNEL_STRUCT(AUX_DATA_STRUCT,'WATERVAPOUR')
	  CHLOROPHYLL    = GET_CHANNEL_STRUCT(AUX_DATA_STRUCT,'CHLOROPHYLL')
	  
    NCDF_INGEST_STRUCT.VARIABLES.ERA_WIND_SPEED(*, 0) = WIND_SPEED
    NCDF_INGEST_STRUCT.VARIABLES.ERA_WIND_DIR(*, 0) = WIND_DIRECTION
    NCDF_INGEST_STRUCT.VARIABLES.ERA_OZONE(*, 0) = OZONE
    NCDF_INGEST_STRUCT.VARIABLES.ERA_PRESSURE(*, 0) = PRESSURE
    NCDF_INGEST_STRUCT.VARIABLES.ERA_WATERVAPOUR(*, 0) = WATERVAPOUR
    NCDF_INGEST_STRUCT.VARIABLES.ESA_CHLOROPHYLL(*, 0) = CHLOROPHYLL
    
		DB_DATA.ERA_WIND_SPEED_MEAN[IN_FNAME]  = MEAN(WIND_SPEED)
		DB_DATA.ERA_WIND_DIR_MEAN[IN_FNAME]    = MEAN(WIND_DIRECTION)
		DB_DATA.ERA_OZONE_MEAN[IN_FNAME]       = MEAN(OZONE)
		DB_DATA.ERA_PRESSURE_MEAN[IN_FNAME]    = MEAN(PRESSURE)
		DB_DATA.ERA_WATERVAPOUR_MEAN[IN_FNAME] = MEAN(WATERVAPOUR)
		DB_DATA.ESA_CHLOROPHYLL_MEAN[IN_FNAME] = MEAN(CHLOROPHYLL)

    ;----------------------------------
    ; NCDF INGESTION OUTPUT FILE WRITING

		STATUS = NETCDFWRITE_INGEST_OUTPUT(NCDF_INGEST_STRUCT, NCDF_FILENAME=NCDF_FILENAME, VERBOSE=VERBOSE)
		IF STATUS NE STATUS_OK THEN BEGIN
			IF KEYWORD_SET(VERBOSE) THEN PRINT, FCT_NAME + ' - ISSUE DURING NCDF INGESTION OUTPUT WRITING'
			RETURN, STATUS_ERROR
		ENDIF     

		DB_DATA.L1_INGESTED_FILENAME[IN_FNAME] = NCDF_FILENAME

		NCDF_OUT.VAR_CLOUD_AUT_1[IN_FNAME] = DB_DATA.AUTO_CS_1_MEAN[IN_FNAME]
		NCDF_OUT.VAR_CLOUD_AUT_2[IN_FNAME] = DB_DATA.AUTO_CS_2_MEAN[IN_FNAME]
		NCDF_OUT.VAR_CLOUD_MAN[IN_FNAME] = -1
		NCDF_OUT.VAR_ROI[IN_FNAME] = DB_DATA.ROI_STATUS[IN_FNAME]

		NO_ROI:; IF ROI IS NOT WITHIN THE PRODUCT OR THERE ARE TOO FEW PIXELS
		
		IF KEYWORD_SET(VERBOSE) THEN PRINT, FCT_NAME + ' - END OF LOOP ON PRODUCT'
		
	ENDFOR; END OF FILE ANALYSIS

	;------------------------
	; DEFINE REPORT OUTPUT FOLDER

  OUTPUT_DIR_REPORT = STRING(OUTPUT_FOLDER+'Site_'+IREGION+DL+SENSOR+DL+'Proc_'+IPROC+DL+'REPORT'+DL)
  OUT_FOLDER_INFO = FILE_INFO(OUTPUT_DIR_REPORT)
  IF OUT_FOLDER_INFO.DIRECTORY EQ 0 THEN BEGIN
    FILE_MKDIR, OUTPUT_DIR_REPORT
    IF KEYWORD_SET(VERBOSE) THEN BEGIN      
      PRINT, FCT_NAME + ' - WARNING, OUTPUT REPORT FOLDER ''' + OUTPUT_DIR_REPORT + ''' NOT FOUND >> CREATED'
    ENDIF
  ENDIF

	;------------------------------------
	; SAVE DATA TO NETCDF REPORT FILE

  NCDF_MULTIFILE_FILENAME = OUTPUT_DIR_REPORT + IREGION + '_' + SENSOR + '_Proc_' + IPROC + '.nc'
  RES = DIMITRI_INTERFACE_EXTRACT_TOA_NCDF(NCDF_OUT,NCDF_MULTIFILE_FILENAME)  

	;------------------------------------
	; GENERATE PLOTS WITH NEW TIME SERIES DATA

  RES = GET_INGESTION_TIMESERIES_PLOTS(NCDF_MULTIFILE_FILENAME,SENSOR,COLOUR_TABLE=COLOUR_TABLE,PLOT_XSIZE=PLOT_XSIZE,PLOT_YSIZE=PLOT_YSIZE,VERBOSE=VERBOSE)
   
	;------------------------------------
	; AMEND DATA TO DATABASE

  IF KEYWORD_SET(VERBOSE) THEN PRINT, FCT_NAME + ' - SENDING DATA TO UPDATE DATABASE'
  RES = UPDATE_DIMITRI_DATABASE(DB_DATA,/SORT_DB,VERBOSE=VERBOSE)

	RETURN, STATUS_OK
END
