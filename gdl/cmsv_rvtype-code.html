<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Tue Jul  2 12:50:47 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>cmsv_rvtype.pro (Documentation for /home/marrabld/projects/DIMITRI_2.0/Source/)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="cmsv_rvtype.pro (Documentation for /home/marrabld/projects/DIMITRI_2.0/Source/)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;   CMSV_RVTYPE</span>
<span class="comments">;</span>
<span class="comments">; AUTHOR:</span>
<span class="comments">;   Craig B. Markwardt, NASA/GSFC Code 662, Greenbelt, MD 20770</span>
<span class="comments">;   craigm@lheamail.gsfc.nasa.gov</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;   Read variable type information from input block or file unit</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;   CMSV_RVTYPE, BLOCK, POINTER, NAME, SIZE, UNIT=UNIT, $</span>
<span class="comments">;          TEMPLATE=TEMPLATE, SUFFIX=SUFFIX, $</span>
<span class="comments">;          /NO_CREATE, /NO_TYPE, /HEAP, /SYSTEM, $</span>
<span class="comments">;          STRUCTURE_NAME=STNAME, $</span>
<span class="comments">;          NAMED_STRUCTS=STRUCTS, NAMED_CLASSES=CLASSES, $</span>
<span class="comments">;          OFFSET=OFFSET, STATUS=STATUS, ERRMSG=ERRMSG</span>
<span class="comments">;   </span>
<span class="comments">; DESCRIPTION: </span>
<span class="comments">;</span>
<span class="comments">;   CMSV_RVTYPE reads the type portion of an IDL SAVE variable record.</span>
<span class="comments">;   An IDL variable is stored in two components: the type descriptor</span>
<span class="comments">;   which describes the name, type, and dimensions of the variable;</span>
<span class="comments">;   and the data record, which contains the raw data of the variable.</span>
<span class="comments">;   This procedure reads the type descriptor returns it to the user.</span>
<span class="comments">;   This procedure can also determine the name of a variable; the heap</span>
<span class="comments">;   index number of a heap variable; and other important information.</span>
<span class="comments">;   Once the type of the data has been determined, the data portion</span>
<span class="comments">;   can be read using the CMSV_RDATA procedure.</span>
<span class="comments">;</span>
<span class="comments">;   CMSV_RVTYPE should recognize and correctly return type descriptor</span>
<span class="comments">;   information about all known IDL data types, as of this writing.</span>
<span class="comments">;   It should be noted that CMSV_RDATA will not necessarily be capable</span>
<span class="comments">;   of reading all of these data types, but the description of the</span>
<span class="comments">;   data should still be readable.  Users can then use this</span>
<span class="comments">;   information to print a summary of the file contents for example.</span>
<span class="comments">;</span>
<span class="comments">;   The type information are normally returned in the SIZE parameter,</span>
<span class="comments">;   which gives the IDL variable type, and the dimensions of the</span>
<span class="comments">;   variable just as the IDL built-in function SIZE() would do.</span>
<span class="comments">;   However, in the case of structures, there is much more information</span>
<span class="comments">;   to convey.  To assist the user a blank template structure is</span>
<span class="comments">;   returned in the keyword parameter TEMPLATE, which they can then</span>
<span class="comments">;   pass on to CMSV_RDATA.</span>
<span class="comments">;</span>
<span class="comments">;   Users should be aware of structure and class name clashes.  The</span>
<span class="comments">;   problem arises because CMSV_RVTYPE must actually instantiate any</span>
<span class="comments">;   named structures or classes in the file.  If these named</span>
<span class="comments">;   structures clash with the definitions of the structures on the</span>
<span class="comments">;   user's local computer, then an error will result.  To prevent</span>
<span class="comments">;   this, the user can use the SUFFIX keyword.  If the SUFFIX keyword</span>
<span class="comments">;   contains a string, then this string is appended to any structure</span>
<span class="comments">;   names discovered in the save file, before instantiation.  Thus, as</span>
<span class="comments">;   long as the suffix is a unique string, there will be no clashes</span>
<span class="comments">;   with local structure definitions.  Users are advised to pick a</span>
<span class="comments">;   different suffix for *each* save file that they open.</span>
<span class="comments">;</span>
<span class="comments">;   CMSV_RVTYPE also provides some diagnostic information about the</span>
<span class="comments">;   variable.  Users can pass the NAMED_STRUCTS and NAMED_CLASSES</span>
<span class="comments">;   keywords in order to discover what named structures, classes and</span>
<span class="comments">;   superclasses are stored in the save file (this is especially</span>
<span class="comments">;   useful with the NO_TYPE keyword).  Since the contents of</span>
<span class="comments">;   NAMED_STRUCTS and NAMED_CLASSES are not destroyed, but appended to</span>
<span class="comments">;   instead, users are advised to clear these variables when opening</span>
<span class="comments">;   each new file.</span>
<span class="comments">;   </span>
<span class="comments">;</span>
<span class="comments">; ==================================================================</span>
<span class="comments">;   Research Systems, Inc. has issued a separate license intended</span>
<span class="comments">;   to resolve any potential conflict between this software and the</span>
<span class="comments">;   IDL End User License Agreement. The text of that license</span>
<span class="comments">;   can be found in the file LICENSE.RSI, included with this</span>
<span class="comments">;   software library.</span>
<span class="comments">; ==================================================================</span>
<span class="comments">;</span>
<span class="comments">; BLOCK, POINTER, OFFSET</span>
<span class="comments">;</span>
<span class="comments">;   This procedure can read data from a byte array, a file unit, or</span>
<span class="comments">;   both.  In fact, this procedure is designed to implement "lazy"</span>
<span class="comments">;   reading from a file, which is to say, it normally reads from a</span>
<span class="comments">;   byte array of data.  However, if the requested data goes beyond</span>
<span class="comments">;   the end of the byte array, more data is read from the file on</span>
<span class="comments">;   demand.  This way the user gets the benefit of fast memory access</span>
<span class="comments">;   for small reads, but guaranteed file access for large reads.</span>
<span class="comments">;</span>
<span class="comments">;   The terminology is as follows: BLOCK is a byte array which</span>
<span class="comments">;   represents a portion of, or an entire, IDL SAVE file.  The block</span>
<span class="comments">;   may be a cached portion of an on-disk file, or an entire in-memory</span>
<span class="comments">;   SAVE file.  POINTER is the current file pointer within BLOCK</span>
<span class="comments">;   (i.e., the next byte to be read is BLOCK[POINTER]).  Hence, a</span>
<span class="comments">;   POINTER value of 0 refers to the start of the block.  OFFSET is</span>
<span class="comments">;   the file offset of the 0th byte of BLOCK; thus "POINT_LUN,</span>
<span class="comments">;   OFFSET+POINTER" should point to the same byte as BLOCK[POINTER].</span>
<span class="comments">;   The following diagram shows the meanings for BLOCK, POINTER and</span>
<span class="comments">;   OFFSET schematically:</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">;                 0 &lt;-  OFFSET  -> |</span>
<span class="comments">;   FILE          |----------------|------*--------|---------></span>
<span class="comments">;</span>
<span class="comments">;   BLOCK                          |------*--------|</span>
<span class="comments">;                                  0      ^ POINTER</span>
<span class="comments">;     </span>
<span class="comments">;</span>
<span class="comments">;   This procedure is part of the CMSVLIB SAVE library for IDL by</span>
<span class="comments">;   Craig Markwardt.  You must have the full CMSVLIB core package</span>
<span class="comments">;   installed in order for this procedure to function properly.  </span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; INPUTS:</span>
<span class="comments">;</span>
<span class="comments">;   BLOCK - a byte array, a cache of the SAVE file.  Users will</span>
<span class="comments">;           usually not access this array directly.  Users are advised</span>
<span class="comments">;           to clear BLOCK after calling POINT_LUN.</span>
<span class="comments">;</span>
<span class="comments">;   POINTER - a long integer, a pointer to the next byte to be read</span>
<span class="comments">;             from BLOCK.  CMSVLIB routines will automatically</span>
<span class="comments">;             advance the pointer.</span>
<span class="comments">;</span>
<span class="comments">;   NAME - upon return, the identifier of the variable.  For named</span>
<span class="comments">;          variables, NAME is a string.  For heap variables, NAME is</span>
<span class="comments">;          an integer heap index.</span>
<span class="comments">;</span>
<span class="comments">;   SIZE - upon return, an integers array describing the variable type</span>
<span class="comments">;          and size, in the same format as returned by the built-in</span>
<span class="comments">;          function SIZE.</span>
<span class="comments">;</span>
<span class="comments">; KEYWORDS:</span>
<span class="comments">;</span>
<span class="comments">;   TEMPLATE - upon return, if the variable is a structure, TEMPLATE</span>
<span class="comments">;              will contain a single blank template structure, which</span>
<span class="comments">;              can be used in calls to CMSV_RDATA.</span>
<span class="comments">;</span>
<span class="comments">;   NO_CREATE - if set, then do not create any template structures</span>
<span class="comments">;               (saves execution time and structure name clashes).</span>
<span class="comments">;</span>
<span class="comments">;   NO_TYPE - if set, do not read type information.  CMSV_RVTYPE</span>
<span class="comments">;             returns only the variable NAME or heap index.</span>
<span class="comments">;</span>
<span class="comments">;   HEAP - if set, then read the variable type assuming it is a heap</span>
<span class="comments">;          variable (a HEAP_DATA record).</span>
<span class="comments">;</span>
<span class="comments">;   SYSTEM - if set, then read the variable type assuming it is a</span>
<span class="comments">;            system variable (a SYSTEM_VARIABLE record).</span>
<span class="comments">;</span>
<span class="comments">;   SUFFIX - a scalar string, the suffix to be appended to any</span>
<span class="comments">;            structure names to force them to be unique.</span>
<span class="comments">;</span>
<span class="comments">;   STRUCTURE_NAME - upon return, if the variable is a named</span>
<span class="comments">;                    structure, STRUCTURE_NAME will contain the name</span>
<span class="comments">;                    of the structure as a string.</span>
<span class="comments">;</span>
<span class="comments">;   NAMED_CLASSES /</span>
<span class="comments">;   NAMED_STRUCTS - upon input, this keyword should contain an</span>
<span class="comments">;                   undefined or a string array value.</span>
<span class="comments">;</span>
<span class="comments">;                   If the variable contains any named structure/class</span>
<span class="comments">;                   definitions, CMSV_RVTYPE will append those names</span>
<span class="comments">;                   upon return, including any enclosed structures or</span>
<span class="comments">;                   superclasses.</span>
<span class="comments">;</span>
<span class="comments">;   UNIT - a file unit.  If a library routine reads to the end of</span>
<span class="comments">;          BLOCK, or if BLOCK is undefined, then this file UNIT will</span>
<span class="comments">;          be accessed for more data.  If undefined, then BLOCK must</span>
<span class="comments">;          contain the entire file in memory.</span>
<span class="comments">;</span>
<span class="comments">;   OFFSET - the file offset of byte zero of BLOCK.  Default: 0</span>
<span class="comments">;            (OFFSET is not used by this routine at this time)</span>
<span class="comments">;</span>
<span class="comments">;   STATUS - upon return, this keyword will contain 1 for success and</span>
<span class="comments">;            0 for failure.</span>
<span class="comments">;</span>
<span class="comments">;   ERRMSG - upon return with a failure, this keyword will contain the</span>
<span class="comments">;            error condition as a string.</span>
<span class="comments">;</span>
<span class="comments">; EXAMPLE:</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; SEE ALSO:</span>
<span class="comments">;</span>
<span class="comments">;   CMRESTORE, SAVE, RESTORE, CMSVLIB</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">;   Written, 2000</span>
<span class="comments">;   Documented, 24 Jan 2001</span>
<span class="comments">;   Added notification about RSI License, 13 May 2002, CM</span>
<span class="comments">;   Avoid using reserved word INHERITS, 07 Mar 2006, CM</span>
<span class="comments">;   NOTE: remember to modify CMSVLIB.PRO when changing library!</span>
<span class="comments">;</span>
<span class="comments">; $Id: cmsv_rvtype.pro,v 1.13 2009/11/22 22:50:49 craigm Exp $</span>
<span class="comments">;</span>
<span class="comments">;-</span>
<span class="comments">; Copyright (C) 2000-2001, 2002, 2006, Craig Markwardt</span>
<span class="comments">; This software is provided as is without any warranty whatsoever.</span>
<span class="comments">; Permission to use, copy, modify, and distribute modified or</span>
<span class="comments">; unmodified copies is granted, provided this copyright and disclaimer</span>
<span class="comments">; are included unchanged.</span>
<span class="comments">;-</span>
forward_function cmsv_rraw

<a id="cmsv_rarrdesc:source"></a>pro cmsv_rarrdesc, block, pointer, sz, status=status, unit=unit, errmsg=errmsg
  <span class="comments">;; ARRAY_DESC</span>
  <span class="comments">;;   LONG - START_TOKEN - value 08 - array descriptor flag</span>
  <span class="comments">;;   LONG - unknown (value 2)</span>
  <span class="comments">;;   LONG - number of bytes in value</span>
  <span class="comments">;;   LONG - number of elements in value</span>
  <span class="comments">;;   LONG - number of variable dimensions</span>
  <span class="comments">;;   LONGx2 - unknown (value 0,0)</span>
  <span class="comments">;;   LONG - maximum number of stored dimensions ( = 8 )</span>
  <span class="comments">;;   LONGx8 - dimensions of number</span>
  if n_elements(pointer) EQ 0 then pointer = 0L
  buff = cmsv_rraw(/long, block, pointer, 16, unit=unit, $
                   status=status, errmsg=errmsg)
  if status EQ 0 then return
  if buff(0) NE 8 then begin
      status = 0
      errmsg = 'ERROR: CMSV_RVTYPE: invalid array type descriptor'
      return
  endif

  ndims = buff(4)
  nelt = buff(3)
  dims = buff(8:8+ndims-1)
  vartype = 0

  sz = [ndims, dims, vartype, nelt]
  return
end

<a id="cmsv_rstructdesc:source"></a>pro cmsv_rstructdesc, block, pointer, template, unit=unit, $
                      status=status, errmsg=errmsg, $
                      suffix=suffix, structure_name=stname, no_create=nocreate, $
                      named_structs=structs, named_classes=classes
  <span class="comments">;; STRUCT_DESCR</span>
  <span class="comments">;;   LONG - START_TOKEN - value 9 - struct descriptor flag</span>
  <span class="comments">;;   STRING - name of struct (or 0 if anonymous)</span>
  <span class="comments">;;   LONG - PREDEF - 0 if struct def'n follows, 1 if already defined</span>
  <span class="comments">;;   LONG - N_TAGS - number of structure tags</span>
  <span class="comments">;;   LONG - total "length" in bytes, but nothing meaningful</span>
  <span class="comments">;;   TAGDESCxN_TAGS - TAG_TABLE - description of each tag</span>
  <span class="comments">;;   STRINGxN_TAGS - TAG_NAMES - name of each tag</span>
  <span class="comments">;;   ARRAY_DESCxN_ARRAYS - ARRAY_TAB - descriptor for each array</span>
  <span class="comments">;;   STRUCT_DESCRxN_STRUCTS - STRUCT_TAB - descriptor for each struct</span>

  template = 0 & dummy = temporary(template)

  if n_elements(pointer) EQ 0 then pointer = 0L
  start_token = cmsv_rraw(/long, block, pointer, unit=unit, $
                          status=status, errmsg=errmsg)
  <span class="comments">;; message, 'ERROR: CMSV_RVTYPE: structure descriptor was not found'</span>
  if status EQ 0 OR start_token NE 9 then return
  struct_name = cmsv_rraw(/string, block, pointer, unit=unit, $
                          status=status, errmsg=errmsg)
  if status EQ 0 then return
  buff = cmsv_rraw(/long, block, pointer, 3, unit=unit, $
                   status=status, errmsg=errmsg)
  if status EQ 0 then return

  status = 0
  nt = buff(1)
  if nt LE 0 then begin
      errmsg = 'ERROR: CMSV_RVTYPE: number of structure tags was &lt;= 0'
      return
  endif
  predefined = (buff(0) AND 1) NE 0  <span class="comments">;; Structure type has already been def'd</span>
  inherits_  = (buff(0) AND 2) NE 0  <span class="comments">;; This is a class, inherits from a super</span>
  is_super   = (buff(0) AND 4) NE 0  <span class="comments">;; This is a superclass</span>

  <span class="comments">;; Structure has already been defined</span>
  if predefined then begin
      stname = struct_name
      errmsg = ''
      status = 1
      if NOT keyword_set(nocreate) then begin
          status = execute('template = {'+stname+'}')
          if status EQ 0 then $
            errmsg = ('ERROR: CMSV_RVTYPE: could not create named structure '+$
                      struct_name)
      endif
      return
  endif

  <span class="comments">;; Read tag_table - type descriptions of each tag</span>
  <span class="comments">;; LONG - offset</span>
  <span class="comments">;; LONG - IDL variable type</span>
  <span class="comments">;; LONG - type flags '20'x: struct, '14'x: array</span>
  tag_table = cmsv_rraw(/long, block, pointer, 3*nt, unit=unit, $
                        status=status, errmsg=errmsg)
  if status EQ 0 then return
  tag_table = reform(tag_table, 3, nt, /overwrite)

  <span class="comments">;; Read tag names</span>
  <span class="comments">;; STRING</span>
  tag_names1 = strarr(nt)
  for i = 0L, nt-1 do begin
      tag_names1(i) = cmsv_rraw(/string, block, pointer, unit=unit, $
                                status=status, errmsg=errmsg)
      if status EQ 0 then return
  endfor

  <span class="comments">;; Read array descriptors - compose a list of SIZE types</span>
  ssz = lonarr(12, nt)
  for i = 0L, nt-1 do begin
      if (tag_table(2,i) AND '24'x) NE 0 then begin
          cmsv_rarrdesc, block, pointer, sz, unit=unit, $
            status=status, errmsg=errmsg
          if status EQ 0 then return
      endif else begin
          sz = [0L, 0, 1L]
      endelse
      sz(sz(0)+1) = tag_table(1,i) <span class="comments">;; Insert the variable type</span>
      ssz(0,i) = sz
  endfor

  <span class="comments">;; Read struct descriptors - compose the resulting struct template</span>
  for i = 0L, nt-1 do begin
      sz = reform(ssz(*,i))

      <span class="comments">;; Recursively read struct descriptor</span>
      if (tag_table(2,i) AND '20'x) NE 0 then begin
          cmsv_rstructdesc, block, pointer, tp, unit=unit, $
            status=status, errmsg=errmsg, suffix=suffix, $
            no_create=no_create, named_structs=structs, named_classes=classes
          if status EQ 0 then tp = 0L
      endif else begin
          forward_function make_array
          tp = make_array(1, type=sz(sz(0)+1))
          tp = tp(0)
      endelse

      <span class="comments">;; Use array descriptor to compose array if needed</span>
      if (tag_table(2,i) AND '04'x) NE 0 then begin
          ndims = sz(0)
          nelt = sz(ndims+2)
          dims = sz(1:ndims)
          tp = replicate(tp, nelt)
          tp = reform(tp, dims, /overwrite)
      endif

      <span class="comments">;; Add this tag element to the structure</span>
      if tag_names1(i) NE '' AND NOT keyword_set(nocreate) then begin
          if n_elements(ss) EQ 0 then $
            ss = create_struct(tag_names1(i), tp) $
          else $
            ss = create_struct(ss, tag_names1(i), tp)
      endif
      stname = struct_name
  endfor

  <span class="comments">;; Read class information</span>
  <span class="comments">;; STRING - name of class</span>
  <span class="comments">;; LONG - number of super classes = N_SUP</span>
  <span class="comments">;; STRINGxN_SUP - names of super classes</span>
  <span class="comments">;; {structdesc}xN_SUP - structures of each super class</span>
  if inherits_ OR is_super then begin
      classname = cmsv_rraw(/string, block, pointer, unit=unit, $
                            status=status, errmsg=errmsg)
      if classname EQ '' then begin
          status = 0
          errmsg = 'ERROR: CMSV_RVTYPE: invalid class name'
          return
      endif
      if status EQ 0 then return
      n_sup = cmsv_rraw(/long, block, pointer, unit=unit, $
                        status=status, errmsg=errmsg)
      if status EQ 0 then return
      
      if n_sup GT 0 then begin
          supnames = cmsv_rraw(/string, block, pointer, n_sup, unit=unit, $
                               status=status, errmsg=errmsg)
          if status EQ 0 then return

          <span class="comments">;; Read sub-structures, but do not create them, we have to</span>
          <span class="comments">;; do this because otherwise we lose synchronization.</span>
          for i = 0, n_sup-1 do begin
              
              cmsv_rstructdesc, block, pointer, tp, unit=unit, $
                status=status, errmsg=errmsg, suffix=suffix, $
                no_create=no_create, named_structs=structs, named_classes=classes
          endfor
      endif

      <span class="comments">;; Set output variables.  First, the name of this structure</span>
      stname = classname

      <span class="comments">;; Second, the name of this class is placed in the class name</span>
      <span class="comments">;; inventory.</span>
      if n_elements(classes) EQ 0 then $
        classes = [classname] $
      else $
        classes = [classes, classname]

      status = 1
      return
  endif

  <span class="comments">;; Make it a named structure if it has a name; otherwise it's</span>
  <span class="comments">;; anonymous</span>
  if stname NE '' AND NOT keyword_set(nocreate) then begin
      catch, catcherr
      if catcherr NE 0 then begin
          catch, /cancel
          status = 0
          errmsg = 'ERROR: CMSV_RVTYPE: conflict between memory and '+ $
            'saved named structures'
      endif else begin
          if n_elements(suffix) EQ 0 then sf = '' $
          else                            sf = strtrim(suffix(0),2)
          s1 = create_struct(ss, name=struct_name+sf)
          catch, /cancel
          
          ss = temporary(s1)
      endelse
  endif
  
  <span class="comments">;; Add this structure name to the inventory list</span>
  if stname NE '' then begin
      if n_elements(structs) EQ 0 then $
        structs = [stname] $
      else $
        structs = [structs, stname]
  endif

  status = 1
  if keyword_set(nocreate) then return
  if n_elements(ss) GT 0 then begin
      template = ss
      status = 1
  endif else begin
      status = 0
      errmsg = 'ERROR: CMSV_RVTYPE: could not decode structure descriptor'
  endelse

  return
end

<a id="cmsv_rvtype:source"></a>pro cmsv_rvtype, block, pointer, result, sz, unit=unit, offset=offset, $
                 status=status, errmsg=errmsg, $
                 template=template1, no_create=nocreate, no_type=notype, $
                 heap=heap, system=system, $
                 suffix=suffix, structure_name=stname, $
                 named_structs=structs, named_classes=classes

  <span class="comments">;; VARIABLE BLOCK</span>
  <span class="comments">;;   STRING - VARNAME - name of variable</span>
  <span class="comments">;;   TYPEDESC - type descriptor</span>

  <span class="comments">;; HEAP VARIABLE</span>
  <span class="comments">;;   LONG - HEAP_INDEX - heap index of data value</span>
  <span class="comments">;;   LONG - value 0x02 or 0x12 - unknown</span>
  <span class="comments">;;   TYPEDESC - type descriptor</span>
  status = 0
  size = [0L, 0, 1]
  if n_elements(pointer) EQ 0 then pointer = 0L
  result = 0 & dummy = temporary(result)

  if keyword_set(heap) then begin
      <span class="comments">;; Read heap index</span>
      varname = cmsv_rraw(/long, block, pointer, 2, unit=unit, $
                          status=status, errmsg=errmsg)
      varname = varname(0)
      if status EQ 0 then return
  endif else begin
      <span class="comments">;; Read variable name</span>
      varname = cmsv_rraw(/string, block, pointer, unit=unit, $
                          status=status, errmsg=errmsg)
      if status EQ 0 then return
  endelse

  if n_elements(classes) GT 0 then begin
      sz1 = size(classes)
      if sz1(sz1(0)+1) NE 7 then begin
          errmsg = 'ERROR: CMSV_RVTYPE: NAMED_CLASSES must be an array '+ $
            'of strings'
          status = 0
          return
      endif
  endif

  if n_elements(structs) GT 0 then begin
      sz1 = size(structs)
      if sz1(sz1(0)+1) NE 7 then begin
          errmsg = 'ERROR: CMSV_RVTYPE: NAMED_STRUCTS must be an array '+ $
            'of strings'
          status = 0
          return
      endif
  endif

  result = varname
  status = 1
  if keyword_set(notype) then return

  <span class="comments">;; Read variable type information.  Here is a summary of the</span>
  <span class="comments">;; formatting of the descriptors.</span>

  <span class="comments">;; SCALAR_TYPE</span>
  <span class="comments">;;   LONG - variable type (IDL type code)</span>
  <span class="comments">;;   LONG - value 0</span>

  <span class="comments">;; ARRAY_TYPE</span>
  <span class="comments">;;   LONG - variable type (IDL type code)</span>
  <span class="comments">;;   LONG - VARFLAGS - bitwise OR of following:</span>
  <span class="comments">;;                      '02'xb - system variable</span>
  <span class="comments">;;                      '04'xb - array</span>
  <span class="comments">;;                      '10'xb - don't know, it's kind of random</span>
  <span class="comments">;;                      '20'xb - structure</span>
  <span class="comments">;;   ARRAY_DESC - array descriptor</span>
  <span class="comments">;;   STRUCT_DESC (if a structure) - structure descriptor</span>

  <span class="comments">;; IDL variable type</span>
  vartype = cmsv_rraw(/long, block, pointer, unit=unit, $
                      status=status, errmsg=errmsg)
  if status EQ 0 then return
  <span class="comments">;; Array type flags</span>
  varflags = cmsv_rraw(/long, block, pointer, unit=unit, $
                       status=status, errmsg=errmsg)
  if status EQ 0 then return

  <span class="comments">;; System variable</span>
  if keyword_set(system) then begin
      dummy = cmsv_rraw(/long, block, pointer, 2, unit=unit, $
                        status=status, errmsg=errmsg)
      if status EQ 0 then return
      if (dummy(1) AND '02'xl) EQ 0 then begin
          errmsg = 'ERROR: CMSV_RVTYPE: system variable type mismatch'
          status = 0
          return
      endif
      if (dummy(1) AND 'ed'xl) NE (varflags AND 'ed'xl) then begin
          errmsg = 'ERROR: CMSV_RVTYPE: variable type mismatch'
          status = 0
          return
      endif
  endif

  <span class="comments">;; Scalar type</span>
  if (varflags(0) AND '24'x) EQ 0 then begin     
      sz = [0L, vartype, 1]
      return
  endif

  <span class="comments">;; Complex array type</span>
  struct = (varflags(0) AND '20'x) NE 0 
  cmsv_rarrdesc, block, pointer, sz, unit=unit, status=status, errmsg=errmsg
  if status EQ 0 then return
  if keyword_set(struct) then begin
      cmsv_rstructdesc, block, pointer, template1, unit=unit, $
        status=status, errmsg=errmsg, no_create=nocreate, $
        suffix=suffix, structure_name=stname, $
        named_structs=structs, named_classes=classes
  endif
  if status EQ 0 then return

  sz(sz(0)+1) = vartype

  return
end
</code>
    </div>
  </body>
</html>