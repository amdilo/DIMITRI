<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Tue Jul  2 12:51:04 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>get_parasol_direction_geometry.pro (Documentation for /home/marrabld/projects/DIMITRI_2.0/Source/)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="get_parasol_direction_geometry.pro (Documentation for /home/marrabld/projects/DIMITRI_2.0/Source/)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">;**************************************************************************************</span>
<span class="comments">;**************************************************************************************</span>
<span class="comments">;*</span>
<span class="comments">;* NAME:</span>
<span class="comments">;*      GET_PARASOL_DIRECTION_GEOMETRY       </span>
<span class="comments">;* </span>
<span class="comments">;* PURPOSE:</span>
<span class="comments">;*      RETURNS THE IMAGE DATA FOR A SPECIFIC PARASOL PRODUCT</span>
<span class="comments">;* </span>
<span class="comments">;* CALLING SEQUENCE:</span>
<span class="comments">;*      RES = GET_PARASOL_DIRECTION_GEOMETRY(L1B_IMAGE)      </span>
<span class="comments">;* </span>
<span class="comments">;* INPUTS:</span>
<span class="comments">;*      L1B_IMAGE - A STRUCTURE OF PIXELS RETURNED FROM GET_PARASOL_L1B_DATA </span>
<span class="comments">;*</span>
<span class="comments">;* KEYWORDS:</span>
<span class="comments">;*      VERBOSE     - PROCESSING STATUS OUTPUTS</span>
<span class="comments">;*</span>
<span class="comments">;* OUTPUTS:</span>
<span class="comments">;*      L1B_DATA     - A STRUCTURE OF THE CORRECTED VIEWING GEOMETRY </span>
<span class="comments">;*</span>
<span class="comments">;* COMMON BLOCKS:</span>
<span class="comments">;*      NONE</span>
<span class="comments">;*</span>
<span class="comments">;* MODIFICATION HISTORY:</span>
<span class="comments">;*             2005 - M Bouvet - PROTOTYPE DIMITRI VERSION</span>
<span class="comments">;*      15 DEC 2010 - C Kent   - DIMITRI-2 V1.0</span>
<span class="comments">;*</span>
<span class="comments">;* VALIDATION HISTORY:</span>
<span class="comments">;*      10 JAN 2010 - C KENT   - WINDOWS 32BIT MACHINE, COMPILATION AND EXECUTION </span>
<span class="comments">;*                               SUCCESSFUL. TESTED MULTIPLE OPTIONS ON MULTIPLE </span>
<span class="comments">;*                               PRODUCTS </span>
<span class="comments">;*      12 APR 2011 - C KENT   - LINUX 64BIT MACHINE IDL 8.0: COMPILATION AND OPERATION SUCCESSFUL </span>
<span class="comments">;*</span>
<span class="comments">;**************************************************************************************</span>
<span class="comments">;**************************************************************************************</span>

FUNCTION GET_PARASOL_DIRECTION_GEOMETRY,L1B_IMAGE

XJ = {$
B443P:-6,$
B443NP:-4,$
B1020:-3,$
B565:-2,$
B670:0,$
B763:2,$
B765:3,$
B910:4,$
B865:6 $
}

NUM_RECS = N_ELEMENTS(L1B_IMAGE)

TEMP_CORRECTED_VZA = FLTARR(NUM_RECS,9)
TEMP_CORRECTED_VAA = FLTARR(NUM_RECS,9)

TEMP_VZA_F8           = L1B_IMAGE.VZA_F8   
TEMP_RAA_F8           = L1B_IMAGE.RAA_F8
TEMP_DELTA_AV_COS_A   = L1B_IMAGE.DELTA_AV_COS_A
TEMP_DELTA_AV_SIN_A   = L1B_IMAGE.DELTA_AV_SIN_A

<span class="comments">;LOOP OVER EACH PIXEL</span>
FOR I=0,NUM_RECS DO BEGIN
<span class="comments">;LOOP OVER EACH DIRECTION</span>
FOR DIR=0,8 DO BEGIN

TEMP1 =  (TEMP_VZA_F8[DIR,I]*COS(TEMP_RAA_F8[DIR,I])+(XJ.(DIR)*TEMP_DELTA_AV_COS_A[DIR,I]))
TEMP2 =  (TEMP_VZA_F8[DIR,I]*SIN(TEMP_RAA_F8[DIR,I])+(XJ.(DIR)*TEMP_DELTA_AV_SIN_A[DIR,I]))
TEMP_CORRECTED_VZA[I,DIR] = SQRT(TEMP1^2+TEMP2^2)
TEMP_CORRECTED_VAA[I,DIR] = ATAN(TEMP2/TEMP1)


IF TEMP2 LT 0.0 THEN TEMP_CORRECTED_VAA[I,DIR]= TEMP_CORRECTED_VAA[I,DIR]+180.0


ENDFOR

ENDFOR

STOP
END














<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">;;------------------------</span>
<span class="comments">;; KEYWORD PARAMETER CHECK</span>
<span class="comments">;</span>
<span class="comments">;  IF STRCMP(FILENAME,'') THEN BEGIN</span>
<span class="comments">;    PRINT, 'PARASOL L1B DATA: NO INPUT FILES PROVIDED, RETURNING...'</span>
<span class="comments">;    RETURN,-1</span>
<span class="comments">;  ENDIF  </span>
<span class="comments">;  </span>
<span class="comments">;;-----------------------------------------------</span>
<span class="comments">;; CHECK FILENAME OS A PARASOL DATA FILE</span>
<span class="comments">;</span>
<span class="comments">;  TEMP = STRMATCH(FILENAME,'*P3L1TBG*D*')</span>
<span class="comments">;  IF TEMP EQ 0 THEN BEGIN</span>
<span class="comments">;    PRINT, 'PARASOL L1B DATA: ERROR, INPUT FILE NOT A PARASOL DATA FILE'</span>
<span class="comments">;    RETURN,-1</span>
<span class="comments">;  ENDIF</span>
<span class="comments">;</span>
<span class="comments">;;------------------------------------------------</span>
<span class="comments">;; CHECK THAT THE FILE EXISTS</span>
<span class="comments">;</span>
<span class="comments">;  TEMP = FILE_INFO(FILENAME)</span>
<span class="comments">;  IF TEMP.EXISTS EQ 0 THEN BEGIN</span>
<span class="comments">;    PRINT, 'PARASOL L1B DATA: ERROR, INPUT FILE DOES NOT EXIST'</span>
<span class="comments">;    RETURN,-1</span>
<span class="comments">;  ENDIF</span>
<span class="comments">;</span>
<span class="comments">;;------------------------------------------------</span>
<span class="comments">;; IF ENDIAN SIZE NOT PROVIDED THEN GET VALUE</span>
<span class="comments">;</span>
<span class="comments">;   IF N_ELEMENTS(ENDIAN_SIZE) EQ 0 THEN BEGIN</span>
<span class="comments">;    IF KEYWORD_SET(VERBOSE) THEN BEGIN</span>
<span class="comments">;      PRINT, 'MERIS L1B VIEWING GEOMETRIES: NO ENDIAN SIZE PROVIDED, RETRIEVING...'</span>
<span class="comments">;      ENDIAN_SIZE = GET_ENDIAN_SIZE(/VERBOSE)</span>
<span class="comments">;    ENDIF ELSE ENDIAN_SIZE = GET_ENDIAN_SIZE()</span>
<span class="comments">;  ENDIF</span>
<span class="comments">;</span>
<span class="comments">;;------------------------------------------------</span>
<span class="comments">;; OPEN THE PRODUCT AND READ NUMBER AND SIZE OF RECORDS</span>
<span class="comments">;</span>
<span class="comments">;  OPENR,IN_PARA,FILENAME,/GET_LUN</span>
<span class="comments">;  TEMP = BYTARR(52)</span>
<span class="comments">;  NUM_RECS = ULONG(1)</span>
<span class="comments">;  REC_SIZE = ULONG(1)</span>
<span class="comments">;  READU,IN_PARA,TEMP</span>
<span class="comments">;  READU,IN_PARA,NUM_RECS</span>
<span class="comments">;  READU,IN_PARA,REC_SIZE </span>
<span class="comments">;</span>
<span class="comments">;;------------------------------------------------</span>
<span class="comments">;; SWAP ENDIAN IF NEEDED - DATA IS BIG ENDIAN</span>
<span class="comments">;</span>
<span class="comments">;  IF ENDIAN_SIZE EQ 0 THEN BEGIN</span>
<span class="comments">;    NUM_RECS = SWAP_ENDIAN(NUM_RECS)</span>
<span class="comments">;    REC_SIZE = SWAP_ENDIAN(REC_SIZE)</span>
<span class="comments">;  ENDIF</span>
<span class="comments">;</span>
<span class="comments">;;------------------------------------------------</span>
<span class="comments">;; GET THE PIXEL STRUCTURE</span>
<span class="comments">;  </span>
<span class="comments">;  L1B_PIXELS = GET_PARASOL_L1B_PIXEL_STRUCTURE(NUM_RECS)</span>
<span class="comments">;  L1B_PIXEL  = GET_PARASOL_L1B_PIXEL_STRUCTURE(1)</span>
<span class="comments">;</span>
<span class="comments">;;------------------------------------------------</span>
<span class="comments">;; DEFINE TEMPORARY VARIABLES FOR READING</span>
<span class="comments">;</span>
<span class="comments">;  TEMP_HDR = 180</span>
<span class="comments">;  TEMP_SSI = INTARR(1)</span>
<span class="comments">;  TEMP_USI = UINTARR(1)</span>
<span class="comments">;  TEMP_ULI = ULONARR(1)</span>
<span class="comments">;  TEMP_BYT = BYTARR(1)</span>
<span class="comments">;  TEMP_REF = INTARR(15)</span>
<span class="comments">;</span>
<span class="comments">;;------------------------------------------------</span>
<span class="comments">;; LOOP OVER EACH RECORD AND RETRIEVE DATA</span>
<span class="comments">;</span>
<span class="comments">;  FOR IN_REC=0,NUM_RECS-1 DO BEGIN</span>
<span class="comments">;  </span>
<span class="comments">;;------------------------------------------------</span>
<span class="comments">;; RETRIEVE LINE AND COLUMN INDEX</span>
<span class="comments">;    </span>
<span class="comments">;    POINT_LUN,IN_PARA,TEMP_HDR+REC_SIZE*IN_REC+6</span>
<span class="comments">;    READU,IN_PARA,TEMP_USI</span>
<span class="comments">;      IF ENDIAN_SIZE EQ 0 THEN TEMP_USI = SWAP_ENDIAN(TEMP_USI)</span>
<span class="comments">;    L1B_PIXELS[IN_REC].LINE=TEMP_USI</span>
<span class="comments">;    READU,IN_PARA,TEMP_USI</span>
<span class="comments">;      IF ENDIAN_SIZE EQ 0 THEN TEMP_USI = SWAP_ENDIAN(TEMP_USI)</span>
<span class="comments">;    L1B_PIXELS[IN_REC].COLUMN=TEMP_USI</span>
<span class="comments">;</span>
<span class="comments">;;-----------------------------------------------</span>
<span class="comments">;; COMPUTE GEOLOCATION FROM LINE AND COLUMN INDEX</span>
<span class="comments">;</span>
<span class="comments">;    L1B_PIXELS[IN_REC].LATITUDE=90.0-(L1B_PIXELS[IN_REC].LINE-0.5)/18.0</span>
<span class="comments">;    N_i=round(3240.0*cos(L1B_PIXELS[IN_REC].LATITUDE*!DTOR))*1.0</span>
<span class="comments">;    L1B_PIXELS[IN_REC].LONGITUDE=180./N_i*(L1B_PIXELS[IN_REC].COLUMN-3240.5)</span>
<span class="comments">;</span>
<span class="comments">;;-----------------------------------------------</span>
<span class="comments">;; RETRIEVE SAA AND NUMBER OF VIEWING DIRECTIONS</span>
<span class="comments">;</span>
<span class="comments">;    POINT_LUN,IN_PARA,TEMP_HDR+REC_SIZE*IN_REC+46</span>
<span class="comments">;    READU,IN_PARA,TEMP_BYT</span>
<span class="comments">;      IF ENDIAN_SIZE EQ 0 THEN TEMP_BYT = SWAP_ENDIAN(TEMP_BYT)    </span>
<span class="comments">;    L1B_PIXELS[IN_REC].SAA = TEMP_BYT*1.4</span>
<span class="comments">;    READU,IN_PARA,TEMP_BYT</span>
<span class="comments">;      IF ENDIAN_SIZE EQ 0 THEN TEMP_BYT = SWAP_ENDIAN(TEMP_BYT)    </span>
<span class="comments">;    L1B_PIXELS[IN_REC].NUM_DIR = TEMP_BYT</span>
<span class="comments">;</span>
<span class="comments">;;----------------------------------------------</span>
<span class="comments">;; IF NO DIRECTIONS AVAILABLE THEN SKIP PIXEL</span>
<span class="comments">;</span>
<span class="comments">;    IF L1B_PIXELS[IN_REC].NUM_DIR LT 1 THEN GOTO,NO_DIR</span>
<span class="comments">;</span>
<span class="comments">;;----------------------------------------------</span>
<span class="comments">;; LOOP OVER THE DIRECTIONS</span>
<span class="comments">;</span>
<span class="comments">;    ;FOR IN_DIR = 0,L1B_PIXELS[IN_REC].NUM_DIR-1 DO BEGIN</span>
<span class="comments">;    FOR IN_DIR = 0,15 DO BEGIN</span>
<span class="comments">; </span>
<span class="comments">;      POINT_LUN,IN_PARA,TEMP_HDR+REC_SIZE*IN_REC+43*IN_DIR+55 </span>
<span class="comments">;      READU,IN_PARA,TEMP_USI</span>
<span class="comments">;       IF ENDIAN_SIZE EQ 0 THEN TEMP_USI = SWAP_ENDIAN(TEMP_USI)     </span>
<span class="comments">;      L1B_PIXELS[IN_REC].SZA[IN_DIR] = TEMP_USI*1.5e-3</span>
<span class="comments">; </span>
<span class="comments">;      READU,IN_PARA,TEMP_USI</span>
<span class="comments">;       IF ENDIAN_SIZE EQ 0 THEN TEMP_USI = SWAP_ENDIAN(TEMP_USI)     </span>
<span class="comments">;      L1B_PIXELS[IN_REC].VZA_F8[IN_DIR] = TEMP_USI*1.5e-3</span>
<span class="comments">; </span>
<span class="comments">;      READU,IN_PARA,TEMP_USI</span>
<span class="comments">;       IF ENDIAN_SIZE EQ 0 THEN TEMP_USI = SWAP_ENDIAN(TEMP_USI)     </span>
<span class="comments">;      L1B_PIXELS[IN_REC].RAA_F8[IN_DIR] = TEMP_USI*6.0e-3</span>
<span class="comments">;  </span>
<span class="comments">;      READU,IN_PARA,TEMP_BYT</span>
<span class="comments">;      IF TEMP_BYT GT 127 THEN BEGIN</span>
<span class="comments">;      L1B_PIXELS[IN_REC].DELTA_AV_COS_A[IN_DIR]=(TEMP_BYT-256)*1.6E-3</span>
<span class="comments">;      ENDIF ELSE L1B_PIXELS[IN_REC].DELTA_AV_COS_A[IN_DIR]=TEMP_BYT*1.6E-3</span>
<span class="comments">;</span>
<span class="comments">;      READU,IN_PARA,TEMP_BYT</span>
<span class="comments">;      IF TEMP_BYT GT 127 THEN BEGIN</span>
<span class="comments">;      L1B_PIXELS[IN_REC].DELTA_AV_SIN_A[IN_DIR]=(TEMP_BYT-256)*1.6E-3</span>
<span class="comments">;      ENDIF ELSE L1B_PIXELS[IN_REC].DELTA_AV_SIN_A[IN_DIR]=TEMP_BYT*1.6E-3</span>
<span class="comments">;           </span>
<span class="comments">;; READ THE REFLECTANCES</span>
<span class="comments">;      READU,IN_PARA,TEMP_REF </span>
<span class="comments">;      IF ENDIAN_SIZE EQ 0 THEN TEMP_REF=SWAP_ENDIAN(TEMP_REF)</span>
<span class="comments">;      REF_SF = 1E-4</span>
<span class="comments">;      L1B_PIXELS[IN_REC].REF_443NP[IN_DIR]  = (TEMP_REF[0]*REF_SF)>0.0</span>
<span class="comments">;      L1B_PIXELS[IN_REC].REF_490P[IN_DIR]   = (TEMP_REF[1]*REF_SF)>0.0</span>
<span class="comments">;      L1B_PIXELS[IN_REC].REF_1020NP[IN_DIR] = (TEMP_REF[2]*REF_SF)>0.0</span>
<span class="comments">;      L1B_PIXELS[IN_REC].REF_565NP[IN_DIR]  = (TEMP_REF[3]*REF_SF)>0.0</span>
<span class="comments">;      L1B_PIXELS[IN_REC].REF_670P[IN_DIR]   = (TEMP_REF[4]*REF_SF)>0.0</span>
<span class="comments">;      L1B_PIXELS[IN_REC].REF_763NP[IN_DIR]  = (TEMP_REF[5]*REF_SF)>0.0</span>
<span class="comments">;      L1B_PIXELS[IN_REC].REF_765NP[IN_DIR]  = (TEMP_REF[6]*REF_SF)>0.0</span>
<span class="comments">;      L1B_PIXELS[IN_REC].REF_865P[IN_DIR]   = (TEMP_REF[7]*REF_SF)>0.0</span>
<span class="comments">;      L1B_PIXELS[IN_REC].REF_910NP[IN_DIR]  = (TEMP_REF[8]*REF_SF)>0.0</span>
<span class="comments">;      L1B_PIXELS[IN_REC].REF_490P_Q[IN_DIR] = (TEMP_REF[9]*REF_SF)>0.0</span>
<span class="comments">;      L1B_PIXELS[IN_REC].REF_670P_Q[IN_DIR] = (TEMP_REF[10]*REF_SF)>0.0</span>
<span class="comments">;      L1B_PIXELS[IN_REC].REF_865P_Q[IN_DIR] = (TEMP_REF[11]*REF_SF)>0.0</span>
<span class="comments">;      L1B_PIXELS[IN_REC].REF_490P_U[IN_DIR] = (TEMP_REF[12]*REF_SF)>0.0</span>
<span class="comments">;      L1B_PIXELS[IN_REC].REF_670P_U[IN_DIR] = (TEMP_REF[13]*REF_SF)>0.0</span>
<span class="comments">;      L1B_PIXELS[IN_REC].REF_865P_U[IN_DIR] = (TEMP_REF[14]*REF_SF)>0.0   </span>
<span class="comments">;   </span>
<span class="comments">;    ENDFOR ;END OF DIRECITON LOOP</span>
<span class="comments">;   NO_DIR:</span>
<span class="comments">;   ENDFOR;END OF PIXEL LOOP</span>
<span class="comments">;</span>
<span class="comments">;;------------------------------------</span>
<span class="comments">;; CLOSE THE PRODUCT</span>
<span class="comments">;</span>
<span class="comments">;  FREE_LUN,IN_PARA</span>
<span class="comments">;</span>
<span class="comments">;;-------------------------------------</span>
<span class="comments">;; CURRENT DIMITRI METHOD FOR GENERATING THE IMAGE</span>
<span class="comments">;</span>
<span class="comments">;  MIN_LON_PIX=MIN(L1B_PIXELS.COLUMN)</span>
<span class="comments">;  MAX_LON_PIX=MAX(L1B_PIXELS.COLUMN)</span>
<span class="comments">;  MIN_LAT_PIX=MIN(L1B_PIXELS.LINE)</span>
<span class="comments">;  MAX_LAT_PIX=MAX(L1B_PIXELS.LINE)</span>
<span class="comments">;  DIM_X_IMAGE=MAX_LON_PIX-MIN_LON_PIX+1</span>
<span class="comments">;  DIM_Y_IMAGE=MAX_LAT_PIX-MIN_LAT_PIX+1</span>
<span class="comments">;</span>
<span class="comments">;;-------------------------------------</span>
<span class="comments">;;GENERATE L1B_IMAGE TO BE POPULATED</span>
<span class="comments">;  </span>
<span class="comments">;  L1B_IMAGE=REPLICATE(L1B_PIXEL[0], DIM_X_IMAGE, DIM_Y_IMAGE)</span>
<span class="comments">;</span>
<span class="comments">;; L1B_IMAGE = REFORM(L1B_PIXELS, DIM_X_IMAGE, DIM_Y_IMAGE)</span>
<span class="comments">;</span>
<span class="comments">;;STOP</span>
<span class="comments">;</span>
<span class="comments">; ; FOR IN_REC=0, NUM_RECS-1 DO BEGIN</span>
<span class="comments">; ;   L1B_IMAGE[L1B_PIXELS[IN_REC].COLUMN-MIN_LON_PIX, L1B_PIXELS[IN_REC].LINE-MIN_LAT_PIX]= L1B_PIXELS[IN_REC]</span>
<span class="comments">; ; ENDFOR</span>
<span class="comments">;</span>
<span class="comments">;;TRYING A NEW METHOD</span>
<span class="comments">;FOR I=0,DIM_X_IMAGE-1 DO BEGIN</span>
<span class="comments">;  FOR J=0,DIM_Y_IMAGE-1 DO BEGIN</span>
<span class="comments">;  </span>
<span class="comments">;    RES = WHERE(L1B_PIXELS.COLUMN-MIN_LON_PIX EQ I AND L1B_PIXELS.LINE-MIN_LAT_PIX EQ J)</span>
<span class="comments">;    IF RES[0] GT -1 AND N_ELEMENTS(RES) EQ 1 THEN L1B_IMAGE[I,J]=L1B_PIXELS[RES]</span>
<span class="comments">;  </span>
<span class="comments">;  ENDFOR</span>
<span class="comments">;ENDFOR</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">;RETURN,L1B_IMAGE</span>
<span class="comments">;</span>
<span class="comments">;END</span>
</code>
    </div>
  </body>
</html>