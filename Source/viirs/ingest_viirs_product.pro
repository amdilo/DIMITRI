FUNCTION INGEST_VIIRS_PRODUCT, IFILES, INPUT_FOLDER=INPUT_FOLDER, ICOORDS=ICOORDS,$
  COLOUR_TABLE=COLOUR_TABLE,$
  PLOT_XSIZE=PLOT_XSIZE, PLOT_YSIZE=PLOT_YSIZE, NO_ZBUFF=NO_ZBUFF, NO_QUICKLOOK=NO_QUICKLOOK,$
  VERBOSE=VERBOSE
;+
; :Name:
;      INGEST_MODISA_PRODUCT
;
; :Purpose:
;      Ingests VIIRS l1b data into dimitri database. multiple product
;      extraction is available but it expects all files to be the same region/processing.
;      outputs quicklook images, updates database and appends data to sav file for
;      specified region and processing.
;
; :Calling sequence:
;      RES = INGEST_MODISA_PRODUCT(IFILES)
;
; :Params:
;      IFILES :
;        A string or string array of the full path filenames of products for ingestion.
;
; :Keywords:
;      INPUT_FOLDER  :
;          - A String containing the full path of the 'input' folder, if
;                          not provided then it is derived from the filename
;      ICOORDS :
;           - A four element floating-point array containing the north, south,
;                          east and west coordinates of the roi, e.g [50.,45.,10.,0.]
;      NB_PIX_THRESHOLD :
;        - Number of pixels within roi to be accepted
;      ENDIAN_SZE :
;            - Machine endian size (0: little, 1: big), if not provided then computed.
;      COLOUR_TABLE :
;           - User defined idl colour table index (default is 39)
;      PLOT_XSIZE :
;             - Width of generated plots (default is 700px)
;      PLOT_YSIZE :
;             - Height of generated plots (default is 400px)
;      NO_ZBUFF :
;               - If set then plots are generated in windows and not wihtin the z-buffer.
;      NO_QUICKLOOK  :
;          - If set then quicklooks are not generated for ifiles.
;      VERBOSE  :
;               - Processing status outputs
;
; :Returns:
;      STATUS  :
;      - 1: No errors reported, (-1) or 0: errors during ingestion
;
; :Common blocks:
;      NONE
;
; :History:
;        02 JUL 2013 - D MARRABLE  
;-

;------------------------
; KEYWORD PARAMETER CHECK - NOTE, ASSUMES ALL PRODUCT ARE RELATED TO THE SAME REGION/PROCESSING

IF STRCMP(STRING(IFILES[0]),'') THEN BEGIN
  PRINT, 'VIIRS L1B INGEST: ERROR, NO INPUT FILES PROVIDED, RETURNING...'
  RETURN,-1
ENDIF

IF N_ELEMENTS(INPUT_FOLDER) EQ 0 THEN INPUT_FOLDER = GET_DIMITRI_LOCATION('INPUT')

DELIM = GET_DIMITRI_LOCATION('DL')
TEMP = STRSPLIT(IFILES[0], DELIM, /EXTRACT)

TEMP_INF  = WHERE(STRCMP(TEMP,'Input') EQ 1)
TEMP_INF  = TEMP_INF(N_ELEMENTS(TEMP_INF)-1)
IREGION   = TEMP[TEMP_INF+1]
IREGION   = STRMID(IREGION,5,STRLEN(IREGION))
SENSOR    = TEMP[TEMP_INF+2]
IPROC     = TEMP[TEMP_INF+3]
IPROC     = STRMID(IPROC,5,STRLEN(IPROC))
CFIG_DATA = GET_DIMITRI_CONFIGURATION()
AQA_SITE_TYPE = GET_SITE_TYPE(IREGION,VERBOSE=VERBOSE)

IF STRUPCASE(AQA_SITE_TYPE) EQ 'OCEAN' THEN AQA_SENSOR = SENSOR+'_O' ELSE AQA_SENSOR = SENSOR+'_L'

IF N_ELEMENTS(ICOORDS) EQ 0 THEN BEGIN
  PRINT, 'VIIRS L1B INGEST: NO ROI COORDINATES PROVIDED, USING DEFAULT OF [90.,-90,180.0,-180.0]'
  ICOORDS = [90.,-90.,180.0,-180.0]
ENDIF
IF N_ELEMENTS(COLOUR_TABLE) EQ 0 THEN BEGIN
  PRINT, 'VIIRS L1B INGEST: NO COLOR_TABLE SET, USING DEFAULT OF 39'
  COLOUR_TABLE = CFIG_DATA.(1)[2]
ENDIF
IF N_ELEMENTS(PLOT_XSIZE) EQ 0 THEN BEGIN
  PRINT, 'VIIRS L1B INGEST: PLOT_XSIZE NOT SET, USING DEFAULT OF 700'
  PLOT_XSIZE = CFIG_DATA.(1)[0]
ENDIF
IF N_ELEMENTS(PLOT_YSIZE) EQ 0 THEN BEGIN
  PRINT, 'VIIRS L1B INGEST: PLOT_YSIZE NOT SET, USING DEFAULT OF 400'
  PLOT_YSIZE = CFIG_DATA.(1)[1]
ENDIF

;------------------------
; DEFINE OUTPUT

OUTPUT_SAV = STRING(INPUT_FOLDER+DELIM+'Site_'+IREGION+DELIM+SENSOR+DELIM+'Proc_'+IPROC+DELIM+SENSOR+'_TOA_REF.dat')
NCDF_FILENAME = STRING(INPUT_FOLDER+DELIM+'Site_'+IREGION+DELIM+SENSOR+DELIM+'Proc_'+IPROC+DELIM+IREGION+'_'+SENSOR+'_Proc_'+IPROC+'.nc')

;------------------------
; GET NUMBER OF IFILES

NB_FILES = N_ELEMENTS(IFILES)

;-----------------------------------------------
; GET THE DATABASE STRUCTURE

DB_DATA = GET_DIMITRI_TEMPLATE(NB_FILES, /DB)

;-----------------------------------------------
; ADD DATA OF INGESTION TO DB_DATA

TEMP = SYSTIME()
TEMP = STRMATCH(STRMID(TEMP,8,1),' ') ? '0'+STRUPCASE(STRING(STRMID(TEMP,9,1)+'-'+STRMID(TEMP,4,3)+'-'+STRMID(TEMP,20,4))) : STRUPCASE(STRING( STRMID(TEMP,8,2)+'-'+STRMID(TEMP,4,3)+'-'+STRMID(TEMP,20,4)))
DB_DATA.DIMITRI_DATE = TEMP

;-----------------------------------------------
; ADD REGION, SENSOR AND PROC VERSION TO DB_DATA

DB_DATA.REGION = IREGION
DB_DATA.SENSOR = SENSOR
DB_DATA.PROCESSING_VERSION = IPROC

;------------------------
; GET NUMBER OF IFILES

NB_FILES = N_ELEMENTS(IFILES)


;----------------------------------
; DEFINE VIIRS SPECIFIC PARAMETERS

NB_BANDS = 16
NB_DIRS = SENSOR_DIRECTION_INFO(SENSOR)

;----------------------------------
; DEFINE THE STATISTICAL ARRAYS

BADVAL = -999.0
ROI_AVG_TOA_REF  = FLTARR(NB_BANDS, NB_FILES)
ROI_STD_TOA_REF  = FLTARR(NB_BANDS, NB_FILES)
NB_ROI_PX        = FLTARR(NB_FILES)
GOOD_RECORD      = MAKE_ARRAY(NB_FILES, /INTEGER, VALUE=0)
IFILE_DATE       = DBLARR(5, NB_FILES);CONTAINS YEAR,MONTH,DAY,DOY,DECIMEL_YEAR
IFILE_VIEW       = DBLARR(4, NB_FILES);CONTAINS SENSOR ZENITH,SENSOR AZIMUTH,SOLAR ZENITH,SOLAR AZIMUTH
IFILE_AUX        = FLTARR(12, NB_FILES);CONTAINS OZONE,PRESSURE,RELHUMIDITY,WIND_ZONAL,WIND_MERID, AND WVAP (MU AND SIGMA)

;---------------------------------
; IF ONLY 1 PRODUCT FOR INGESTION THEN REFORM ARRAYS

IF NB_FILES EQ 1 THEN BEGIN
  ROI_AVG_TOA_REF  = REFORM(ROI_AVG_TOA_REF,NB_BANDS,NB_FILES)
  ROI_STD_TOA_REF  = REFORM(ROI_STD_TOA_REF,NB_BANDS,NB_FILES)
  IFILE_DATE       = REFORM(IFILE_DATE,5,NB_FILES)
  IFILE_VIEW       = REFORM(IFILE_VIEW,4,NB_FILES)
  IFILE_AUX        = REFORM(IFILE_AUX,12,NB_FILES)
ENDIF

IF KEYWORD_SET(VERBOSE) THEN BEGIN
  PRINT, 'VIIRS L1B INGEST: DEFINITION OF OUTPUT ARRAYS:'
  HELP, ROI_AVG_TOA_REF,ROI_STD_TOA_REF,NB_ROI_PX,GOOD_RECORD,IFILE_DATE,IFILE_VIEW
ENDIF

;---------------------------------
; ADD DATA TO NETCDF OUTPUT STRUCTURE

NCDF_OUT = GET_DIMITRI_EXTRACT_NCDF_DATA_STRUCTURE(NB_FILES,NB_BANDS,NB_DIRS)
NCDF_OUT.ATT_FNAME  = 'Site_'+IREGION+'_'+SENSOR+'_'+'Proc_'+IPROC+'.nc'
NCDF_OUT.ATT_TOOL   = GET_DIMITRI_LOCATION('TOOL')
NCDF_OUT.ATT_SENSOR = SENSOR
NCDF_OUT.ATT_PROCV  = IPROC
NCDF_OUT.ATT_PRES   = STRTRIM(STRING(SENSOR_PIXEL_SIZE(SENSOR)),2)+' KM'
NCDF_OUT.ATT_NBANDS = STRTRIM(STRING(NB_BANDS),2)
NCDF_OUT.ATT_NDIRS  = STRTRIM(STRING(NB_DIRS[0]),2)
NCDF_OUT.ATT_SITEN  = IREGION
NCDF_OUT.ATT_SITEC  = STRJOIN(STRTRIM(STRING(ICOORDS),2),' ')
NCDF_OUT.ATT_SITET  = AQA_SITE_TYPE

;----------------------------------
; START MAIN LOOP OVER EACH IFILE

IF KEYWORD_SET(VERBOSE) THEN PRINT, 'VIIRS L1B INGEST: STARTING INGESTION LOOP ON viirs PRODUCTS'
FOR IN_FNAME=0,NB_FILES-1 DO BEGIN; IN_FNAME IS RESERVED FOR LOOPS WITHIN THE INGESTION ROUTINES

  TEMP = STRSPLIT(IFILES[IN_FNAME],DELIM,/EXTRACT)
  DB_DATA.FILENAME[IN_FNAME] = TEMP[N_ELEMENTS(TEMP)-1]
  
  ;------------------------------------------
  ; GENERATE A QUICKLOOK WITH THE ROI OVERLAID
  
  IF N_ELEMENTS(NO_QUICKLOOK) EQ 0 THEN BEGIN
    IF KEYWORD_SET(VERBOSE) THEN PRINT, 'VIIRS L1B INGEST: GENERATE QUICKLOOK OF PRODUCT'
    IF FIX(CFIG_DATA.(1)[3]) EQ 1 THEN QL_STATUS =  GET_VIIRS_QUICKLOOK(IFILES[IN_FNAME],/ROI,/RGB,ICOORDS=ICOORDS,VERBOSE=VERBOSE) $
    ELSE QL_STATUS =  GET_VIIRS_QUICKLOOK(IFILES[IN_FNAME],/ROI,ICOORDS=ICOORDS,VERBOSE=VERBOSE)
    
    IF KEYWORD_SET(VERBOSE) THEN IF QL_STATUS EQ -1 THEN PRINT, 'VIIRS L1B INGEST: QUICKLOOK GENERATION FAILED - ',IFILES[IN_FNAME] $
    ELSE PRINT, 'VIIRS L1B INGEST: QUICKLOOK GENERATION SUCCESS'
  ENDIF 
  
  
  ;------------------------------------------
  ; RETRIEVE AUX DATA FILENAMES FOR DB_DATA
  ;  TODO!!! Check this
  
  
  ;----------------------------------
  ; RETRIEVE DATE INFORMATION
  
  IF KEYWORD_SET(VERBOSE) THEN PRINT, 'VIIRS L1B INGEST: RETRIEVING DATE INFORMATION'
  TEMP_DATE = GET_VIIRS_DATE_INFO(IFILES[IN_FNAME],VERBOSE=VERBOSE)
  
  IFILE_DATE[0,IN_FNAME]  = TEMP_DATE.YEAR
  IFILE_DATE[1,IN_FNAME]  = TEMP_DATE.MONTH
  IFILE_DATE[2,IN_FNAME]  = TEMP_DATE.DAY
  IFILE_DATE[3,IN_FNAME]  = TEMP_DATE.DOY
  IFILE_DATE[4,IN_FNAME]  = TEMP_DATE.DYEAR
  
  ;----------------------------------
  ; ADD DATE INFORMATION TO DB_DATA
  
  DB_DATA.YEAR[IN_FNAME]  = IFILE_DATE[0,IN_FNAME]
  DB_DATA.MONTH[IN_FNAME] = IFILE_DATE[1,IN_FNAME]
  DB_DATA.DAY[IN_FNAME]   = IFILE_DATE[2,IN_FNAME]
  DB_DATA.DOY[IN_FNAME]   = IFILE_DATE[3,IN_FNAME]
  DB_DATA.DECIMAL_YEAR[IN_FNAME] = IFILE_DATE[4,IN_FNAME]

  ;----------------------------------
  ; RETRIEVE INPUT FILE GEOLOCATION
  
  IF KEYWORD_SET(VERBOSE) THEN PRINT, 'VIIRS L1B INGEST: RETRIEVING GEOLOCATION INFORMATION'
  ;IFILE_GEO = GET_VIIRS_LAT_LON(IFILES[IN_FNAME], VERBOSE=VERBOSE)
  ; BECUASE WE HAVE FIXED THE BOWTIE EFFECT WE CAN'T GET LAT LON FROM THE ORIGINAL FILE NAME
  ; WE CACHED IT TO DISK IN GET_*_L1B_*.PRO
  
  RESTORE, 'LAT_LON_VIIRS_REGRID.SAV'
  IFILE_GEO = Temporary(BOWTIE_CORRECTION_STRUCTURE)
  
  ;----------------------------------
  ; RETRIEVE INPUT FILE L1B REFLECTANCE
  
  IF KEYWORD_SET(VERBOSE) THEN PRINT, 'VIIRS L1B INGEST: RETRIEVING REFLECTANCE INFORMATION'
  TOA_REF_750M = GET_VIIRS_L1B_REFLECTANCE(IFILES[IN_FNAME], 0, VERBOSE=VERBOSE)
  
  ;------------------------------------------
  ; RETRIEVE INDEX OF NOMINAL DATA WITHIN ROI
  
  IF KEYWORD_SET(VERBOSE) THEN PRINT, 'VIIRS L1B INGEST: RETRIEVING INDEX OF PIXELS WITHIN ROI'
  ROI_INDEX = WHERE($
    IFILE_GEO.LAT LT ICOORDS[0] AND $
    IFILE_GEO.LAT GT ICOORDS[1] AND $
    IFILE_GEO.LON LT ICOORDS[2] AND $
    IFILE_GEO.LON gT ICOORDS[3] AND $
    TOA_REF_750M[*,*,0] GT 0.0  , $
    NB_PIX $
    )
    
  DB_DATA.NUM_ROI_PX[IN_FNAME] = NB_PIX
  
  ;-----------------------------------------
  ; SET INITIAL VALUES OF CLOUD SCREENING
  
  DB_DATA.AUTO_CS[IN_FNAME] = -1
  DB_DATA.MANUAL_CS[IN_FNAME] = -1
  
  ;-----------------------------------------
  ; STORE DATE IN NETCDF STRUCTURE
  
  NCDF_OUT.VAR_PNAME[IN_FNAME]  = DB_DATA.FILENAME[IN_FNAME]
  NCDF_OUT.VAR_PTIME[IN_FNAME]  = STRJOIN(STRSPLIT(TEMP_DATE.CMD_DATE,'-',/EXTRACT))+' '+STRMID(TEMP_DATE.CMD_TIME,0,2)+':'+STRMID(TEMP_DATE.CMD_TIME,3,2)+':'+STRMID(TEMP_DATE.CMD_TIME,6,2)
  NCDF_OUT.VAR_DTIME[IN_FNAME]  = DB_DATA.DECIMAL_YEAR[IN_FNAME]
  
  ;-----------------------------------------
  ; IF NUMBER OF PIXELS IN ROI LESS THAN
  ; DEFINED THRESHOLD THEN DO NOT RETRIEVE
  ; TOA REFLECTANCE
  SIZE_ROI_INDEX = SIZE(ROI_INDEX)
  IF SIZE_ROI_INDEX[1] lt 50 THEN BEGIN
    DB_DATA.NUM_ROI_PX[IN_FNAME] = -1
    IFILE_VIEW[*,IN_FNAME]= BADVAL
    IFILE_AUX[*,IN_FNAME] = BADVAL
    ROI_AVG_TOA_REF(*,IN_FNAME) = BADVAL
    ROI_STD_TOA_REF(*,IN_FNAME) = BADVAL
    GOTO, NO_ROI
  ENDIF
  
  GOOD_RECORD[IN_FNAME] = 1
  
  ;-----------------------------------------
  ; CHECK ROI COVERAGE
  
  IF DB_DATA.NUM_ROI_PX[IN_FNAME] GT 0 THEN BEGIN
    TROI = CHECK_ROI_COVERAGE(IFILE_GEO.LAT, IFILE_GEO.LON, ROI_INDEX, ICOORDS, VERBOSE=VERBOSE)
    IF TROI GT DB_DATA.ROI_COVER[IN_FNAME] THEN DB_DATA.ROI_COVER[IN_FNAME]=TROI
  ENDIF
  
  ;------------------------------------------
  ; DEFINE ARRAY TO HOLD CS RHO
  
  CS_RHO = FLTARR(NB_PIX, NB_BANDS + 1)

  ;------------------------------------------
  ; RETRIEVE VIEWING GEOMETRIES
  
  IF KEYWORD_SET(VERBOSE) THEN PRINT, 'VIIRS L1B INGEST: RETRIEVING VIEWING GEOMETRIES'
  TEMP = GET_VIIRS_VIEWING_GEOMETRIES(IFILES[IN_FNAME], VERBOSE=VERBOSE)
  TEMP_ANGLES = DIMITRI_ANGLE_CORRECTOR(TEMP.VZA, TEMP.VAA, TEMP.SZA, TEMP.SAA, VERBOSE=VERBOSE)
  
  IFILE_VIEW[0,IN_FNAME]=MEAN(TEMP_ANGLES.VZA[ROI_INDEX])
  IFILE_VIEW[1,IN_FNAME]=MEAN(TEMP_ANGLES.VAA[ROI_INDEX])
  IFILE_VIEW[2,IN_FNAME]=MEAN(TEMP_ANGLES.SZA[ROI_INDEX])
  IFILE_VIEW[3,IN_FNAME]=MEAN(TEMP_ANGLES.SAA[ROI_INDEX])
  TEMP_SZA = TEMP_ANGLES.SZA
  
  TEMP=0
  TEMP_ANGLES=0

  ;----------------------------------------
  ; SET AUX INFORMATION AS MISSING
  
  IFILE_AUX[*,IN_FNAME] = BADVAL
  
  ;---------------------------------------
  ; AVERAGE 750M TOA_REF OVER ROI
  
  IF KEYWORD_SET(VERBOSE) THEN PRINT, 'VIIRS L1B INGEST: AVERAGING  REFLECTANCES'
  FOR IN_BAND = 0, NB_BANDS - 6 DO BEGIN ; 11 reflective bands
    TOA_REF_TEMP = GET_VIIRS_L1B_REFLECTANCE(IFILES[IN_FNAME], IN_BAND)
    TOA_REF_TEMP = TOA_REF_TEMP/COS(TEMP_SZA*!DTOR)
    
    VALID     = WHERE(TOA_REF_TEMP(ROI_INDEX) GT 0.0 AND TOA_REF_TEMP(ROI_INDEX) LT 5.0,COUNTV)
    IF COUNTV EQ 0 THEN CONTINUE
    NON_VALID = WHERE(TOA_REF_TEMP(ROI_INDEX) LT 0.0 OR TOA_REF_TEMP(ROI_INDEX) GE 5.0,COUNTN)
    IF COUNTN GT 0 THEN TOA_REF_TEMP(ROI_INDEX[NON_VALID]) = MEAN(TOA_REF_TEMP(ROI_INDEX[VALID]))
    
    CS_RHO[*, IN_BAND] = TOA_REF_TEMP(ROI_INDEX)
    ROI_AVG_TOA_REF(IN_BAND, IN_FNAME) = MEAN(TOA_REF_TEMP(ROI_INDEX[valid]))
    ROI_STD_TOA_REF(IN_BAND, IN_FNAME) = STDDEV(TOA_REF_TEMP(ROI_INDEX[valid]))
    NCDF_OUT.VAR_PIX[IN_BAND, IN_FNAME, 0] = COUNTV
  ENDFOR
  
  
  ;----------------------------------
  ; GET ADDITIONAL EMISSIVE BAND ;; TODO ;; COMEBACK
  
  ; TEMP_REF            = GET_VIIRS_L1B_EMISSIVE(IFILES[IN_FNAME],11)
  ; TEMP_BTEMP          = CONVERT_EMISSIVE_TO_BTEMP(TEMP_REF(ROI_INDEX),11)
  ; CS_RHO[*,NB_BANDS]  = TEMP_BTEMP  
  
  ;----------------------------------
  ; APPLY CLOUD SCREENING
  
  CS_VIIRS = DIMITRI_CLOUD_SCREENING(SENSOR, AQA_SITE_TYPE, CS_RHO, 0, 'LCCA', VERBOSE=VERBOSE)
  IF CS_VIIRS[0] GT -1.0 THEN DB_DATA.AUTO_CS[IN_FNAME] = DOUBLE(CS_VIIRS[0])
  
  ;-----------------------------------------
  ; STORE DATA IN NETCDF STRUCTURE
  ; TODO ;; AUX DATA NEED TO GO HERE TOO
  
  NCDF_OUT.VAR_VZA[0,IN_FNAME]      = IFILE_VIEW[0,IN_FNAME]
  NCDF_OUT.VAR_VAA[0,IN_FNAME]      = IFILE_VIEW[1,IN_FNAME]
  NCDF_OUT.VAR_SZA[0,IN_FNAME]      = IFILE_VIEW[2,IN_FNAME]
  NCDF_OUT.VAR_SAA[0,IN_FNAME]      = IFILE_VIEW[3,IN_FNAME]
  NCDF_OUT.VAR_RHOMU[*,IN_FNAME,0]  = ROI_AVG_TOA_REF(*,IN_FNAME)
  NCDF_OUT.VAR_RHOSD[*,IN_FNAME,0]  = ROI_STD_TOA_REF(*,IN_FNAME)
  NCDF_OUT.VAR_CLOUD_AUT[IN_FNAME]  = DB_DATA.AUTO_CS[IN_FNAME]
  NCDF_OUT.VAR_CLOUD_MAN[IN_FNAME]  = -1
  NCDF_OUT.VAR_ROI[IN_FNAME]        = DB_DATA.ROI_COVER[IN_FNAME]
  
  NO_ROI:; IF ROI IS NOT WITHIN THE PRODUCT OR THERE ARE TOO FEW PIXELS
  IF KEYWORD_SET(VERBOSE) THEN PRINT, 'VIIRS L1B INGEST: END OF LOOP ON PRODUCT'
ENDFOR; END OF FILE ANALYSIS

;------------------------------------
; AMEND/SAVE DATA TO SAV FILE

IF KEYWORD_SET(VERBOSE) THEN PRINT, 'VIIRS L1B INGEST: DEFINING OUTPUT ARRAY'
NUM_NON_REFS = 5 + 12
NB_COLS = NUM_NON_REFS + 2 * (NB_BANDS)
SENSOR_L1B_REF          = DBLARR(NB_COLS, NB_FILES)
IF NB_FILES EQ 1 THEN SENSOR_L1B_REF = REFORM(SENSOR_L1B_REF, NB_COLS, NB_FILES)
SENSOR_L1B_REF[0,*]     = IFILE_DATE[4,*]
SENSOR_L1B_REF[1:4,*]   = IFILE_VIEW[*,*]
SENSOR_L1B_REF[5:16,*]  = IFILE_AUX[*,*]  ;;THIS IS GOING TO CRASH
SENSOR_L1B_REF[NUM_NON_REFS:NUM_NON_REFS + NB_BANDS - 1, *]  = ROI_AVG_TOA_REF[*,*]
SENSOR_L1B_REF[NUM_NON_REFS + NB_BANDS:NB_COLS - 1, *] = ROI_STD_TOA_REF[*,*]

IF KEYWORD_SET(VERBOSE) THEN PRINT, 'VIIRS L1B INGEST: AMMENDING DATA TO OUTPUT SAV FILE'
TEMP = FILE_INFO(OUTPUT_SAV)
IF TEMP.EXISTS EQ 1 THEN BEGIN
  TEMP_NEW = SENSOR_L1B_REF
  IF N_ELEMENTS(TEMP_NEW) EQ NB_COLS THEN TEMP_NEW = REFORM(TEMP_NEW, NB_COLS,NB_FILES)
  RESTORE,OUTPUT_SAV
  TEMP_OLD = SENSOR_L1B_REF
  IF N_ELEMENTS(TEMP_OLD) EQ NB_COLS THEN TEMP_OLD = REFORM(TEMP_OLD, NB_COLS, NB_FILES)
  RES_DIMS = SIZE(TEMP_OLD)
  
  SENSOR_L1B_REF = MAKE_ARRAY(NB_COLS,RES_DIMS[2] + NB_FILES, /DOUBLE)
  SENSOR_L1B_REF[*, 0:RES_DIMS[2] - 1] = TEMP_OLD
  SENSOR_L1B_REF[*, RES_DIMS[2]:RES_DIMS[2] + NB_FILES - 1] = TEMP_NEW
  
ENDIF

RES = SORT(SENSOR_L1B_REF[0, *])
SENSOR_L1B_REF = SENSOR_L1B_REF[*, RES]
SAVE, SENSOR_L1B_REF, FILENAME = OUTPUT_SAV

;------------------------------------
; GENERATE PLOTS WITH NEW TIME SERIES DATA

RES = GET_VIIRS_TIMESERIES_PLOTS(OUTPUT_SAV, COLOUR_TABLE=COLOUR_TABLE, PLOT_XSIZE=PLOT_XSIZE, PLOT_YSIZE=PLOT_YSIZE, VERBOSE=VERBOSE)

;------------------------------------
; SAVE DATA TO NETCDF FILE

RES = DIMITRI_INTERFACE_EXTRACT_TOA_NCDF(NCDF_OUT, NCDF_FILENAME)

;------------------------------------
; AMEND DATA TO DATABASE

IF KEYWORD_SET(VERBOSE) THEN PRINT, 'VIIRS L1B INGEST: SENDING DATA TO UPDATE DATABASE'
RES = UPDATE_DIMITRI_DATABASE(DB_DATA, /SORT_DB, VERBOSE=VERBOSE)

RETURN,1
END