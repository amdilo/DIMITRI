;-----------------------------------------
; NAME:
;    VALID_RPV_BRDF_GEOMETRY
; -------------------------
; PURPOSE:
; THIS ROUTINE TEST THE INPUT GEOMETRY TO FIND OUT IF IT IS WITHIN THE GEOMETRIES USED FOR THE INVERSION OF THE MERIS RPV BRDF MODEL
; 
; -------------------------
; CALLING SEQUENCE:
;      RES =VALID_RPV_BRDF_GEOMETRY(VZA, VAA, SZA, SAA, MAX_ANGULAR_DISTANCE, SITE,  VERBOSE=VERBOSE)
;      
; -------------------------
; INPUT:
; - VZA, VAA, SZA, SAA: SCALARS OR VECTORS
; - MAX_ANGULAR_DISTANCE: A SCALAR IN DEGREE
; - SITE: SITE NAME
;
; --------------------------------
; KEYWARDS:
; - /VERBOSE : PRINT RESULTS OF INVESTIGATION
;
; --------------------------------
; OUTPUT:
; A VECTOR FO THE SAME SIZE A VZA, VAA, SZA, SAA. IT CONTAINS -1 FOR RECIPROCAL GEOMETRY MATCH, 0 IF THERE IS NO MATCH WITHIN THE MAX_ANGULAR_DISTANCE AND 1 IF THE GEOMETRICAL MATCH IS AN IDENTICAL GEOMETRY
; 
; -------------------------
; EXAMPLE:
; 
; -------------------------
; TROUBLE SHOOTING:
;
; -------------------------
; MODIFICATION HISTORY:
;        28 JAN 2013  - M BOUVET    - FIRST PROTOTYPE OF THE ROUTINE
;        15 JAN 2015  - B ALHAMMOUD - FIRST IMPLEMENTATION TO DIMITRI-V3.1A
;
; VALIDATION HISTORY:
;        21 JAN 2015 -  B ALHAMMOUD - LINUX 64-BIT MACHINE IDL 8.2, NOMINAL COMPILATION AND OPERATION.
;                                  TESTED FOR PARASOL OVER LIBYA4
;
; -------------------------

FUNCTION VALID_RPV_BRDF_GEOMETRY, VZA, VAA, SZA, SAA, MAX_ANGULAR_DISTANCE, SITE,  VERBOSE=VERBOSE

;-----------------------------------------
; DEFINE CURRENT FUNCTION NAME

  FCT_NAME  = 'valid_RPV_BRDF_geometry'

;-----------------------------------------
; DEFINE INPUT/OUTPUT FILES AND DIRECTORIES

  IF KEYWORD_SET(VERBOSE) THEN PRINT,FCT_NAME+': DEFINING INPUT/OUTPUT FILES'
  SITE_FILE  = GET_DIMITRI_LOCATION('SITE_DATA')
  DB_FILE    = GET_DIMITRI_LOCATION('DATABASE')
  MAIN_DIRC  = GET_DIMITRI_LOCATION('DIMITRI')
 
;-----------------------------------------
; FIRST WE COMPUTE THE DELTA PHI
DPHI=(VAA-SAA)
DPHI=ABS(DPHI) ; WE ASSUME SYMMETRY WRT PRINCIPAL PLANE
DPHI=DPHI MOD 360
DPHI=(FLOOR(DPHI/180))*180.+((-1.)^(FLOOR(DPHI/180.)))*(DPHI MOD 180)


; READ .SAV THAT CONTAINS THE SIMULATED MERIS DATA (FOR BAND 1) AND THEIR ACQUISITION GEOMETRY
RESTORE, FILENAME=GET_DIMITRI_LOCATION('PICS_BRDF_DATA')+SITE+'_Inversion_statistics_MERIS_Band_1_full_RSR.sav'  ;, VERBOSE=VERBOSE

VZA_REF=FILTERED_REF_SENSOR[1,*]
VAA_REF=FILTERED_REF_SENSOR[2,*]
SZA_REF=FILTERED_REF_SENSOR[3,*]
SAA_REF=FILTERED_REF_SENSOR[4,*]
DPHI_REF=VAA_REF-SAA_REF
DPHI_REF=ABS(DPHI_REF) ; WE ASSUME SYMMETRY WRT PRINCIPAL PLANE
DPHI_REF=DPHI_REF MOD 360
DPHI_REF=(FLOOR(DPHI_REF/180))*180.+((-1.)^(FLOOR(DPHI_REF/180.)))*(DPHI_REF MOD 180)



N_ACQUISITIONS=N_ELEMENTS(VZA)

; THE OUTPUT FLAG WILL GET THE VALUE 0 IF NO MATCH FOUND WITHIN MAX_ANGULAR_DISTANCE, 1 IF ITS IN IDENTICAL CONFIGURATION AND -1 IN RECIPROCAL
OUTPUT_FLAG=FLTARR(N_ELEMENTS(VZA))

FOR I_ACQUISITION=0, N_ACQUISITIONS-1 DO BEGIN
  ; COMPUTE THE ANGULAR DISTANCE TO THE MERIS REFERENCE DATASET USED FOR THE BRDF INVERSION
  DISTANCE_IDENTICAL_CONFIGS=ACOS(COS(VZA[I_ACQUISITION]*!PI/180.)*COS(VZA_REF*!PI/180.)+SIN(VZA[I_ACQUISITION]*!PI/180.)*SIN(VZA_REF*!PI/180.)*COS((DPHI[I_ACQUISITION]-DPHI_REF)*!PI/180.))
  DISTANCE_IDENTICAL_CONFIGS=DISTANCE_IDENTICAL_CONFIGS+ACOS(COS(SZA[I_ACQUISITION]*!PI/180.)*COS(SZA_REF*!PI/180.)+SIN(SZA[I_ACQUISITION]*!PI/180.)*SIN(SZA_REF*!PI/180.))
  DISTANCE_IDENTICAL_CONFIGS=DISTANCE_IDENTICAL_CONFIGS*180./!PI
  
  DISTANCE_RECIPROCAL_CONFIGS=ACOS(COS(VZA[I_ACQUISITION]*!PI/180.)*COS(SZA_REF*!PI/180.)+SIN(VZA[I_ACQUISITION]*!PI/180.)*SIN(SZA_REF*!PI/180.))
  DISTANCE_RECIPROCAL_CONFIGS=DISTANCE_RECIPROCAL_CONFIGS+ACOS(COS(SZA[I_ACQUISITION]*!PI/180.)*COS(VZA_REF*!PI/180.)+SIN(SZA[I_ACQUISITION]*!PI/180.)*SIN(VZA_REF*!PI/180.)*COS((DPHI[I_ACQUISITION]-DPHI_REF)*!PI/180.))
  DISTANCE_RECIPROCAL_CONFIGS=DISTANCE_RECIPROCAL_CONFIGS*180./!PI
  
  MIN_DISTANCE_IDENTICAL=MIN(DISTANCE_IDENTICAL_CONFIGS, INDEX_MIN_IDENTICAL)
  MIN_DISTANCE_RECIPROCAL=MIN(DISTANCE_RECIPROCAL_CONFIGS, INDEX_MIN_RECIPROCAL)
  
  MIN_OVERALL=MIN([MIN_DISTANCE_IDENTICAL, MIN_DISTANCE_RECIPROCAL], CONFIG_FLAG)
  
  IF MIN_OVERALL LT MAX_ANGULAR_DISTANCE THEN IF CONFIG_FLAG EQ 0 THEN OUTPUT_FLAG[I_ACQUISITION]=1
  IF MIN_OVERALL LT MAX_ANGULAR_DISTANCE THEN IF CONFIG_FLAG EQ 1 THEN OUTPUT_FLAG[I_ACQUISITION]=-1
  
  IF KEYWORD_SET(VERBOSE) THEN BEGIN
    PRINT, 'Looking for match to ', VZA[I_ACQUISITION], VAA[I_ACQUISITION], SZA[I_ACQUISITION], SAA[I_ACQUISITION]
    PRINT, 'Closest identical at', MIN_DISTANCE_IDENTICAL, ' degrees:'
    PRINT, FILTERED_REF_SENSOR[1:4,INDEX_MIN_IDENTICAL]
    PRINT, 'Closest reciprocal at',  MIN_DISTANCE_RECIPROCAL, ' degrees:'
    PRINT, FILTERED_REF_SENSOR[1:4,INDEX_MIN_RECIPROCAL]
    if OUTPUT_FLAG[I_ACQUISITION] eq  0 then PRINT, 'Too far...'
    if OUTPUT_FLAG[I_ACQUISITION] eq  1 then PRINT, 'Choosing identical config...'
    if OUTPUT_FLAG[I_ACQUISITION] eq -1 then PRINT, 'Choosing reciprocal config...'
    PRINT, ' '
  ENDIF
  
ENDFOR
  
RETURN, OUTPUT_FLAG
END
