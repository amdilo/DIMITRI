;**************************************************************************************
;**************************************************************************************
;*
;* NAME:
;*      DIMITRI_INTERFACE_SUNGLINT_MAG       
;* 
;* PURPOSE:
;*      MAIN SUNGLINT SENSOR TO SIMULATION COMPARISON ROUTINE 
;* 
;* CALLING SEQUENCE:
;*      RES = DIMITRI_INTERFACE_SUNGLINT_MAG(SITE_NAME,SENSOR,PROC_VERSION)      
;* 
;* INPUTS:
;*      SITE_NAME = A STRING CONTAINING THE NAME OF THE REGION TO BE USED
;*      SENSOR = A STRING CONTAINING THE NAME OF THE SENSOR TO BE USED
;*      PROC_VERSION = A STRING CONTAINING THE NAME OF THE PROCESSING_VERSION TO BE USED
;*
;* KEYWORDS:
;*      ALL      - SET TO SEARCH FOR ALL DIMITRI PRODUCTS
;*      YEAR     - A STRING OF THE YEAR TO BE INGESTED (E.G. '2002')
;*      VERBOSE  - PROCESSING STATUS OUTPUTS
;*
;* OUTPUTS:
;*      STATUS   - 1: NOMINAL, (-1): ERROR, 0: NO PRODUCTS FOUND
;*
;* COMMON BLOCKS:
;*      NONE
;*
;* MODIFICATION HISTORY:
;*        05 MAY 2014 - PML / MAGELLIUM - CREATION
;*        26 FEB 2015 - NCG / MAGELLIUM - UPDATE FOR DIMITRI V4
;*
;* VALIDATION HISTORY:
;*        26 MAY 2014 - PML / MAGELLIUM - WINDOWS 64-BIT MACHINE IDL 8.2.3 : COMPILATION AND CALLING SUCCESSFUL
;*        20 JAN 2015 - NCG / MAGELLIUM - WINDOWS 64BIT MACHINE IDL 8.0: COMPILATION AND OPERATION SUCCESSFUL 
;*      30 MAR 2015 - NCG / MAGELLIUM      - WINDOWS 64BIT MACHINE IDL 8.0: COMPILATION AND OPERATION SUCCESSFUL (DIMITRI V4.0) 
;*
;**************************************************************************************
;**************************************************************************************

FUNCTION SUNGLINT_COMMON_PROCESS, NUM_DIR, SENSOR_CONFIG, SUNGLINT_STRUCT, SUNGLINT_LUT_FILE_STRUCT, SMAC_FILE_STRUCT, NCDF_CALIB_STRUCT, VERBOSE=VERBOSE

  FCT_NAME = 'SUNGLINT_COMMON_PROCESS'
  
  DEBUG_MODE = 0			; SET TO 1 IF WANT TO DEBUG THIS PROCEDURE
  
  STATUS_OK = GET_DIMITRI_LOCATION('STATUS_OK')
  STATUS_ERROR = GET_DIMITRI_LOCATION('STATUS_ERROR')
          
	; CALIBRATION VALUES FOR SUNGLINT CALIBRATION PROCESS
	MIN_PIXEL_NB_CALIB_PROCESS=GET_DIMITRI_LOCATION('MIN_PIXEL_NB_CALIB_PROCESS')
	MAX_WS_SG_CALIBRATION=GET_DIMITRI_LOCATION('MAX_WS_SG_CALIBRATION')
	MIN_NIR_SG_CALIBRATION=GET_DIMITRI_LOCATION('MIN_NIR_SG_CALIBRATION')
	MAX_THETA_N_SG_PROCESS=GET_DIMITRI_LOCATION('MAX_THETA_N_SG_PROCESS')
	PRESSURE_CSTE=GET_DIMITRI_LOCATION('PRESSURE_CSTE')
	MISSING_VALUE_FLT = FLOAT(GET_DIMITRI_LOCATION('NCDF_MISSING_VALUE'))

	IF KEYWORD_SET(VERBOSE) THEN BEGIN
		PRINT, ' THRESHOLDS:'
		PRINT, '   MIN_PIXEL_NB_CALIB_PROCESS = ' + STRTRIM(STRING(MIN_PIXEL_NB_CALIB_PROCESS),2)
		PRINT, '   MAX_WS_SG_CALIBRATION = ' + STRTRIM(STRING(MAX_WS_SG_CALIBRATION),2)
		PRINT, '   MIN_NIR_SG_CALIBRATION = ' + STRTRIM(STRING(MIN_NIR_SG_CALIBRATION),2)
		PRINT, '   MAX_THETA_N_SG_PROCESS = ' + STRTRIM(STRING(MAX_THETA_N_SG_PROCESS),2)          
	ENDIF
          
	;----------------------
	IF NUM_DIR+1 LT 10 THEN DIR_ID = 'DIR0' + STRTRIM(STRING(NUM_DIR+1),2) $
										 ELSE DIR_ID = 'DIR' + STRTRIM(STRING(NUM_DIR+1),2)

	;----------------------
	; CHECK COUNT_CS_CLEAR_PIX 

	; IDENTIFY AND SELECT CLEAR PIXELS ACCORDING CLOUD SCREENING MASK
	INDX_CS_MASK_CLEAR = WHERE(SUNGLINT_STRUCT.CLOUD_MASK EQ 0, COUNT_CS_CLEAR_PIX)

	IF COUNT_CS_CLEAR_PIX LT MIN_PIXEL_NB_CALIB_PROCESS THEN BEGIN
		IF KEYWORD_SET(VERBOSE) THEN BEGIN
			PRINT, ' NB_CLEAR_PIX = ' + STRTRIM(STRING(COUNT_CS_CLEAR_PIX),1) + ' < MIN_PIXEL_NB_CALIB_PROCESS : DIRECTION SKIPPED'
		ENDIF 
		GOTO, END_COMMON
	ENDIF 

	NB_PIX = COUNT_CS_CLEAR_PIX

  VISR_BAND_IDX = WHERE( STRMATCH(SENSOR_CONFIG.BAND_LABEL_STD, 'VISR') EQ 1, COUNT)
  NIR_BAND_IDX = WHERE( STRMATCH(SENSOR_CONFIG.BAND_LABEL_STD, 'NIR') EQ 1, COUNT)
  IF COUNT EQ 0 THEN BEGIN
    IF KEYWORD_SET(VERBOSE) THEN PRINT, ': NO NIR SENSOR BAND IDENTIFIED >> RETURNING'
    RETURN, STATUS_ERROR
  ENDIF
  IF COUNT GT 1 THEN BEGIN
    IF KEYWORD_SET(VERBOSE) THEN PRINT, ': MORE THAN ONE NIR SENSOR BAND IDENTIFIED >> RETURNING'
    RETURN, STATUS_ERROR
  ENDIF  
  NIR_BAND_IDX = NIR_BAND_IDX[0]
  VISR_BAND_IDX = VISR_BAND_IDX[0]
  
	;----------------------
	; NIR BOTTOM LIMIT (NIR RTOA > 0.15) AND WIND SPEED LIMIT (WS < 5 m/s)
	; REMOVE WIND TEST AND ADD TEST THETA_S/V ANGLES GE 15Â° (LIMIT VALUE OF THE LUT FILE)
	; INDX_NIR_WS_VLD = WHERE((RTOA_NIR_CS GT MIN_NIR_SG_CALIBRATION) AND (WIND_SPEED LT MAX_WS_SG_CALIBRATION), COUNT_NIR_WS_VALID) 
	INDX_NIR_WS_VLD = WHERE(SUNGLINT_STRUCT.REFL_BAND[INDX_CS_MASK_CLEAR, NIR_BAND_IDX] GT MIN_NIR_SG_CALIBRATION $
													AND SUNGLINT_STRUCT.THETA_V[INDX_CS_MASK_CLEAR] GE 15 $
													AND SUNGLINT_STRUCT.THETA_S[INDX_CS_MASK_CLEAR] GE 15 $
;                          AND SUNGLINT_STRUCT.WIND_SPEED[INDX_CS_MASK_CLEAR] LT MAX_WS_SG_CALIBRATION $
													, COUNT_NIR_WS_VALID)
	IF COUNT_NIR_WS_VALID LT MIN_PIXEL_NB_CALIB_PROCESS THEN BEGIN
		IF KEYWORD_SET(VERBOSE) THEN BEGIN
			PRINT, ' NB_PIX VALID (ANGLE + NIR RTOA CONDITIONS VALUES) = ' + STRTRIM(STRING(COUNT_NIR_WS_VALID),1) + ' < ' + STRTRIM(STRING(MIN_PIXEL_NB_CALIB_PROCESS),1) + ' : FILE SKIPPED FROM SUNGLINT CALIBRATION'
		ENDIF
		GOTO, END_COMMON
	ENDIF

	; BUILD PIXEL INDEX INPUT TO NIR & WS RANGE VALID
	INDX_IN_2_NIRWS_VLD = INDX_CS_MASK_CLEAR(INDX_NIR_WS_VLD)

	; LIMIT VARIABLES TO NIR/WIND SPEED VALID RANGES
	LAT_VLD = SUNGLINT_STRUCT.LAT(INDX_IN_2_NIRWS_VLD)
	LON_VLD = SUNGLINT_STRUCT.LON(INDX_IN_2_NIRWS_VLD)
	THETA_S_VLD = SUNGLINT_STRUCT.THETA_S(INDX_IN_2_NIRWS_VLD)
	PHI_S_VLD   = SUNGLINT_STRUCT.PHI_S(INDX_IN_2_NIRWS_VLD)
	THETA_V_VLD = SUNGLINT_STRUCT.THETA_V(INDX_IN_2_NIRWS_VLD)
	PHI_V_VLD   = SUNGLINT_STRUCT.PHI_V(INDX_IN_2_NIRWS_VLD)
	WIND_SPEED_VLD  = SUNGLINT_STRUCT.WIND_SPEED(INDX_IN_2_NIRWS_VLD)
	WATERVAPOUR_VLD = SUNGLINT_STRUCT.WATERVAPOUR(INDX_IN_2_NIRWS_VLD) 
	OZONE_VLD       = SUNGLINT_STRUCT.OZONE(INDX_IN_2_NIRWS_VLD)

	DPHI_VLD = ABS(PHI_S_VLD - PHI_V_VLD)
	INDX_DPHI_INV=WHERE(DPHI_VLD GT 180, COUNT_DPHI_INV)
	IF COUNT_DPHI_INV GT 0 THEN DPHI_VLD(INDX_DPHI_INV) = 360 - DPHI_VLD(INDX_DPHI_INV)

	;----------------------
	; SET SUNGLINT LUT ESTIMATION MATRIX DIMENSIONS
	
	SUNGLINT_LUT_STRUCT = SUNGLINT_LUT_FILE_STRUCT.SUNGLINT_LUT_STRUCT
	
	TSI = SUNGLINT_LUT_STRUCT.THETA_S[UNIQ(SUNGLINT_LUT_STRUCT.THETA_S, SORT(SUNGLINT_LUT_STRUCT.THETA_S))]
	TVI = SUNGLINT_LUT_STRUCT.THETA_V[UNIQ(SUNGLINT_LUT_STRUCT.THETA_V, SORT(SUNGLINT_LUT_STRUCT.THETA_V))]
	DPI = SUNGLINT_LUT_STRUCT.DPHI[UNIQ(SUNGLINT_LUT_STRUCT.DPHI, SORT(SUNGLINT_LUT_STRUCT.DPHI))]
	WSI = SUNGLINT_LUT_STRUCT.WS[UNIQ(SUNGLINT_LUT_STRUCT.WS, SORT(SUNGLINT_LUT_STRUCT.WS))]

	ROR=LINSPACE(0,0.35,INC=0.05) ; roR= ref/tg

	;----------------------
	; SEARCH OF WIND SPEED WITH VISR BAND
			
	VISR_SMAC_COEFFS = SMAC_FILE_STRUCT.SMAC_COEFFS(*,VISR_BAND_IDX)
	TG_VISR = GET_SMAC_GT_VALUES(VISR_SMAC_COEFFS, THETA_S = THETA_S_VLD, THETA_V = THETA_V_VLD, $
		                           PRESSURE = PRESSURE_CSTE, OZONE = OZONE_VLD, WATERVAPOUR = WATERVAPOUR_VLD)

	RTOA_VISR_OBS = SUNGLINT_STRUCT.REFL_BAND[INDX_IN_2_NIRWS_VLD, VISR_BAND_IDX]
  RTOA_TG_RATIO_VISR = RTOA_VISR_OBS / TG_VISR

	; WIND SPEED IS EVALUATED WITH INVERTED MODEL WS_INV[INDX_TS,INDX_TV,INDX_DPHI,INDX_RO]
  IDX_VISR_LUT = WHERE(SUNGLINT_LUT_FILE_STRUCT.IDX_VALID_LUT_FILE EQ VISR_BAND_IDX, COUNT)
  WS_ESTIM = INTERP4D(SUNGLINT_LUT_STRUCT.REFL_TOA[*,IDX_VISR_LUT], $
                        THETA_S_VLD, THETA_V_VLD, DPHI_VLD, RTOA_TG_RATIO_VISR, $ 
                        TSI, TVI, DPI, WSI, /INVERSE_Z)
         
	INDX_WS_VLD = WHERE(WS_ESTIM LT MAX_WS_SG_CALIBRATION, COUNT_WIND_VLD_RANGE)

	IF COUNT_WIND_VLD_RANGE LT MIN_PIXEL_NB_CALIB_PROCESS THEN BEGIN
		IF KEYWORD_SET(VERBOSE) THEN BEGIN
			PRINT, ' COUNT_WIND_VLD_RANGE = ' + STRTRIM(STRING(COUNT_WIND_VLD_RANGE),1) + ' < ' + STRTRIM(STRING(MIN_PIXEL_NB_CALIB_PROCESS),1) +' : FILE SKIPPED FOR SUNGLINT CALIBRATION'
		ENDIF
		GOTO, END_COMMON
	ENDIF
	
	IF DEBUG_MODE EQ 1 THEN BEGIN
		PRINT, ' DEBUG MODE - COUNT_WIND_VLD_RANGE = ', COUNT_WIND_VLD_RANGE
		PRINT, ' DEBUG MODE - MIN/MAX/MEAN = ', MIN(WS_ESTIM(INDX_WS_VLD)), '/', MAX(WS_ESTIM(INDX_WS_VLD)), '/', MEAN(WS_ESTIM(INDX_WS_VLD))
	ENDIF
	
	;----------------------
	; LIMIT INPUT DATA TO CLOUD, NIR, THETA_S/V AND WIND SPEED CRITERIA (VALID PIXELS)

  INDX_IN_ESTIM_VLD = INDX_IN_2_NIRWS_VLD(INDX_WS_VLD)
	
	WS_ESTIM_VLD= WS_ESTIM(INDX_WS_VLD)
	THETA_S_VLD = THETA_S_VLD(INDX_WS_VLD)
	THETA_V_VLD = THETA_V_VLD(INDX_WS_VLD)
	PHI_S_VLD   = PHI_S_VLD(INDX_WS_VLD)
	PHI_V_VLD   = PHI_V_VLD(INDX_WS_VLD)
	DPHI_VLD    = DPHI_VLD(INDX_WS_VLD)
	OZONE_VLD   = OZONE_VLD(INDX_WS_VLD)
	WATERVAPOUR_VLD = WATERVAPOUR_VLD(INDX_WS_VLD)
	WIND_SPEED_VLD  = WIND_SPEED_VLD(INDX_WS_VLD)
	PRESSURE_EXPORT = MAKE_ARRAY(N_ELEMENTS(INDX_WS_VLD),1,/FLOAT,VALUE=PRESSURE_CSTE)
	
	;-------------------
	; COMPLETE NCDF CALIBRATION STRUCTURE

	NB_PIX = N_ELEMENTS(INDX_IN_ESTIM_VLD)
	NCDF_CALIB_STRUCT.VARIABLES.CALIB_PIXEL_NUMBER(NUM_DIR) = NB_PIX
	NCDF_CALIB_STRUCT.VARIABLES.CALIB_VALID_INDEX(0:NB_PIX-1,NUM_DIR) = INDX_IN_ESTIM_VLD

	NCDF_CALIB_STRUCT.VARIABLES.WIND_SPEED_ESTIM(0:NB_PIX-1,NUM_DIR)   = WS_ESTIM_VLD
	
	;-------------------
	; LOOP ON SENSOR BANDS TO PROCESS

	NB_BANDS_SENSOR_PROCESS = N_ELEMENTS(SUNGLINT_STRUCT.IDX_BANDS_SENSOR_PROCESS)
	
	FOR NUM_BAND=0, NB_BANDS_SENSOR_PROCESS-1 DO BEGIN

		IDX_NUM_BAND = SUNGLINT_STRUCT.IDX_BANDS_SENSOR_PROCESS[NUM_BAND]

		IF IDX_NUM_BAND+1 LT 10 THEN BAND_ID = '0' + STRTRIM(STRING(IDX_NUM_BAND+1),2) $
												    ELSE BAND_ID = STRTRIM(STRING(IDX_NUM_BAND+1),2)

		WAVELENGTH = STRTRIM(STRING(SENSOR_CONFIG.BAND_WAVELENGTH[IDX_NUM_BAND]),2)

		IF KEYWORD_SET(VERBOSE) THEN PRINT, ' ----- ID : ' + STRTRIM(STRING(SENSOR_CONFIG.BAND_ID[IDX_NUM_BAND]),1) + $
																				', LABEL_STD : ' + SENSOR_CONFIG.BAND_LABEL_STD[IDX_NUM_BAND] + $
																				', REF_LABEL : ' + SENSOR_CONFIG.BAND_REF_LABEL[IDX_NUM_BAND] + $
																				', WAVELENGTH : ' + WAVELENGTH

		;-------------------
		; CHECK IF LUT AVAILABLE FOR CURRENT BAND
		IDX_LUT = WHERE(SUNGLINT_LUT_FILE_STRUCT.IDX_VALID_LUT_FILE EQ IDX_NUM_BAND, COUNT)
		IF COUNT NE 1 THEN BEGIN
			PRINT, FCT_NAME + ': WARNING, NO LUTS AVAILABLE FOR BAND ', BAND_ID, ' (WAVELENGTH=', WAVELENGTH, ') >> BAND SKIPPED'
			GOTO, NEXT_BAND
		ENDIF
	
		;-------------------
		; CHECK IF CURRENT BAND IS VISR BAND
		IF IDX_NUM_BAND EQ VISR_BAND_IDX THEN BEGIN

			IF DEBUG_MODE EQ 1 THEN BEGIN

				RTOA_TG_RATIO_VISR_VLD = RTOA_TG_RATIO_VISR(INDX_WS_VLD)
				VISR_ESTIM = INTERP4D(SUNGLINT_LUT_STRUCT.REFL_TOA[VISR_BAND_IDX], $
															THETA_S_VLD, THETA_V_VLD, DPHI_VLD, WS_ESTIM_VLD, $ 
															TSI, TVI, DPI, WSI)
				AK_VISR_ESTIM = RTOA_TG_RATIO_VISR_VLD / DOUBLE(VISR_ESTIM);

			ENDIF ELSE GOTO, NEXT_BAND

		ENDIF
	
		IF SMAC_FILE_STRUCT.SMAC_FILE_EXIST(IDX_NUM_BAND) EQ 0 THEN GOTO, NEXT_BAND

		RTOA_OBS = SUNGLINT_STRUCT.REFL_BAND[INDX_IN_ESTIM_VLD, IDX_NUM_BAND]

		INDX_NAN = WHERE(RTOA_OBS EQ MISSING_VALUE_FLT, COUNT_MISSING_VALUE, NCOMPLEMENT=COUNT_VALID, COMPLEMENT=IDX_VALID)
		IF COUNT_MISSING_VALUE GT 0 THEN RTOA_OBS(INDX_NAN)=!VALUES.F_NAN
		IF COUNT_VALID EQ 0 THEN BEGIN
		  PRINT, FCT_NAME + ': WARNING, NO VALID VALUE FOR BAND ', SENSOR_CONFIG.BAND_REF_LABEL[IDX_NUM_BAND], ', RESULTS SET AS MISSING VALUE FOR THIS BAND'
		  GOTO, NEXT_BAND
		ENDIF 

		TG = GET_SMAC_GT_VALUES(SMAC_FILE_STRUCT.SMAC_COEFFS(*,IDX_NUM_BAND), THETA_S = THETA_S_VLD, THETA_V = THETA_V_VLD, $
														PRESSURE = PRESSURE_CSTE, OZONE = OZONE_VLD, WATERVAPOUR = WATERVAPOUR_VLD)

		RTOA_TG_RATIO = RTOA_OBS / TG

    RTOA_TG_RATIO_ESTIM = INTERP4D(SUNGLINT_LUT_STRUCT.REFL_TOA(*,IDX_LUT), $
                          THETA_S_VLD, THETA_V_VLD, DPHI_VLD, WS_ESTIM_VLD, $
                          TSI, TVI, DPI, WSI)
               
		REF_TO_SIM_RATIO = RTOA_TG_RATIO / DOUBLE(RTOA_TG_RATIO_ESTIM);

		RTOA_OBS_VLD = RTOA_OBS(IDX_VALID)
		TG_VLD = TG(IDX_VALID)
		RTOA_TG_RATIO_VLD = RTOA_TG_RATIO(IDX_VALID)
		RTOA_TG_RATIO_ESTIM_VLD = RTOA_TG_RATIO_ESTIM(IDX_VALID)
		REF_TO_SIM_RATIO_VLD = REF_TO_SIM_RATIO(IDX_VALID)

		IF DEBUG_MODE EQ 1 THEN BEGIN
			PRINT, ' ------ BAND ID: ', NCDF_CALIB_STRUCT.VARIABLES.REFL_BAND_IDS[NUM_BAND], SENSOR_CONFIG.BAND_REF_LABEL[IDX_NUM_BAND]
			PRINT, ' DEBUG MODE - SMAC_COEFFS = ', SMAC_FILE_STRUCT.SMAC_COEFFS(*,IDX_NUM_BAND)
			PRINT, ' DEBUG MODE - MIN/MAX/MEAN(RAYLEIGH_LUT_STRUCT.REFL_TOA) = ', MIN(SUNGLINT_LUT_STRUCT.REFL_TOA(*,IDX_LUT)), '/', MAX(SUNGLINT_LUT_STRUCT.REFL_TOA(*,IDX_LUT)), '/', MEAN(SUNGLINT_LUT_STRUCT.REFL_TOA(*,IDX_LUT))
			PRINT, ' DEBUG MODE - MIN/MAX/MEAN(RTOA_OBS) = ', MIN(RTOA_OBS_VLD), '/', MAX(RTOA_OBS_VLD), '/', MEAN(RTOA_OBS_VLD)
			PRINT, ' DEBUG MODE - MIN/MAX/MEAN(TG) = ', MIN(TG_VLD), '/', MAX(TG_VLD), '/', MEAN(TG_VLD)
			PRINT, ' DEBUG MODE - MIN/MAX/MEAN(RTOA_TG_RATIO_ESTIM) = ', MIN(RTOA_TG_RATIO_ESTIM_VLD), '/', MAX(RTOA_TG_RATIO_ESTIM_VLD), '/', MEAN(RTOA_TG_RATIO_ESTIM_VLD)
			PRINT, ' DEBUG MODE - MIN/MAX/MEAN(REF_TO_SIM_RATIO) = ', MIN(REF_TO_SIM_RATIO_VLD), '/', MAX(REF_TO_SIM_RATIO_VLD), MEAN(REF_TO_SIM_RATIO_VLD)
			PRINT, ' ------ '
		ENDIF

    NB_DIRECTIONS = SENSOR_DIRECTION_INFO(SENSOR_CONFIG.SENSOR)
    NB_DIRECTIONS = NB_DIRECTIONS[0]
    IF NB_DIRECTIONS GT 1 THEN BEGIN
      OUT_FIG_FILENAME = SUNGLINT_STRUCT.OUT_FIG_BASE_FILENAME $
                                    + '_' + DIR_ID $
                                    + '_' + SENSOR_CONFIG.BAND_REF_LABEL[IDX_NUM_BAND] $
                                    + '_' + WAVELENGTH $
                                    + '.jpg'
    ENDIF ELSE BEGIN
      OUT_FIG_FILENAME = SUNGLINT_STRUCT.OUT_FIG_BASE_FILENAME $
                                    + '_' + SENSOR_CONFIG.BAND_REF_LABEL[IDX_NUM_BAND] $
                                    + '_' + WAVELENGTH $
                                    + '.jpg'
    ENDELSE                                

		RES = GET_SENSOR_TO_SIMULATION_PRODUCT_PLOTS(OUT_FIG_FILENAME, RTOA_TG_RATIO_VLD, RTOA_TG_RATIO_ESTIM_VLD, REF_TO_SIM_RATIO_VLD)

		;-------------------
		; COMPLETE NCDF CALIBRATION STRUCTURE

		NCDF_CALIB_STRUCT.VARIABLES.BAND_GAZ_TRANS(0:NB_PIX-1,NUM_DIR,NUM_BAND)        = TG
		NCDF_CALIB_STRUCT.VARIABLES.BAND_RHO_SIM(0:NB_PIX-1,NUM_DIR,NUM_BAND)          = RTOA_TG_RATIO_ESTIM
		;  NCDF_CALIB_STRUCT.VARIABLES.BAND_RHO_SIM_UNCERT(0:NB_PIX-1,NUM_DIR,NUM_BAND)   = BAND_RHO_SIM_UNCERT
		NCDF_CALIB_STRUCT.VARIABLES.BAND_REF_TO_SIM_RATIO(0:NB_PIX-1,NUM_DIR,NUM_BAND) = REF_TO_SIM_RATIO
		NCDF_CALIB_STRUCT.VARIABLES.BAND_VALID_INDEX(0:COUNT_VALID-1,NUM_DIR,NUM_BAND) = IDX_VALID

		NEXT_BAND:

	ENDFOR  ; END LOOP ON BANDS
	
  END_COMMON:
  
  RETURN, STATUS_OK

END


FUNCTION DIMITRI_INTERFACE_SUNGLINT_MAG,SITE_NAME,SENSOR,PROC_VERSION,ALL=ALL,YEAR=YEAR,VERBOSE=VERBOSE

  DEBUG_MODE=0       ; SET TO 1 IF WANT TO DEBUG THIS PROCEDURE
  
  FCT_NAME = 'DIMITRI_INTERFACE_SUNGLINT_MAG'
  
  METHOD = 'SUNGLINT_MAG'

  ;----------------------
  STATUS_OK = GET_DIMITRI_LOCATION('STATUS_OK')
  STATUS_ERROR = GET_DIMITRI_LOCATION('STATUS_ERROR')

  DL         = GET_DIMITRI_LOCATION('DL')
  DIMITRI_DB    = GET_DIMITRI_LOCATION('DATABASE',VERBOSE=VERBOSE)
  INPUT_FOLDER  = GET_DIMITRI_LOCATION('INGESTION_OUTPUT')
  OUTPUT_FOLDER = GET_DIMITRI_LOCATION('OUTPUT')
  MISSING_VALUE_FLT = FLOAT(GET_DIMITRI_LOCATION('NCDF_MISSING_VALUE'))
  MISSING_VALUE_LG  = LONG(GET_DIMITRI_LOCATION('NCDF_MISSING_VALUE'))
  
  MIN_NIR_SG_CS_PROCESS=GET_DIMITRI_LOCATION('MIN_NIR_SG_CS_PROCESS')
  MAX_THETA_R_SG_PROCESS=GET_DIMITRI_LOCATION('MAX_THETA_R_SG_PROCESS')
  MAX_THETA_N_SG_PROCESS=GET_DIMITRI_LOCATION('MAX_THETA_N_SG_PROCESS')  
  MAX_WAVELENGTH_VALUE_FOR_SUNGLINT=GET_DIMITRI_LOCATION('MAX_WAVELENGTH_VALUE_FOR_SUNGLINT')
  MIN_PIXEL_NB_CALIB_PROCESS=GET_DIMITRI_LOCATION('MIN_PIXEL_NB_CALIB_PROCESS')
  
  ;---------------------
  ; SEARCH FOR DATA PRODUCTS
  
  IF KEYWORD_SET(VERBOSE) THEN PRINT, FCT_NAME + ': RETRIEVING PRODUCT SEARCH FILTER'
  SEARCH_FOLDER = INPUT_FOLDER + DL + 'Site_' + SITE_NAME + DL + SENSOR + DL + 'Proc_' + PROC_VERSION + DL
  SEARCH_FILTER = SITE_NAME + '_' + SENSOR + '_' + PROC_VERSION + '_*.nc'

  ;----------------------
  ;  READ THE DIMITRI DATABASE 

  IF KEYWORD_SET(VERBOSE) THEN PRINT, FCT_NAME + ': CHECKING EXISTENCE OF DATABASE FILE'  
  DB_TEMPLATE = GET_DIMITRI_TEMPLATE(1,/TEMPLATE)   
  DB_TEMP = FILE_INFO(DIMITRI_DB)
  IF DB_TEMP.EXISTS EQ 0 THEN BEGIN
    DB_CHECK = 0
    IF KEYWORD_SET(VERBOSE) THEN PRINT, FCT_NAME + ': DATABASE FILE NOT FOUND'
  ENDIF ELSE BEGIN
    DB_CHECK = 1
    DB_DATA = READ_ASCII(DIMITRI_DB,TEMPLATE=DB_TEMPLATE)
  ENDELSE

  ;----------------------
  ; GET FILES FROM DATABASE
  
  IF KEYWORD_SET(ALL) THEN BEGIN
    ; WITHOUT YEAR FILTERING
    IDX_FILES = WHERE( STRCMP(DB_DATA.SENSOR,SENSOR,/FOLD_CASE) EQ 1 AND $
                       STRCMP(DB_DATA.SITE_NAME,SITE_NAME,/FOLD_CASE) EQ 1 AND $
                       STRCMP(DB_DATA.PROCESSING_VERSION,PROC_VERSION,/FOLD_CASE) EQ 1 AND $
                       DB_DATA.ROI_STATUS EQ 1, NB_FILES) 

  ENDIF ELSE BEGIN
    ; WITH YEAR FILTERING
    IDX_FILES = WHERE( STRCMP(DB_DATA.SENSOR,SENSOR,/FOLD_CASE) EQ 1 AND $
                       STRCMP(DB_DATA.SITE_NAME,SITE_NAME,/FOLD_CASE) EQ 1 AND $
                       STRCMP(DB_DATA.PROCESSING_VERSION,PROC_VERSION,/FOLD_CASE) EQ 1 AND $
                       DB_DATA.ROI_STATUS EQ 1 AND $
                       DB_DATA.YEAR EQ LONG(YEAR) , NB_FILES)        
  ENDELSE

  IF NB_FILES EQ 0 THEN BEGIN
    PRINT, FCT_NAME + ': NO PRODUCTS FOR CALIBRATION'
    RETURN, 0
  ENDIF
  
  ;----------------------
  ; GET INGESTION OUTPUT FILENAME FROM DATABASE
  
  I_FILES = SEARCH_FOLDER + DL + STRTRIM(STRING(DB_DATA.YEAR[IDX_FILES]),2) + DL + DB_DATA.L1_INGESTED_FILENAME[IDX_FILES]
  FILE_RESULT = FILE_SEARCH(I_FILES, COUNT=NB_FILES_SEARCH)
  
  IF NB_FILES_SEARCH NE NB_FILES THEN BEGIN
    IF KEYWORD_SET(VERBOSE) THEN PRINT, FCT_NAME + ': THE NUMBER OF INGESTION PRODUCTS ON DISK (', NB_FILES_SEARCH, $
                                                    ') DOES NOT MATCH THE NUMBER OF INGESTED PRODUCT IN THE DATABASE (', NB_FILES, ')'
    RETURN, STATUS_ERROR
  ENDIF

  ;----------------------
  ; GET BAND INFO STRUCTURE (NB_BANDS, BAND_ID, BAND_LABEL_STD, BAND_WAVELENGTH)
  
  CUR_SENSOR_BAND_INFOS = GET_SENSOR_BAND_INFO(SENSOR)
  NB_BANDS_SENSOR  = CUR_SENSOR_BAND_INFOS.NB_BAND
  NB_DIRECTIONS = SENSOR_DIRECTION_INFO(SENSOR)
  NB_DIRECTIONS = NB_DIRECTIONS[0]

  SENSOR_CONFIG = GET_SENSOR_BAND_CONFIG(SENSOR) ; GET USED CHANNELS / STD LABELS / SMAC FILENAME / LUT FILENAME

  ;-------------------
  ; COMPUTE SENSOR BAND WAVELENGTH TO PROCESS 
  
  SENSOR_BAND_WAVELENGTH = CUR_SENSOR_BAND_INFOS.BAND_WAVELENGTH
  IDX_BANDS_SENSOR_PROCESS = WHERE(SENSOR_BAND_WAVELENGTH LE MAX_WAVELENGTH_VALUE_FOR_SUNGLINT, NB_BANDS_SENSOR_PROCESS)

  IF NB_BANDS_SENSOR_PROCESS EQ 0 THEN BEGIN
    IF KEYWORD_SET(VERBOSE) THEN PRINT, ': NO SENSOR BAND WAVELENGTHS LOWER THAN SUNGLINT MAX WAVELENGTH >> RETURNING'
    RETURN, STATUS_ERROR
  ENDIF

  ;-------------------
  ; IDENTIFY VISR SENSOR BAND WAVELENGTH USED FOR WS ESTIMATION
  
  VISR_BAND_IDX = WHERE( STRMATCH(SENSOR_CONFIG.BAND_LABEL_STD, 'VISR') EQ 1, COUNT)
  IF COUNT EQ 0 THEN BEGIN
    IF KEYWORD_SET(VERBOSE) THEN PRINT, ': NO VISR SENSOR BAND IDENTIFIED >> RETURNING'
    RETURN, STATUS_ERROR
  ENDIF
  IF COUNT GT 1 THEN BEGIN
    IF KEYWORD_SET(VERBOSE) THEN PRINT, ': MORE THAN ONE VISR SENSOR BAND IDENTIFIED >> RETURNING'
    RETURN, STATUS_ERROR
  ENDIF  
  VISR_BAND_IDX = VISR_BAND_IDX[0]
  
  ;----------------------
  ; GET SMAC COEFFICIENTS
  ; SMAC_FILE_STRUCT = { SMAC_FILE_EXIST, SMAC_FILE_LABEL, SMAC_COEFFS }
  
  IF KEYWORD_SET(VERBOSE) THEN PRINT, FCT_NAME + ': READ SMAC COEFFICIENTS FOR SENSOR : ' + SENSOR
  STATUS = GET_SMAC_COEFFICIENTS(SENSOR, SMAC_FILE_STRUCT=SMAC_FILE_STRUCT, VERBOSE=VERBOSE)
  IF STATUS NE STATUS_OK THEN BEGIN
    IF KEYWORD_SET(VERBOSE) THEN PRINT, FCT_NAME + ': ERROR DURING SMAC COEFFICIENTS RETRIEVING >> RETURNING'
    RETURN, STATUS
  ENDIF

  IDX_SMAC_FILE_EXIST = WHERE(SMAC_FILE_STRUCT.SMAC_FILE_EXIST EQ 1, COUNT_SMAC_FILE)
  IF COUNT_SMAC_FILE EQ 0 THEN BEGIN
    IF KEYWORD_SET(VERBOSE) THEN PRINT, FCT_NAME + ': NO SMAC FILE AVAILABLE FOR SENSOR ', SENSOR, ' >> RETURNING'
    RETURN, STATUS_ERROR
  ENDIF
  IF SMAC_FILE_STRUCT.SMAC_FILE_EXIST(VISR_BAND_IDX) EQ 0 THEN BEGIN
    PRINT, FCT_NAME + ': ERROR, NO SMAC FILE AVAILABLE FOR VISR BAND FOR SENSOR ', SENSOR, ' >> RETURNING'
    RETURN, STATUS_ERROR
  ENDIF

  ;----------------------
  ; GET SUNGLINT LUTS COEFFICIENTS
  ;  SUNGLINT_LUT_FILE_STRUCT = { IDX_VALID_LUT_FILE: IDX_VALID_LUT_FILE, $
  ;                                 LUT_FILE_LABEL: LUT_FILE_LABEL, $
  ;                                 SUNGLINT_LUT_STRUCT: SUNGLINT_LUT_STRUCT }
  ;  SUNGLINT_LUT_STRUCT = { REFL_TOA: MAKE_ARRAY(NB_LINES, COUNT_VALID_LUT_FILE), $
  ;                                  THETA_S : MAKE_ARRAY(NB_LINES), $
  ;                                  THETA_V : MAKE_ARRAY(NB_LINES), $
  ;                                  DPHI    : MAKE_ARRAY(NB_LINES), $
  ;                                  WS      : MAKE_ARRAY(NB_LINES) }

  IF KEYWORD_SET(VERBOSE) THEN PRINT, FCT_NAME + ': READ SUNGLINT LUTS FOR SENSOR : ' + SENSOR
	STATUS = GET_SUNGLINT_LUTS(SENSOR, SUNGLINT_LUT_FILE_STRUCT=SUNGLINT_LUT_FILE_STRUCT, VERBOSE=VERBOSE)
	IF STATUS NE STATUS_OK THEN BEGIN
		IF KEYWORD_SET(VERBOSE) THEN BEGIN
			PRINT, FCT_NAME + ': ERROR DURING READING OF SUNGLINT LUT VALUES FOR SENSOR ' + SENSOR
		ENDIF
    RETURN, STATUS
	ENDIF
  IDX_LUT_VISR = WHERE(SUNGLINT_LUT_FILE_STRUCT.IDX_VALID_LUT_FILE EQ VISR_BAND_IDX, COUNT)   
  IF COUNT NE 1 THEN BEGIN
    PRINT, FCT_NAME + ': ERROR, NO LUT FILE AVAILABLE FOR VISR BAND FOR SENSOR ', SENSOR, ' >> RETURNING'
    RETURN, STATUS_ERROR
  ENDIF

  ;----------------------
  ; SET OUTPUT CALIB FOLDER
  
  CALDAT, SYSTIME(/UTC,/JULIAN),TMM,TDD,TYY,THR,TMN,TSS

  TYY = STRTRIM(STRING(TYY),2)
  TMM = TMM LT 10 ? '0'+STRTRIM(STRING(TMM),2) : STRTRIM(STRING(TMM),2)
  TDD = TDD LT 10 ? '0'+STRTRIM(STRING(TDD),2) : STRTRIM(STRING(TDD),2)
  THR = THR LT 10 ? '0'+STRTRIM(STRING(THR),2) : STRTRIM(STRING(THR),2)
  TMN = TMN LT 10 ? '0'+STRTRIM(STRING(TMN),2) : STRTRIM(STRING(TMN),2)
  TSS = TSS LT 10 ? '0'+STRTRIM(STRING(TSS,FORMAT='(I)'),2) : STRTRIM(STRING(TSS,FORMAT='(I)'),2)

  PROCESS_DATE = TYY+TMM+TDD+'-'+THR+TMN

  OUT_FILEPATH = OUTPUT_FOLDER + DL + METHOD + '_' + PROCESS_DATE + DL + 'Site_'+ SITE_NAME + DL + SENSOR + DL + 'Proc_' + PROC_VERSION + DL
  OUT_FILENAME_BASE =  SITE_NAME + '_' + SENSOR + '_' + PROC_VERSION + '_' + METHOD 
          
  ;----------------------
  ; LOOP OVER NCDF FILE IN PROCESSING DATASET

  FOR IDX_FILE=0, NB_FILES-1 DO BEGIN

    NCDF_FILENAME = FILE_RESULT[IDX_FILE]
    NCDF_INFOS = FILE_INFO(NCDF_FILENAME)
    
    IF NCDF_INFOS.EXISTS EQ 0 OR STRLEN(NCDF_FILENAME) EQ 0 THEN BEGIN
      IF KEYWORD_SET(VERBOSE) THEN PRINT,FCT_NAME + ': FILE ',NCDF_FILENAME,' IS MISSING, PLEASE CHECK YOUR INGESTION PROGRESS'
      GOTO, NEXT_IFILES
    ENDIF

    CUR_NCFILE = FILE_BASENAME(NCDF_FILENAME)
    
    ;----------------------
    ; GET ACQUISITION DATE FROM NCDF FILE
    CUR_NCDF_DATE = STRTRIM(GET_NCDF_GLOBAL_ATT(NCDF_FILENAME, 'ACQUISITION_DATE'))
    NCDF_YEAR_STR=STRMID(CUR_NCDF_DATE,0,4)
    NCDF_MONTH_STR=STRMID(CUR_NCDF_DATE,5,2)
    NCDF_DAY_STR=STRMID(CUR_NCDF_DATE,8,2)
    NCDF_HOURS_STR=STRMID(CUR_NCDF_DATE,11,2)
    NCDF_MINUTES_STR=STRMID(CUR_NCDF_DATE,14,2)
    
    NCDF_YEAR=UINT(NCDF_YEAR_STR)
    NCDF_MONTH=UINT(NCDF_MONTH_STR)
    NCDF_DAY=UINT(NCDF_DAY_STR)
    NCDF_HOURS=UINT(NCDF_HOURS_STR)
    NCDF_MINUTES=UINT(NCDF_MINUTES_STR)
    
    ACQUI_DATE = JULDAY(NCDF_MONTH,NCDF_DAY,NCDF_YEAR,NCDF_HOURS,NCDF_MINUTES,0)
    
    IF KEYWORD_SET(VERBOSE) THEN BEGIN
      PRINT, '[' + STRTRIM(STRING(IDX_FILE+1),1) + '/' + STRTRIM(STRING(NB_FILES),1) + '] > ' + FCT_NAME + ' ' + CUR_NCFILE + ' :: ' + CUR_NCDF_DATE
    ENDIF

    ;----------------------
    ; READ INPUT INGESTION FILE
    
    STATUS = NETCDFREAD_INGEST_OUTPUT( NCDF_FILENAME, NCDF_INGEST_STRUCT=NCDF_INGEST_STRUCT, VERBOSE=VERBOSE)
    IF STATUS NE STATUS_OK THEN BEGIN
      IF KEYWORD_SET(VERBOSE) THEN BEGIN
        PRINT, FCT_NAME + ': ERROR DURING ', FILE_BASENAME(NCDF_FILENAME),' FILE READING >> FILE SKIPPED'
      ENDIF
      GOTO, NEXT_IFILES
    ENDIF  
        
    IF NB_DIRECTIONS NE NCDF_INGEST_STRUCT.DIMENSIONS.VIEWDIR_NUMBER THEN BEGIN
      IF KEYWORD_SET(VERBOSE) THEN BEGIN
        PRINT, FCT_NAME + ': NUMBER OF VIEWING DIRECTIONS IN NCDF FILE (', NCDF_INGEST_STRUCT.DIMENSIONS.VIEWDIR_NUMBER, $
                              ') DOES NOT MATCH TO THE NUMBER OF SENSOR VIEWING DIRECTION (', NB_DIRECTIONS, ') >> FILE SKIPPED'
      ENDIF
      GOTO, NEXT_IFILES
    ENDIF
 
    ;----------------------
    ; COMPUTE MAXIMAL COUNT PIXEL CLEAR ACROSS DIRECTION FOR AN ESTIMATION OF VALID CALIBRATION PIXELS
    
    COUNT_CS_CLEAR_PIX_MAX = 0
    FOR NUM_DIR=0, NB_DIRECTIONS-1 DO BEGIN
      INDX_CS_MASK_CLEAR = WHERE(NCDF_INGEST_STRUCT.VARIABLES.AUTO_CS_2_MASK(*,NUM_DIR) EQ 0, COUNT_CS_CLEAR_PIX)
      COUNT_CS_CLEAR_PIX_MAX = MAX( [ COUNT_CS_CLEAR_PIX_MAX, COUNT_CS_CLEAR_PIX ] )
    ENDFOR
    
    IF COUNT_CS_CLEAR_PIX_MAX LT MIN_PIXEL_NB_CALIB_PROCESS THEN BEGIN
      IF KEYWORD_SET(VERBOSE) THEN BEGIN
        PRINT, ' NB_CLEAR_PIX = ' + STRTRIM(STRING(COUNT_CS_CLEAR_PIX_MAX),1) + ' < MIN_PIXEL_NB_CALIB_PROCESS : FILE SKIPPED '
      ENDIF 
      GOTO, NEXT_IFILES
    ENDIF 
 
    ;----------------------
    ; GET NCDF STRUCTURE FOR CALIBRATION OUTPUT
    
    CALIB_PIXEL_NUMBER = COUNT_CS_CLEAR_PIX_MAX
    
    NCDF_CALIB_STRUCT = GET_NCDF_CALIB_STRUCT(CALIB_PIXEL_NUMBER, NCDF_INGEST_STRUCT.DIMENSIONS.ROI_PIXEL_NUMBER, NB_DIRECTIONS, NB_BANDS_SENSOR_PROCESS, VERBOSE=VERBOSE)
    NCDF_CALIB_STRUCT.GLOBAL_ATT.CALIBRATION_METHOD = METHOD
    NCDF_CALIB_STRUCT.VARIABLES.REFL_BAND_IDS = IDX_BANDS_SENSOR_PROCESS
    
    ;----------------------
    ; COPY COMMON INFOS FROM INGESTION NCDF TO CALIBRATION NCDF
    STATUS = COPY_INGESTION_TO_CALIBRATION_NCDF_STRUCTURE(NCDF_INGEST_STRUCT=NCDF_INGEST_STRUCT, NCDF_CALIB_STRUCT=NCDF_CALIB_STRUCT, VERBOSE=VERBOSE)
    IF STATUS NE STATUS_OK THEN GOTO, END_PROCESS
    
		;----------------------
		; SET OUTPUT FIGURE FILENAME BASE
		OUT_FIG_BASE_FILENAME = OUT_FILEPATH + NCDF_YEAR_STR + DL + OUT_FILENAME_BASE + '_' + NCDF_YEAR_STR + NCDF_MONTH_STR + NCDF_DAY_STR $
																			+ '_' + NCDF_HOURS_STR + NCDF_MINUTES_STR

		;----------------------
    IF STRCMP(STRUPCASE(SENSOR), 'PARASOL') EQ 1 THEN BEGIN

	    ;----------------------
			; PARASOL SENSOR CASE
	    ;----------------------
			DIR_7 = 6
			IF NCDF_INGEST_STRUCT.VARIABLES.ROI_STATUS[DIR_7] NE 1 THEN BEGIN
				PRINT, FCT_NAME + ': NO DIRECTION 7 AVAILABLE FOR PARASOL PROCESSING'
				GOTO, NO_PARASOL_DIR_7
			ENDIF

			;-------------------
			; IDENTIFY NIR SENSOR BAND WAVELENGTH USED 3D TO 2D PROCESS

			NIR_BAND_IDX = WHERE( STRMATCH(SENSOR_CONFIG.BAND_LABEL_STD, 'NIR') EQ 1, COUNT)
			IF COUNT EQ 0 THEN BEGIN
				IF KEYWORD_SET(VERBOSE) THEN PRINT, ': NO NIR SENSOR BAND IDENTIFIED >> RETURNING'
				RETURN, STATUS_ERROR
			ENDIF
			IF COUNT GT 1 THEN BEGIN
				IF KEYWORD_SET(VERBOSE) THEN PRINT, ': MORE THAN ONE NIR SENSOR BAND IDENTIFIED >> RETURNING'
				RETURN, STATUS_ERROR
			ENDIF  

			; 3D TABLES INITIALIZATION
			NB_PTS = NCDF_INGEST_STRUCT.DIMENSIONS.ROI_PIXEL_NUMBER

			THETA_N_3D = MAKE_ARRAY(NB_PTS, NB_DIRECTIONS, /FLOAT, VALUE=MISSING_VALUE_FLT)
			THETA_R_3D = MAKE_ARRAY(NB_PTS, NB_DIRECTIONS, /FLOAT, VALUE=MISSING_VALUE_FLT)

			; 2D TABLES INITIALIZATION
			LAT = MAKE_ARRAY(NB_PTS, /FLOAT, VALUE=MISSING_VALUE_FLT)
      LON = MAKE_ARRAY(NB_PTS, /FLOAT, VALUE=MISSING_VALUE_FLT)
      THETA_S = MAKE_ARRAY(NB_PTS, /FLOAT, VALUE=MISSING_VALUE_FLT)
			PHI_S   = MAKE_ARRAY(NB_PTS, /FLOAT, VALUE=MISSING_VALUE_FLT)
			THETA_V = MAKE_ARRAY(NB_PTS, /FLOAT, VALUE=MISSING_VALUE_FLT)
			PHI_V   = MAKE_ARRAY(NB_PTS, /FLOAT, VALUE=MISSING_VALUE_FLT)
			REFL_BAND  = MAKE_ARRAY(NB_PTS, NB_BANDS_SENSOR, /FLOAT, VALUE=MISSING_VALUE_FLT)
			CLOUD_MASK = MAKE_ARRAY(NB_PTS, /FLOAT, VALUE=MISSING_VALUE_FLT)
			THETA_N = MAKE_ARRAY(NB_PTS, /FLOAT, VALUE=MISSING_VALUE_FLT)
			THETA_R = MAKE_ARRAY(NB_PTS, /FLOAT, VALUE=MISSING_VALUE_FLT)
			WIND_SPEED  = MAKE_ARRAY(NB_PTS, /FLOAT, VALUE=MISSING_VALUE_FLT)
			WATERVAPOUR = MAKE_ARRAY(NB_PTS, /FLOAT, VALUE=MISSING_VALUE_FLT)
			OZONE       = MAKE_ARRAY(NB_PTS, /FLOAT, VALUE=MISSING_VALUE_FLT)

			; LOOP ON THE VIEWING DIRECTION
			FOR NUM_DIR=0, NB_DIRECTIONS-1 DO BEGIN

				RES = GET_SUNGLINT_ANGLES( NCDF_INGEST_STRUCT.VARIABLES.SZA[*,NUM_DIR], $
																	 NCDF_INGEST_STRUCT.VARIABLES.VZA[*,NUM_DIR], $
																	 NCDF_INGEST_STRUCT.VARIABLES.SAA[*,NUM_DIR], $
																	 NCDF_INGEST_STRUCT.VARIABLES.VAA[*,NUM_DIR], $
																	 THETA_N=THETA_N, THETA_R=THETA_R)

				THETA_R_3D[*,NUM_DIR] = THETA_R
				THETA_N_3D[*,NUM_DIR] = THETA_N

			ENDFOR

			; 3D TO 2D PROCESSING
			DIR_SG = MAKE_ARRAY(NB_PTS, /LONG, VALUE=MISSING_VALUE_LG)
			FOR IDX_PT=0, NB_PTS-1 DO BEGIN
				IF THETA_N_3D[IDX_PT, DIR_7] GT 0 THEN BEGIN

					MAX_TN = MAX(NCDF_INGEST_STRUCT.VARIABLES.REFL_BAND[IDX_PT,*,NIR_BAND_IDX])
					IMAXTN = WHERE((NCDF_INGEST_STRUCT.VARIABLES.REFL_BAND[IDX_PT,*,NIR_BAND_IDX]) EQ MAX_TN)
					IMAXTN = IMAXTN[0]
					
					; STORE THE VIEWING DIRECTION OF THE POINT
					DIR_SG[IDX_PT] = IMAXTN
					; 3D TO 2D
          LAT[IDX_PT]        = NCDF_INGEST_STRUCT.VARIABLES.LAT[IDX_PT,IMAXTN]
          LON[IDX_PT]        = NCDF_INGEST_STRUCT.VARIABLES.LON[IDX_PT,IMAXTN]
					THETA_S[IDX_PT]    = NCDF_INGEST_STRUCT.VARIABLES.SZA[IDX_PT,IMAXTN]
					PHI_S[IDX_PT]      = NCDF_INGEST_STRUCT.VARIABLES.SAA[IDX_PT,IMAXTN]
					THETA_V[IDX_PT]    = NCDF_INGEST_STRUCT.VARIABLES.VZA[IDX_PT,IMAXTN]
					PHI_V[IDX_PT]      = NCDF_INGEST_STRUCT.VARIABLES.VAA[IDX_PT,IMAXTN]
					help, REFL_BAND[IDX_PT,*]
					help, NCDF_INGEST_STRUCT.VARIABLES.REFL_BAND[IDX_PT,IMAXTN,*]
					REFL_BAND[IDX_PT,*]= NCDF_INGEST_STRUCT.VARIABLES.REFL_BAND[IDX_PT,IMAXTN,*]
					CLOUD_MASK[IDX_PT] = NCDF_INGEST_STRUCT.VARIABLES.AUTO_CS_2_MASK[IDX_PT,IMAXTN]
					THETA_N[IDX_PT] 	 = THETA_N_3D[IDX_PT,IMAXTN]
					THETA_R[IDX_PT] 	 = THETA_R_3D[IDX_PT,IMAXTN]
					WIND_SPEED[IDX_PT] = NCDF_INGEST_STRUCT.VARIABLES.ERA_WIND_SPEED[IDX_PT,IMAXTN]
					WATERVAPOUR[IDX_PT]= NCDF_INGEST_STRUCT.VARIABLES.ERA_WATERVAPOUR[IDX_PT,IMAXTN]
					OZONE[IDX_PT]			 = NCDF_INGEST_STRUCT.VARIABLES.ERA_OZONE[IDX_PT,IMAXTN]
				ENDIF
			ENDFOR
			; FILTER OUT PIXEL WITH THETA_N >= 4 (NOT IN SUNGLINT) (MAX_THETA_N_SG_PROCESS VARIABLE)
			INDEX_IN_GLITTER = WHERE(THETA_N LT MAX_THETA_N_SG_PROCESS, NB_PIX_IN_GLITTER)
			IF NB_PIX_IN_GLITTER EQ 0 THEN GOTO, NO_PARASOL_DIR_7

			SUNGLINT_STRUCT = { LAT     : LAT(INDEX_IN_GLITTER), $
													LON     : LON(INDEX_IN_GLITTER), $
													THETA_S : THETA_S(INDEX_IN_GLITTER), $ ; SUN ZENITH ANGLE
													PHI_S   : PHI_S(INDEX_IN_GLITTER), $ ; SUN AZIMUTH ANGLE
													THETA_V : THETA_V(INDEX_IN_GLITTER), $ ; VIEWING ZENITH ANGLE
													PHI_V   : PHI_V(INDEX_IN_GLITTER), $ ; VIEWING AZIMUTH ANGLE
													THETA_N : THETA_N(INDEX_IN_GLITTER), $
													THETA_R : THETA_R(INDEX_IN_GLITTER), $
													CLOUD_MASK  : CLOUD_MASK(INDEX_IN_GLITTER)  , $
													REFL_BAND   : REFL_BAND[INDEX_IN_GLITTER,*], $
													WIND_SPEED  : WIND_SPEED(INDEX_IN_GLITTER), $
													WATERVAPOUR : WATERVAPOUR(INDEX_IN_GLITTER), $
													OZONE       : OZONE(INDEX_IN_GLITTER), $
													IDX_BANDS_SENSOR_PROCESS : IDX_BANDS_SENSOR_PROCESS, $
													OUT_FIG_BASE_FILENAME : OUT_FIG_BASE_FILENAME }
 
	    ;----------------------
			; SUNGLINT COMMON PROCESS LAUNCH
			NUM_DIR = 0
			STATUS = SUNGLINT_COMMON_PROCESS( NUM_DIR, SENSOR_CONFIG, SUNGLINT_STRUCT, SUNGLINT_LUT_FILE_STRUCT, SMAC_FILE_STRUCT, NCDF_CALIB_STRUCT, VERBOSE=VERBOSE)
      IF STATUS NE STATUS_OK THEN GOTO, END_PROCESS
      
      ;----------------------
	    ; MODIFY CALIB_VALID_INDEX VARIABLE TO TAKE INTO ACCOUNT FIRST FILTERING

      NB_PIX = NCDF_CALIB_STRUCT.VARIABLES.CALIB_PIXEL_NUMBER[0]

      CALIB_VALID_INDEX = NCDF_CALIB_STRUCT.VARIABLES.CALIB_VALID_INDEX[0:NB_PIX-1,0]    
      NCDF_CALIB_STRUCT.VARIABLES.CALIB_VALID_INDEX[0:NB_PIX-1,0] = INDEX_IN_GLITTER[CALIB_VALID_INDEX]  

	    ;----------------------
		  ; DUPLICATE VALUES AND FIGURES BETWEEN VIEWING DIRECTIONS
		  
			NCDF_CALIB_STRUCT.VARIABLES.CALIB_PIXEL_NUMBER[*] = NB_PIX

			; LOOP ON THE VIEWING DIRECTION
			FOR NUM_DIR=1, NB_DIRECTIONS-1 DO BEGIN			
				NCDF_CALIB_STRUCT.VARIABLES.CALIB_VALID_INDEX[0:NB_PIX-1,NUM_DIR]       = NCDF_CALIB_STRUCT.VARIABLES.CALIB_VALID_INDEX[0:NB_PIX-1,0]
				NCDF_CALIB_STRUCT.VARIABLES.WIND_SPEED_ESTIM[0:NB_PIX-1,NUM_DIR]        = NCDF_CALIB_STRUCT.VARIABLES.WIND_SPEED_ESTIM[0:NB_PIX-1,0]
				NCDF_CALIB_STRUCT.VARIABLES.BAND_GAZ_TRANS[0:NB_PIX-1,NUM_DIR,*]        = NCDF_CALIB_STRUCT.VARIABLES.BAND_GAZ_TRANS[0:NB_PIX-1,0,*]
				NCDF_CALIB_STRUCT.VARIABLES.BAND_RHO_SIM[0:NB_PIX-1,NUM_DIR,*]          = NCDF_CALIB_STRUCT.VARIABLES.BAND_RHO_SIM[0:NB_PIX-1,0,*]
;       NCDF_CALIB_STRUCT.VARIABLES.BAND_RHO_SIM_UNCERT[0:NB_PIX-1,NUM_DIR,*]   = NCDF_CALIB_STRUCT.VARIABLES.BAND_RHO_SIM_UNCERT[0:NB_PIX-1,0,*]
				NCDF_CALIB_STRUCT.VARIABLES.BAND_REF_TO_SIM_RATIO[0:NB_PIX-1,NUM_DIR,*] = NCDF_CALIB_STRUCT.VARIABLES.BAND_REF_TO_SIM_RATIO[0:NB_PIX-1,0,*]
				NCDF_CALIB_STRUCT.VARIABLES.BAND_VALID_INDEX[0:NB_PIX-1,NUM_DIR,*]      = NCDF_CALIB_STRUCT.VARIABLES.BAND_VALID_INDEX[0:NB_PIX-1,0,*]
			ENDFOR

			AT_LEAST_ONE_DIR = 1
			
			NO_PARASOL_DIR_7:

		ENDIF ELSE BEGIN
		
	    ;----------------------
			; OTHER SENSOR CASE
	    ;----------------------  
    
			;----------------------
			; LOOP OVER VIEWING DIRECTION
			
			AT_LEAST_ONE_DIR = 0

			FOR NUM_DIR=0, NB_DIRECTIONS-1 DO BEGIN

				IF NUM_DIR+1 LT 10 THEN DIR_ID = 'DIR0' + STRTRIM(STRING(NUM_DIR+1),2) $
													 ELSE DIR_ID = 'DIR' + STRTRIM(STRING(NUM_DIR+1),2)

				IF KEYWORD_SET(VERBOSE) THEN BEGIN
					PRINT, FCT_NAME + ': ----- PROCESS DIRECTION [' + DIR_ID + '/' + STRTRIM(STRING(NB_DIRECTIONS),1) + ']'
				ENDIF

				IF NCDF_INGEST_STRUCT.VARIABLES.ROI_STATUS[NUM_DIR] EQ 0 THEN BEGIN
					IF KEYWORD_SET(VERBOSE) THEN BEGIN
						PRINT, FCT_NAME + ': ROI STATUS WITH 0 VALUE >> DIRECTION SKIPPED'
					ENDIF
					GOTO, NEXT_DIR
				ENDIF

				;----------------------
				; GET VARIABLES FROM NCDF DATA STRUCTURE

				RES = GET_SUNGLINT_ANGLES( NCDF_INGEST_STRUCT.VARIABLES.SZA[*,NUM_DIR], $
																	 NCDF_INGEST_STRUCT.VARIABLES.VZA[*,NUM_DIR], $
																	 NCDF_INGEST_STRUCT.VARIABLES.SAA[*,NUM_DIR], $
																	 NCDF_INGEST_STRUCT.VARIABLES.VAA[*,NUM_DIR], $
																	 THETA_N=THETA_N, THETA_R=THETA_R)

 				SUNGLINT_STRUCT = { LAT     : NCDF_INGEST_STRUCT.VARIABLES.LAT(*,NUM_DIR), $
 														LON     : NCDF_INGEST_STRUCT.VARIABLES.LON(*,NUM_DIR), $
														THETA_S : NCDF_INGEST_STRUCT.VARIABLES.SZA(*,NUM_DIR), $ ; SUN ZENITH ANGLE
														PHI_S   : NCDF_INGEST_STRUCT.VARIABLES.SAA(*,NUM_DIR), $ ; SUN AZIMUTH ANGLE
														THETA_V : NCDF_INGEST_STRUCT.VARIABLES.VZA(*,NUM_DIR), $ ; VIEWING ZENITH ANGLE
														PHI_V   : NCDF_INGEST_STRUCT.VARIABLES.VAA(*,NUM_DIR), $ ; VIEWING AZIMUTH ANGLE
 														THETA_N : THETA_N, $
 														THETA_R : THETA_R, $
 														CLOUD_MASK  : NCDF_INGEST_STRUCT.VARIABLES.AUTO_CS_2_MASK(*,NUM_DIR), $
 														REFL_BAND   : REFORM(NCDF_INGEST_STRUCT.VARIABLES.REFL_BAND(*,NUM_DIR,*),NCDF_INGEST_STRUCT.DIMENSIONS.ROI_PIXEL_NUMBER,NB_BANDS_SENSOR), $
 														WIND_SPEED  : NCDF_INGEST_STRUCT.VARIABLES.ERA_WIND_SPEED(*,NUM_DIR), $
 														WATERVAPOUR : NCDF_INGEST_STRUCT.VARIABLES.ERA_WATERVAPOUR(*,NUM_DIR), $
 														OZONE       : NCDF_INGEST_STRUCT.VARIABLES.ERA_OZONE(*,NUM_DIR), $
 														IDX_BANDS_SENSOR_PROCESS : IDX_BANDS_SENSOR_PROCESS, $
													  OUT_FIG_BASE_FILENAME : OUT_FIG_BASE_FILENAME }
 
				;----------------------
			  ; SUNGLINT COMMON PROCESS LAUNCH
				STATUS = SUNGLINT_COMMON_PROCESS( NUM_DIR, SENSOR_CONFIG, SUNGLINT_STRUCT, SUNGLINT_LUT_FILE_STRUCT, SMAC_FILE_STRUCT, NCDF_CALIB_STRUCT, VERBOSE=VERBOSE)
				IF STATUS NE STATUS_OK THEN GOTO, END_PROCESS
				
				AT_LEAST_ONE_DIR = 1

      	NEXT_DIR:

			ENDFOR ; END LOOP OVER VIEWING DIRECTION
			
    ENDELSE ; END OTHER SENSOR CASE 
    
    ; CHECK IF AT LEAST ONE DIRECTION HAS BEEN PROCESSED 
    IF AT_LEAST_ONE_DIR EQ 1 THEN BEGIN
  		
  		;----------------------
  		; WRITE CALIBRATION OUTPUT
  
  		STATUS = NETCDFWRITE_CALIB_OUTPUT(PROCESS_DATE, NCDF_CALIB_STRUCT, NCDF_FILENAME=NCDF_FILENAME, VERBOSE=VERBOSE)
  		IF STATUS NE STATUS_OK THEN BEGIN
  			IF KEYWORD_SET(VERBOSE) THEN PRINT, FCT_NAME + ': ERROR DURING OUTPUT CALIBRATION WRITING >> RETURNING'    
  			RETURN, STATUS_ERROR
  		ENDIF
  		
    ENDIF ELSE IF KEYWORD_SET(VERBOSE) THEN PRINT, FCT_NAME + ': NO DIRECTION PROCESSED >> OUTPUT CALIBRATION NOT WRITTEN' 

		NEXT_IFILES:

  ENDFOR ; END LOOP ON FILES

  PRINT, FCT_NAME + ': ***** PROCESS COMPLETED SUCCESSFULLY *****'
  RETURN, STATUS_OK

  END_PROCESS:
  IF (STATUS NE STATUS_OK) AND (KEYWORD_SET(VERBOSE)) THEN PRINT, FCT_NAME + ': ERROR DURING PROCESSING'
  RETURN, STATUS_ERROR
  
END