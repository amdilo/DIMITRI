;**************************************************************************************
;**************************************************************************************
;*
;* NAME:
;*      NETCDFREAD_INTERPOL_AUXDATA       
;* 
;* PURPOSE:
;*		NETCDF FUNCTION TO READ AND INTERPOLATE AUXDATA FROM GLOBAL DATA (LON/LAT) :
;*		- CHECK FOR VALID INPUT PARAMETERS
;*		- OPEN THE NETCDF FILE
;*		- READ NETCDF VARIABLES AND CHECK FOR LON/LAT/TIME VARIABLES
;*		- FIND INDEXES AND FILTER OUT REQUIRED REGION
;*		- READ THE ATTRIBUTES INTO A STRING ARRAY
;*		- PERFORM DATA INTERPOLATION IF REQUIRED
;*    - CLOSE THE NETCDF FILE
;* 
;* CALLING SEQUENCE:
;*      RES = NETCDFREAD_INTERPOL_AUXDATA, NCDF_FILENAME, STATUS, INGEST_INFOS_STRUCT, ATTRIBUTES_STRUCT, REGION_STRUCT, DATA_STRUCT, NCDF_LON_VALUES, NCDF_LAT_VALUES, VERBOSE=VERBOSE
;* 
;* INPUTS:
;*      NCDF_FILENAME - NETCDF FILE TO READ
;*      STATUS        - STATUS OF THE PROCESS /  1: NO ERRORS REPORTED, (-1) OR 0: ERRORS DURING INGESTION  
;*      INGEST_INFOS_STRUCT - INFORMATION STRUCTURE TO READ (ROI DEFINITION(LON/LAT) / FIELDS OF DATA / DATE SLOT )
;*      LON / LAT     - LONGITUDE / LATITUDE VALUES 
;*
;* KEYWORDS:
;*      MONTH_EXTRACT  - DATE BASED ON MONTH TEMPORAL SAMPLING
;*      VERBOSE        - PROCESSING STATUS OUTPUTS
;*
;* OUTPUTS:
;*		  RES - INTERPOLATED AUX DATA
;*
;* COMMON BLOCKS:
;*      NONE
;*
;* MODIFICATION HISTORY:
;*      22 JAN 2015 - NCG / MAGELLIUM    - CREATION
;*
;* VALIDATION HISTORY:
;*      30 MAR 2015 - NCG / MAGELLIUM      - WINDOWS 64BIT MACHINE IDL 8.0: COMPILATION AND OPERATION SUCCESSFUL (DIMITRI V4.0) 
;*
;**************************************************************************************
;**************************************************************************************

FUNCTION NETCDFREAD_INTERPOL_AUXDATA, NCDF_FILENAME, STATUS, INGEST_INFOS_STRUCT, LON, LAT, MONTH_EXTRACT=MONTH_EXTRACT, VERBOSE=VERBOSE

	DEBUG_MODE = 0      ; SET TO 1 IF WANT TO DEBUG THIS PROCEDURE

	STATUS_OK = GET_DIMITRI_LOCATION('STATUS_OK')
	STATUS_ERROR = GET_DIMITRI_LOCATION('STATUS_ERROR')

	AUXDATA_BORDER_PIX_NB = GET_DIMITRI_LOCATION('AUXDATA_INTERP_BORDER')

	STATUS = STATUS_ERROR

	; GET AND PREPARE SITE COORDS
	NORTH_LAT = INGEST_INFOS_STRUCT.NORTH_LAT
	SOUTH_LAT = INGEST_INFOS_STRUCT.SOUTH_LAT
	EAST_LON = INGEST_INFOS_STRUCT.EAST_LON
	WEST_LON = INGEST_INFOS_STRUCT.WEST_LON

	IF EAST_LON LT 0 THEN  EAST_LON = 360 + EAST_LON 
	IF WEST_LON LT 0 THEN  WEST_LON = 360 + WEST_LON

	IF KEYWORD_SET(DEBUG_MODE) THEN BEGIN
		PRINT, 'DEBUG MODE - NORTH_LAT = ', NORTH_LAT, ' / SOUTH_LAT = ', SOUTH_LAT, ' / EAST_LON = ', EAST_LON, ' / WEST_LON = ', WEST_LON
	ENDIF

	;	OPEN THE NETCDF FILE
	FID = NCDF_OPEN(NCDF_FILENAME,/NOWRITE )
	IF FID EQ -1 THEN BEGIN
			PRINT, 'NETCDFREAD_INTERPOL_AUXDATA: NCDF FILE ' + NCDF_FILENAME + ' CAN NOT BE OPEN'
			RETURN, STATUS_ERROR
	ENDIF 

	;NCDF_CONTROL, FID, /ENDEF
	NCDF_CONTROL, FID, /VERBOSE

	; CHECK VARIABLES AVAILABILITY
	NCDF_LON_ID = NCDF_VARID(FID, INGEST_INFOS_STRUCT.NCDF_LON_NAME)
	NCDF_LAT_ID = NCDF_VARID(FID, INGEST_INFOS_STRUCT.NCDF_LAT_NAME)
	NCDF_TIME_ID = NCDF_VARID(FID, INGEST_INFOS_STRUCT.NCDF_TIME_NAME)

	IF (NCDF_LON_ID EQ -1) $
		OR (NCDF_LAT_ID EQ -1) $
		OR (NCDF_TIME_ID EQ -1) THEN BEGIN
			PRINT, 'NETCDFREAD_INTERPOL_AUXDATA: NCDF FILE ' + NCDF_FILENAME + ' : FIELD ' + INGEST_INFOS_STRUCT.NCDF_LON_NAME + $
									' OR ' + INGEST_INFOS_STRUCT.NCDF_LAT_NAME + $
									' OR ' + INGEST_INFOS_STRUCT.NCDF_TIME_NAME + 'DO NOT EXIST '
			NCDF_CLOSE, FID 
			RETURN, STATUS_ERROR  
	ENDIF

	NB_VAR = N_ELEMENTS(INGEST_INFOS_STRUCT.NCDF_VAR_NAME)
	NCDF_VAR_ID = INTARR(NB_VAR)
	FOR NUM_VAR=0, NB_VAR-1 DO BEGIN
		NCDF_VAR_ID[NUM_VAR] = NCDF_VARID(FID, INGEST_INFOS_STRUCT.NCDF_VAR_NAME[NUM_VAR])
		IF NCDF_VAR_ID[NUM_VAR] EQ -1 THEN BEGIN
				PRINT, 'NETCDFREAD_INTERPOL_AUXDATA: NCDF FILE ' + NCDF_FILENAME + ' : FIELD ' + INGEST_INFOS_STRUCT.NCDF_VAR_NAME[NUM_VAR] + 'DOES NOT EXIST '
				NCDF_CLOSE, FID 
				RETURN, STATUS_ERROR  
		ENDIF
	ENDFOR


	; GET VARIABLES
	NCDF_VARGET, FID, NCDF_LAT_ID, NCDF_LAT_VALUES
	NCDF_VARGET, FID, NCDF_LON_ID, NCDF_LON_VALUES
	NCDF_VARGET, FID, NCDF_TIME_ID, NCDF_TIME_VALUES

	;---------------------------------------------------------
	; GET THE LONGITUDE / LATITUDE INDEXES AND VALUES WHICH CORRESPONDS TO THE AREA TO EXTRACT
	; (EXTENDED WITH BORDER_PIX_NB)

	; LONGITUDE VALUES IN NETCDF FILE
	LON_BKPT_ORIG = GET_COORD_RANGE(NCDF_LON_VALUES, WEST_LON, EAST_LON, INDEXES=INDX_LON_BKPT_ORIG, BORDER_PIX_NB=AUXDATA_BORDER_PIX_NB, INDX_WITH_BORDER_PIX_NB=INDX_LON_BKPT_EXT)
	; LONGITUDE EXTENDED VALUES (WITH BORDER_PIX_NB) IN NETCDF FILE
	LON_BKPT_EXT = NCDF_LON_VALUES(INDX_LON_BKPT_EXT)
	INDX_LON_BKPT_EXT2ORIG = INDGEN(N_ELEMENTS(INDX_LON_BKPT_ORIG))+AUXDATA_BORDER_PIX_NB

	; LATITUDE VALUES IN NETCDF FILE
	LAT_BKPT_ORIG = GET_COORD_RANGE(NCDF_LAT_VALUES, SOUTH_LAT, NORTH_LAT, INDEXES=INDX_LAT_BKPT_ORIG, BORDER_PIX_NB=AUXDATA_BORDER_PIX_NB, INDX_WITH_BORDER_PIX_NB=INDX_LAT_BKPT_EXT)
	; LATITUDE EXTENDED VALUES (WITH BORDER_PIX_NB) IN NETCDF FILE
	LAT_BKPT_EXT = NCDF_LAT_VALUES(INDX_LAT_BKPT_EXT)
	INDX_LAT_BKPT_EXT2ORIG = INDGEN(N_ELEMENTS(INDX_LAT_BKPT_ORIG))+AUXDATA_BORDER_PIX_NB

	IF KEYWORD_SET(DEBUG_MODE) THEN BEGIN
		PRINT, 'DEBUG MODE - AUXDATA_BORDER_PIX_NB = ', AUXDATA_BORDER_PIX_NB
		PRINT, 'DEBUG MODE - LON_BKPT_ORIG = ', LON_BKPT_ORIG, ' / INDX_LON_BKPT_ORIG = ', INDX_LON_BKPT_ORIG
		PRINT, 'DEBUG MODE - LON_BKPT_EXT = ', LON_BKPT_EXT
		PRINT, 'DEBUG MODE - LAT_BKPT_ORIG = ', LAT_BKPT_ORIG, ' / INDX_LAT_BKPT_ORIG = ', INDX_LAT_BKPT_ORIG
		PRINT, 'DEBUG MODE - LAT_BKPT_EXT = ', LAT_BKPT_EXT
	ENDIF

	;---------------------------------------------------------
	; GET THE TIME INDEXES AND VALUES WHICH CORRESPONDS TO THE ACQUISITION DATE TO EXTRACT

		CALDAT, INGEST_INFOS_STRUCT.ACQUI_DATE, MONTH_ACQUI, DAY_ACQUI, YEAR_ACQUI, HOUR_ACQUI, MINUTE_ACQUI, SECOND_ACQUI

		; SWITCH BETWEEN TIME BASIS IN MONTH 
		IF KEYWORD_SET(MONTH_EXTRACT) THEN BEGIN
			; TIME IN MONTH
			;---------------
			; CONVERT NCDF MONTH IN DATE with the YEAR OF THE ACQUISITION DATE (NCDF_TIME_VALUES = MONTH VALUES)
			DAY_REF = 15
			HOUR_REF = 12
			YEAR_REF = YEAR_ACQUI
			NCDF_JUL_DATES = JULDAY(NCDF_TIME_VALUES, DAY_REF, YEAR_REF, HOUR_REF)
			MONTH_BEFORE = JULDAY(12, DAY_REF, YEAR_REF-1, HOUR_REF)
			MONTH_AFTER = JULDAY(1, DAY_REF, YEAR_REF+1, HOUR_REF)
			NCDF_JUL_DATES_EXT = [ MONTH_BEFORE, NCDF_JUL_DATES, MONTH_AFTER ]     

			; TIME VALUES IN NETCDF FILE
			TIME_BKPT = GET_COORD_RANGE(NCDF_JUL_DATES_EXT, INGEST_INFOS_STRUCT.ACQUI_DATE, INGEST_INFOS_STRUCT.ACQUI_DATE, INDEXES=INDX_TIME_BKPT)
			IDX = WHERE( (INDX_TIME_BKPT EQ 0) OR (INDX_TIME_BKPT EQ N_ELEMENTS(NCDF_JUL_DATES_EXT)-1), NB_EXT )
			IF NB_EXT NE 0 THEN BEGIN
				; RETRIEVE ALL DATA FOR TIME BORDER INTERPOLATION
				TIME_EXT_INTERP = 1
				INDX_TIME_BKPT = INDGEN(N_ELEMENTS(NCDF_JUL_DATES))
			ENDIF ELSE BEGIN
				; BACK TO NCDF INDEXES
				INDX_TIME_BKPT = INDX_TIME_BKPT -1
			ENDELSE

		ENDIF ELSE BEGIN
			; TIME IN HOUR PER DAY
			;---------------
			JJ_ERA=DOUBLE(NCDF_TIME_VALUES)/24 ; CHANGE HOURS TO DAY
			; ERA TIME AS REF AT 1 JAN 1900
			REF_ERA=JULDAY(1,1,1900,0,0,0)
			JJ_REF_ERA = REF_ERA + JJ_ERA
			TIME_BKPT = GET_COORD_RANGE(JJ_REF_ERA, INGEST_INFOS_STRUCT.ACQUI_DATE, INGEST_INFOS_STRUCT.ACQUI_DATE, INDEXES=INDX_TIME_BKPT)

		ENDELSE

		IF KEYWORD_SET(DEBUG_MODE) THEN BEGIN
			PRINT, 'DEBUG MODE - ACQUI_DATE = ', INGEST_INFOS_STRUCT.ACQUI_DATE
			PRINT, 'DEBUG MODE - MONTH_ACQUI(', MONTH_ACQUI, ') / DAY_ACQUI(', DAY_ACQUI, ') / YEAR_ACQUI(', YEAR_ACQUI, ') / HOUR_ACQUI(', HOUR_ACQUI, ') / MINUTE_ACQUI(', MINUTE_ACQUI, ') / SECOND_ACQUI(', SECOND_ACQUI, ')'
			PRINT, 'DEBUG MODE - TIME_BKPT = ', TIME_BKPT, ' / INDX_TIME_BKPT = ', INDX_TIME_BKPT
		ENDIF


		; GET VARIABLE FROM NCDF FILE WITH SPECIFIED NUMBERS AND POSITION 
		;--------------------------------------------------
		MIN_LAT_INDX = MIN(INDX_LAT_BKPT_EXT)
		MIN_LON_INDX = MIN(INDX_LON_BKPT_EXT)
		MIN_TIME_INDX = MIN(INDX_TIME_BKPT)

		COUNT_RANGE = [N_ELEMENTS(INDX_LON_BKPT_EXT), N_ELEMENTS(INDX_LAT_BKPT_EXT), N_ELEMENTS(INDX_TIME_BKPT)]
		OFFSET_RANGE = [MIN_LON_INDX, MIN_LAT_INDX, MIN_TIME_INDX]

		IF KEYWORD_SET(DEBUG_MODE) THEN BEGIN
			PRINT, 'DEBUG MODE - NCDF COUNT_RANGE = ', COUNT_RANGE
			PRINT, 'DEBUG MODE - NCDF OFFSET_RANGE = ', OFFSET_RANGE
		ENDIF

		DATA_INTERP = MAKE_ARRAY(NB_VAR, N_ELEMENTS(LON), /DOUBLE)

		FOR NUM_VAR=0, NB_VAR-1 DO BEGIN

			NCDF_VARGET, FID, NCDF_VAR_ID[NUM_VAR], NCDF_VAR_VALUE, COUNT=COUNT_RANGE, OFFSET=OFFSET_RANGE

			; CHECK FOR ATTRIBUTES
			;-------------------
			VAR_INFO = NCDF_VARINQ(FID, NCDF_VAR_ID[NUM_VAR])

			IF VAR_INFO.NATTS GT 0 THEN BEGIN

				VAR_ATT_IDS = INDGEN(VAR_INFO.NATTS)
				VAR_ATT_NAMES = STRARR(VAR_INFO.NATTS)

				FOR NUM_ATT=0, VAR_INFO.NATTS-1 DO BEGIN
					VAR_ATT_NAMES[NUM_ATT] = NCDF_ATTNAME(FID, NCDF_VAR_ID[NUM_VAR], VAR_ATT_IDS[NUM_ATT])        
				ENDFOR

				; GET OFFSET VALUE IF EXIST
				INDX = WHERE( STRCMP(STRUPCASE(VAR_ATT_NAMES),'ADD_OFFSET'), COUNT)
				IF COUNT NE 1 THEN ADD_OFFSET = 0.0 ELSE NCDF_ATTGET, FID, NCDF_VAR_ID[NUM_VAR], VAR_ATT_NAMES[INDX[0]], ADD_OFFSET

				; GET SCALE FACTOR IF EXIST
				INDX = WHERE( STRCMP(STRUPCASE(VAR_ATT_NAMES),'SCALE_FACTOR'), COUNT)
				IF COUNT NE 1 THEN SCALE_FACTOR = 1.0 ELSE NCDF_ATTGET, FID, NCDF_VAR_ID[NUM_VAR], VAR_ATT_NAMES[INDX[0]], SCALE_FACTOR

				; GET MISSING VALUE IF EXIST
				INDX = WHERE( STRCMP(STRUPCASE(VAR_ATT_NAMES),'MISSING_VALUE'), COUNT)
				IF COUNT NE 1 THEN MISSING_VALUE = !VALUES.F_INFINITY ELSE NCDF_ATTGET, FID, NCDF_VAR_ID[NUM_VAR], VAR_ATT_NAMES[INDX[0]], MISSING_VALUE

				IF KEYWORD_SET(DEBUG_MODE) THEN BEGIN
					PRINT, 'DEBUG MODE - NCDF VAR_ATT_NAMES = ', VAR_ATT_NAMES
					PRINT, 'DEBUG MODE - NCDF ADD_OFFSET = ', ADD_OFFSET, ' / SCALE_FACTOR = ', SCALE_FACTOR, ' / MISSING_VALUE = ', MISSING_VALUE
				ENDIF

				; REPLACE MISSING VALUES PER NAN
				INDX_NOT_VALID = WHERE( NCDF_VAR_VALUE EQ MISSING_VALUE, COUNT_MISSING_VALUE , COMPLEMENT=INDX_VALID)              
				SCALED_VALUE = DOUBLE(NCDF_VAR_VALUE)       
				IF COUNT_MISSING_VALUE GT 0 THEN SCALED_VALUE(INDX_NOT_VALID) = !VALUES.F_NAN
				SCALED_VALUE(INDX_VALID) = DOUBLE(ADD_OFFSET + (SCALE_FACTOR * SCALED_VALUE(INDX_VALID))) 

			ENDIF ELSE BEGIN

				SCALED_VALUE = DOUBLE(NCDF_VAR_VALUE)

			ENDELSE

			; DATA INTERPOLATION ACROSS DATE
			;-------------------------------
			IF N_ELEMENTS(TIME_BKPT) GT 1 THEN BEGIN

				IF KEYWORD_SET(TIME_EXT_INTERP) THEN BEGIN
					; REFORMATE DATA FOR DATE INTERLATION ON TIME BORDER
					DATA_START = SCALED_VALUE(*,*,N_ELEMENTS(INDX_TIME_BKPT)-1)
					DATA_STOP  = SCALED_VALUE(*,*,0)
					SCALED_VALUE = [ [[ DATA_START ]] , [[ DATA_STOP ]] ]
				ENDIF

				ACQUI_DATE_NORM = (INGEST_INFOS_STRUCT.ACQUI_DATE - TIME_BKPT[0]) / (TIME_BKPT[1] - TIME_BKPT[0])
				AUX_DATA_ACQUI_DATE=INTERPOLATE([ [[SCALED_VALUE(*,*,0)]] ,[[SCALED_VALUE(*,*,1)]]], ACQUI_DATE_NORM)
				IF KEYWORD_SET(DEBUG_MODE) THEN BEGIN
						PRINT, 'DEBUG MODE - DATE INTERPOLATION - ACQUI_DATE_NORM = ', ACQUI_DATE_NORM
				ENDIF
			ENDIF ELSE BEGIN
				AUX_DATA_ACQUI_DATE = SCALED_VALUE(*,*)
			ENDELSE

			IF KEYWORD_SET(DEBUG_MODE) THEN BEGIN
					PRINT, 'DEBUG MODE - NCDF NCDF_VAR_VALUE[', NUM_VAR, '] = ', NCDF_VAR_VALUE
					PRINT, 'DEBUG MODE - NCDF SCALED_VALUE[', NUM_VAR, '] = ', SCALED_VALUE
					PRINT, 'DEBUG MODE - AUX_DATA_ACQUI_DATE[', NUM_VAR, '] = ', AUX_DATA_ACQUI_DATE
			ENDIF

			; DATA INTERPOLATION ACROSS LAT/LON
			;-------------------------------
			NB_DIMS = SIZE(AUX_DATA_ACQUI_DATE,/N_DIMENSION)
			IF NB_DIMS EQ 0 THEN BEGIN
				; SCALAR VALUE / NO INTERP NEEDED
				VALUE_OUT = AUX_DATA_ACQUI_DATE
			ENDIF ELSE BEGIN
				; CAUTION INTERP2D IS ONLY VALID FOR MONOTONEOUS INCREASING BREAKPOINTS
				; LATITUDE AXE (DECREASING) MUST BE INVERTED AT THE INPUT OF THE FUNCTION
				DATA_IN = REVERSE(AUX_DATA_ACQUI_DATE,2);
				X0=LON_BKPT_EXT
				Y0=LAT_BKPT_EXT
				INTERP_OUT = INTERP2D(DOUBLE(DATA_IN),X0,Y0,LON,LAT) ; ,/CUBIC IF NECESSARY >
				; INTERPOLATION CONCEPT CROSS-VALIDATION IDL/MATLAB > valid_interp_ws_MATLAB_vs_IDL.m
				DATA_INTERP[NUM_VAR,*] = INTERP_OUT
			ENDELSE

		ENDFOR

	NCDF_CLOSE, FID
	
	STATUS = STATUS_OK

	RETURN, DATA_INTERP

END
