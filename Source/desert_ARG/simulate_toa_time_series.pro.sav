;**************************************************************************************
;**************************************************************************************
;*
;* NAME:
;*      SIMULATE_TOA_TIME_SERIES
;* 
;* PURPOSE:
;*      SIMULATING A TOA SERIES FROM A GIVEN SENSOR AS GIVEN BY
;*      DIMITRI FOR NON CLAUDY OBSERVATIONS FOLLOWING M. BOUVET 2011
;* 
;* CALLING SEQUENCE:
;*      RES = SIMULATE_TOA_TIME_SERIES(OUTPUT_FOLDER, SITE, SENSOR, PROC_VER, YEAR, PHOTON_NB, CPU_NB)
;* 
;* INPUTS:
;*      OUTPUT_FOLDER    - THE FULL PATH OF THE OUTPUT FOLDER
;*      SITE             - THE VALIDATION SITE NAME E.G. 'Libya4'
;*      SENSOR           - THE NAME OF THE SENSOR E.G. 'PARASOL'
;*      PROC_VER         - THE PROCESSING VERSION OF THE SENSOR
;*      YEAR             - THE YEAR E.G. 2003 OR 'ALL'
;*	    PHOTON_NB        - THE NUMBER OF PHOTONS USED FOR THE SIMULATION (DEFALT VALUE IS 1500)
;*	    CPU_NB           - THE NUMBER OF PARALLEL JOBS/CPUS (DEFALT VALUE IS 1)
;*
;* KEYWORDS:
;*      CONSOLIDATE      - ALLOWS SUBSTITUTING THE L1 AUX O3 AND WV DATA BY ERA-INTERIM CORRESPONDING DATA
;*      DISPLAY_PLOT     - ALLOW DISPLAYING RESULTS ON THE SCREEN
;*      VERBOSE          - PROCESSING STATUS OUTPUTS
;*
;* OUTPUTS:
;*      STATUS          - 1: NO ERRORS REPORTED, (-1) OR 0: ERRORS DURING SIMULATION 
;*
;* COMMON BLOCKS:
;*      NON
;*
;* MODIFICATION HISTORY:
;*        21 SEP 2014  - M BOUVET - FIRST DEVELOPEMENT OF THE METHODOLOGY
;*        15 JAN 2015  - B ALHAMMOUD - FIRST IMPLEMENTATION TO DIMITRI-V3.1.1
;*        17 MAR 2015  - NCG / MAGELLIUM - UPDATED WITH NCDF INPUT/OUTPUT INTERFACES 
;*                                  AND LOOPS ON PRODUCTS/VIEWING DIRECTIONS (DIMITRI V4)
;*
;* VALIDATION HISTORY:
;*        21 JAN 2015 -  B ALHAMMOUD - LINUX 64-BIT MACHINE IDL 8.2, NOMINAL COMPILATION AND OPERATION.
;*                                  TESTED FOR PARASOL OVER LIBYA4
;*
;**************************************************************************************
;**************************************************************************************

FUNCTION SIMULATE_TOA_TIME_SERIES, SITE,  SENSOR, PROC_VER, YEAR, PHOTON_NB, CPU_NB, CONSOLIDATED=CONSOLIDATED, DISPLAY_PLOT=DISPLAY_PLOT, VERBOSE=VERBOSE


  DEBUG_MODE = 1
  
  METHOD = 'DESERT_ARG'

  STATUS_OK = GET_DIMITRI_LOCATION('STATUS_OK')
  STATUS_ERROR = GET_DIMITRI_LOCATION('STATUS_ERROR')
  STATUS_NODATA = GET_DIMITRI_LOCATION('STATUS_NODATA')

  INPUT_FOLDER  = GET_DIMITRI_LOCATION('INGESTION_OUTPUT')
  OUTPUT_FOLDER = GET_DIMITRI_LOCATION('OUTPUT')
  MISSING_VALUE_FLT = FLOAT(GET_DIMITRI_LOCATION('NCDF_MISSING_VALUE'))

;-----------------------------------------
; DEFINE CURRENT FUNCTION NAME

  FCT_NAME  = 'SIMULATE_TOA_TIME_SERIES'

	;-----------------------------------------
	; CHECK SITE TYPE

  SITE_TYPE = GET_SITE_TYPE(SITE_NAME,VERBOSE=VERBOSE)
  IF STRUPCASE(SITE_TYPE) NE 'DESERT' THEN BEGIN
     PRINT,FCT_NAME+': ERROR, INPUT SITE IS NOT EXISTING OR NOT DESERT'
     RETURN, STATUS_ERROR
  ENDIF

;-----------------------------------------
; DEFINE INPUT/OUTPUT FILES AND DIRECTORIES

  IF KEYWORD_SET(VERBOSE) THEN PRINT,FCT_NAME+': DEFINING INPUT/OUTPUT FILES'
  SITE_FILE  = GET_DIMITRI_LOCATION('SITE_DATA')
  BANDS_FILE = GET_DIMITRI_LOCATION('BAND_NAME')
  DB_FILE    = GET_DIMITRI_LOCATION('DATABASE')
  MAIN_DIRC  = GET_DIMITRI_LOCATION('DIMITRI')

	;-----------------------------------------
	; CHECK DIMITRI DATABASE EXISTS

  TEMP = FILE_INFO(DB_FILE)
  IF TEMP.EXISTS EQ 0 THEN BEGIN
    PRINT, FCT_NAME+': ERROR, DIMITRI DATABASE FILE DOES NOT EXIST'
    RETURN, STATUS_ERROR
  ENDIF

	;-------------------
	; COMPUTE THE AOT SCALING FACTOR WHICH IS AOT_550 / AOT_550_HESS_MODEL

	RESTORE, MAIN_DIRC+'/AUX_DATA/PICS_BRDF_data/template_aero_data.sav'
	BEST_AEROSOL=READ_ASCII(MAIN_DIRC+'/AUX_DATA/PICS_BRDF_data/'+SITE+'_aero_data.txt', TEMPLATE=TEMPLATE_AERO_DATA)
	AERO_TYPE = BEST_AEROSOL.FIELD1
	AOT_550   = BEST_AEROSOL.FIELD2

	IF AERO_TYPE EQ 'continental_average' THEN AOT_550_HESS_MODEL = 0.107539 ; VALUES FOR THE CONTINENTAL_AVERAGE
	IF AERO_TYPE EQ 'desert'              THEN AOT_550_HESS_MODEL = 0.246745 ; VALUE FOR THE DESERT
	AOT_SCALING_FACTOR = AOT_550 / AOT_550_HESS_MODEL



; DEFINE THE NUMBER OF PARALLEL JOBS/CPUS
MAX_CPU=!CPU.HW_NCPU
;MAX_CPU=4
IF (CPU_NB NE 0 ) AND ( CPU_NB LT MAX_CPU) THEN BEGIN
   MAX_CPU=CPU_NB
ENDIF

; DEFINE THE NUMBER OF PHOTON PER SIMULATION
;BAH PHOTON_NB=1500

; GRAPHIC SETTINGS
IF KEYWORD_SET(DISPLAY_PLOT) THEN BEGIN
  WINDOW, 10,RETAIN=2, XSIZE=1200, YSIZE=900
  DEVICE, DECOMPOSED=0
ENDIF ELSE BEGIN
  SET_PLOT, 'Z'
  DEVICE, DECOMPOSED=0, SET_RESOLUTION=[1200, 900],SET_PIXEL_DEPTH=24
ENDELSE


	;----------------------------------------
	; READ THE DIMITRI DATABASE

  IF KEYWORD_SET(VERBOSE) THEN PRINT,FCT_NAME+': READING DIMITRI DATABASE'
  DB_TEMPLATE = GET_DIMITRI_TEMPLATE(1,/TEMPLATE)
  DB_DATA     = READ_ASCII(DB_FILE,TEMPLATE=DB_TEMPLATE)

	;----------------------------------------
	; SORT OUT THE DATA THAT ARE REQUESTED FROM THE DATABASE

	;; SELECT DATA FOR WHICH THE SENSOR IS AS REQUESTED
	FLAG_REQUESTED=FLOAT(DB_DATA.SENSOR EQ SENSOR)

	;; SELECT DATA FOR WHICH THE PROCESSING VERSION IS AS REQUESTED
	FLAG_REQUESTED=FLAG_REQUESTED*FLOAT(DB_DATA.PROCESSING_VERSION EQ PROC_VER)

	;; SELECT DATA FOR WHICH THE SITE IS AS REQUESTED
	FLAG_REQUESTED=FLAG_REQUESTED*FLOAT(DB_DATA.SITE_NAME EQ SITE)

	;; SELECT DATA FOR WHICH AUTOMATIC CLOUD SCREENING AND MANUAL CLOUD SCREENING GIVE NO CLOUD AT ALL
	FLAG_REQUESTED=FLAG_REQUESTED*FLOAT(((DB_DATA.AUTO_CS_1_MEAN EQ 0) AND (DB_DATA.MANUAL_CS NE 1)) OR (DB_DATA.MANUAL_CS EQ 0))

	;; SELECT DATA FOR WHICH THE YEAR IS AS REQUESTED
	CYEAR = STRTRIM(YEAR,2)
	IF CYEAR EQ 'ALL' THEN BEGIN
		PRINT, 'SELECTION IS DONE OVER '+CYEAR+' AVAILABLE YEARS'  ; IN FACT WE SKIP THE YEAR SELECTION HERE, AUTOMATICALY WE TAKE ALL THE DATES
	ENDIF ELSE BEGIN
		FLAG_REQUESTED=FLAG_REQUESTED*FLOAT(DB_DATA.YEAR EQ YEAR)
	ENDELSE

	;; SELECT DATA FOR WHICH THE ROI IS FULLY COVERED
	FLAG_REQUESTED=FLAG_REQUESTED*FLOAT(DB_DATA.ROI_STATUS EQ 1)

	;; GET THE INDEX OF THE ACQUISITION REQUESTED IN THE DATABASE
	IDX_FILES=WHERE(FLAG_REQUESTED, NB_FILES)

  IF NB_FILES EQ 0 THEN BEGIN
    PRINT, FCT_NAME+': WARNING, NO SENSOR DATA FOUND WITHIN PIXEL THRESHOLD OR CLOUD CONDITION, RETURN'
    RETURN, STATUS_NODATA
  ENDIF

  ;----------------------
  ; GET INGESTION OUTPUT FILENAME FROM DATABASE
  
  SEARCH_FOLDER = INPUT_FOLDER + DL + 'Site_' + SITE + DL + SENSOR + DL + 'Proc_' + PROC_VER + DL
  I_FILES = SEARCH_FOLDER + DL + STRTRIM(STRING(DB_DATA.YEAR[IDX_FILES]),2) + DL + DB_DATA.L1_INGESTED_FILENAME[IDX_FILES]
  FILE_RESULT = FILE_SEARCH(I_FILES, COUNT=NB_FILES_SEARCH)
  
  IF NB_FILES_SEARCH NE NB_FILES THEN BEGIN
    IF KEYWORD_SET(VERBOSE) THEN PRINT, FCT_NAME + ': THE NUMBER OF INGESTION PRODUCTS ON DISK (', NB_FILES_SEARCH, $
                                                    ') DOES NOT MATCH THE NUMBER OF INGESTED PRODUCT IN THE DATABASE (', NB_FILES, ')'
    RETURN, STATUS_ERROR
  ENDIF
 
  ;----------------------
  ; GET BAND INFO STRUCTURE (NB_BANDS, BAND_ID, BAND_LABEL_STD, BAND_WAVELENGTH)
  
  NB_DIRECTIONS = SENSOR_DIRECTION_INFO(SENSOR)
  NB_DIRECTIONS = NB_DIRECTIONS[0]

  SENSOR_CONFIG = GET_SENSOR_BAND_CONFIG(SENSOR) ; GET USED CHANNELS / STD LABELS / SMAC FILENAME / LUT FILENAME

  ;-------------------
  ; COMPUTE SENSOR BAND WAVELENGTH TO PROCESS 
  
  BAND_WAVELENGTH = CUR_SENSOR_BAND_INFOS.BAND_WAVELENGTH
	N_BANDS = N_ELEMENTS(BAND_WAVELENGTH)


  ;-------------------
  ; GET RSR AND RPV MODEL AND COMPUTE SENSOR BAND WAVELENGTH TO PROCESS 
  
	;BAH THE RPV-TEMPLATE IS THE ONE PROVIDD BY M.B. (SRC) 
	; WE ONLY PROCEEED IF THE WAVELENGTH_MIN AND WAVELENGTH_MAX ARE WITHIN THE RANGE OF THE RPV SPECTRAL MODEL DEFINITION
	RESTORE, MAIN_DIRC+'/AUX_DATA/PICS_BRDF_data/template_to_read_RPV_model_files_in_IDL.sav'
	RPV_MODEL=READ_ASCII(MAIN_DIRC+'/AUX_DATA/PICS_BRDF_data/'+SITE+'_interpolated_RPV_model.txt', TEMPLATE=TEMPLATE_RPV)
	WAVELENGTH_RPV_MIN=MIN(RPV_MODEL.FIELD1)
	WAVELENGTH_RPV_MAX=MAX(RPV_MODEL.FIELD1)

	;BAH THIS TEMPLATE IS THE ONE PROVIDED BY MB (SRC) 
	;READ THE TEMPLATE FOR THE SPECTRAL RESPONSE ASCII FILE (RSR ARE FROM DIMITRI)
	RSR_TEMPLATE  = GET_DIMITRI_RSR_TEMPLATE()

	WAVELENGTH_MIN = FLTARR(N_BANDS)
	WAVELENGTH_MAX = FLTARR(N_BANDS)
	
	; START LOOPING ON EACH BAND
	FOR SPECTRAL_BAND=0, N_BANDS-1 DO BEGIN
	
		; DEFINE NAME OF THE SPECTRAL RESPONSE FILE
		FILTER_FILENAME=MAIN_DIRC+'/AUX_DATA/spectral_response/'+SENSOR+'/RSR_'+SENSOR+'_BAND_'+STRTRIM(SPECTRAL_BAND, 2)+'.txt'

		; READ THE SPECTRAL RESPONSE
		SPECTRAL_RESPONSE=READ_ASCII(FILTER_FILENAME, TEMPLATE=RSR_TEMPLATE)

		; ASSIGN MIN AND MAX WAVELENGHT OF SPECTRAL REPONSE TO THE VARIABLE USED TO DEFINE THE INTERVAL OF THE SIMULATION
		WAVELENGTH_MIN[SPECTRAL_BAND] = MIN(SPECTRAL_RESPONSE.WAVELENGTH)
		WAVELENGTH_MAX[SPECTRAL_BAND] = MAX(SPECTRAL_RESPONSE.WAVELENGTH)
	
	ENDFOR

	IDX_VALID_BANDS = WHERE( (WAVELENGTH_MIN GT WAVELENGTH_RPV_MIN) AND (WAVELENGTH_MAX LT WAVELENGTH_RPV_MAX) , NB_VALID_BANDS)
	
	IF NB_VALID_BANDS EQ 0 THEN BEGIN
    IF KEYWORD_SET(VERBOSE) THEN PRINT, FCT_NAME + ': SPECTRAL BAND DEFINED OUTSIDE RPV SPECTRAL MODEL DOMAIN...'
    RETURN, STATUS_NODATA
  ENDIF
	
  ;----------------------
	; READ THE EXTRATERRESTRIAL SOLAR IRRADIANCE

	SOLAR_SPECTRUM=READ_ASCII(MAIN_DIRC+'/AUX_DATA/solar_spectrum/Thuillier_2003_solar_irradiance.txt', DATA_START=1) ; in mW.m-2.nm-1
	SPECTRAL_RESOLUTION=0.1 ; IN NM

  ;----------------------
  ; SET OUTPUT CALIB FOLDER
  
  CALDAT, SYSTIME(/UTC,/JULIAN),TMM,TDD,TYY,THR,TMN,TSS

  TYY = STRTRIM(STRING(TYY),2)
  TMM = TMM LT 10 ? '0'+STRTRIM(STRING(TMM),2) : STRTRIM(STRING(TMM),2)
  TDD = TDD LT 10 ? '0'+STRTRIM(STRING(TDD),2) : STRTRIM(STRING(TDD),2)
  THR = THR LT 10 ? '0'+STRTRIM(STRING(THR),2) : STRTRIM(STRING(THR),2)
  TMN = TMN LT 10 ? '0'+STRTRIM(STRING(TMN),2) : STRTRIM(STRING(TMN),2)
  TSS = TSS LT 10 ? '0'+STRTRIM(STRING(TSS,FORMAT='(I)'),2) : STRTRIM(STRING(TSS,FORMAT='(I)'),2)

  PROCESS_DATE = TYY+TMM+TDD+'-'+THR+TMN

  OUT_FILEPATH = OUTPUT_FOLDER + DL + METHOD + '_' + PROCESS_DATE + DL + 'Site_'+ SITE_NAME + DL + SENSOR + DL + 'Proc_' + PROC_VERSION + DL
  OUT_FILENAME_BASE =  SITE_NAME + '_' + SENSOR + '_' + PROC_VERSION + '_' + METHOD 
          
  ;----------------------
  ; LOOP OVER NCDF FILE IN PROCESSING DATASET

  FOR IDX_FILE=0, NB_FILES-1 DO BEGIN

    NCDF_FILENAME = FILE_RESULT[IDX_FILE]
    NCDF_INFOS = FILE_INFO(NCDF_FILENAME)
    
    IF NCDF_INFOS.EXISTS EQ 0 OR STRLEN(NCDF_FILENAME) EQ 0 THEN BEGIN
      IF KEYWORD_SET(VERBOSE) THEN PRINT,FCT_NAME + ': FILE ',NCDF_FILENAME,' IS MISSING, PLEASE CHECK YOUR INGESTION PROGRESS'
      GOTO, NEXT_IFILES
    ENDIF

    CUR_NCFILE = FILE_BASENAME(NCDF_FILENAME)

    ;----------------------
    ; GET ACQUISITION DATE FROM NCDF FILE
    CUR_NCDF_DATE = STRTRIM(GET_NCDF_GLOBAL_ATT(NCDF_FILENAME, 'ACQUISITION_DATE'))
    NCDF_YEAR_STR=STRMID(CUR_NCDF_DATE,0,4)
    NCDF_MONTH_STR=STRMID(CUR_NCDF_DATE,5,2)
    NCDF_DAY_STR=STRMID(CUR_NCDF_DATE,8,2)
    NCDF_HOURS_STR=STRMID(CUR_NCDF_DATE,11,2)
    NCDF_MINUTES_STR=STRMID(CUR_NCDF_DATE,14,2)
    
    NCDF_YEAR=UINT(NCDF_YEAR_STR)
    NCDF_MONTH=UINT(NCDF_MONTH_STR)
    NCDF_DAY=UINT(NCDF_DAY_STR)
    NCDF_HOURS=UINT(NCDF_HOURS_STR)
    NCDF_MINUTES=UINT(NCDF_MINUTES_STR)
    
    ACQUI_DATE = JULDAY(NCDF_MONTH,NCDF_DAY,NCDF_YEAR,NCDF_HOURS,NCDF_MINUTES,0)
    
    IF KEYWORD_SET(VERBOSE) THEN BEGIN
      PRINT, '[' + STRTRIM(STRING(IDX_FILE+1),1) + '/' + STRTRIM(STRING(NB_FILES),1) + '] > ' + FCT_NAME + ' ' + CUR_NCFILE + ' :: ' + CUR_NCDF_DATE
    ENDIF

    ; COMPUTE DECIMAL YEAR
    IF FLOAT(DATE_TABLE[0]) MOD 4 EQ 0 THEN DIY = DOUBLE(366.0) ELSE DIY = DOUBLE(365.0)
    TTIME = DOUBLE( (NCDF_HOURS/(DIY*24.))+(NCDF_MINUTES/(DIY*60.*24.)) )
    DAY_OF_YEAR = DOUBLE(JULDAY(NCDF_MONTH,NCDF_DAY,NCDF_YEAR)-JULDAY(1,0,NCDF_YEAR))
    
    DECIMAL_YEAR  = DOUBLE(NCDF_YEAR)+ DAY_OF_YEAR/DIY + TTIME

    ;----------------------
    ; READ INPUT INGESTION FILE
    
    STATUS = NETCDFREAD_INGEST_OUTPUT( NCDF_FILENAME, NCDF_INGEST_STRUCT=NCDF_INGEST_STRUCT, VERBOSE=VERBOSE)
    IF STATUS NE STATUS_OK THEN BEGIN
      IF KEYWORD_SET(VERBOSE) THEN BEGIN
        PRINT, FCT_NAME + ': ERROR DURING ', FILE_BASENAME(NCDF_FILENAME),' FILE READING >> FILE SKIPPED'
      ENDIF
      GOTO, NEXT_IFILES
    ENDIF  

    ;----------------------
		; CONSOLIDATE THE METEO DATA IF NEEDED

		OZONE_ALL = NCDF_INGEST_STRUCT.VARIABLES.ERA_OZONE
		WATERVAPOUR_ALL = NCDF_INGEST_STRUCT.VARIABLES.ERA_WATERVAPOUR
			
		IF KEYWORD_SET(CONSOLIDATED) THEN BEGIN
    
			; GET ROI COORDINATES
		  ICOORDS = GET_SITE_COORDINATES(SITE,SITE_FILE,VERBOSE=VERBOSE)
     	IF ICOORDS[0] EQ -1 THEN BEGIN
        PRINT,FCT_NAME+': ERROR, REGION COORDINATES NOT FOUND'
        RETURN, STATUS_ERROR
     	ENDIF

			LAT_ROI_CENTER=(ICOORDS[0]+ICOORDS[1])/2.
			LON_ROI_CENTER=(ICOORDS[2]+ICOORDS[3])/2.
       
			; RETRIEVE OZONE AND WATERVAPOUR VALUES ATTHE ACUISITION DATE AND CENTER LAT/LON COORD
    	TCO = READ_ECMWF_INTERIM(DECIMAL_YEAR, LAT_ROI_CENTER, LON_ROI_CENTER, 'TCO')
    	WV  = READ_ECMWF_INTERIM(DECIMAL_YEAR, LAT_ROI_CENTER, LON_ROI_CENTER, 'WV')
            
    	OZONE_ALL(*)       = TCO
    	WATERVAPOUR_ALL(*) = WV
    
    ENDIF
    
    ;----------------------
    ; BEFORE STARTING, WE MAKE SURE THE OZONE AND WATER VAPOUR ARE AVAILABLE IN THE FILE 
    ; OTHERWISE WE FILL UP WITH DUMMY VALUES

		IDX = WHERE( OZONE_ALL EQ MISSING_VALUE_FLT, COUNT)
		IF COUNT NE 0 THEN OZONE_ALL[IDX] = 300
		IDX = WHERE( WATERVAPOUR_ALL EQ MISSING_VALUE_FLT, COUNT)
		IF COUNT NE 0 THEN WATERVAPOUR_ALL[IDX] = 20
		
    ;----------------------
    ; GET NCDF STRUCTURE FOR CALIBRATION OUTPUT
    
    CALIB_PIXEL_NUMBER = 1 ; USE MEAN VALUE TO BE ONLINE WITH ARGANS FOR THE MOMENT...
    
    NCDF_CALIB_STRUCT = GET_NCDF_CALIB_STRUCT(CALIB_PIXEL_NUMBER, NCDF_INGEST_STRUCT.DIMENSIONS.ROI_PIXEL_NUMBER, NB_DIRECTIONS, NB_VALID_BANDS, VERBOSE=VERBOSE)
    NCDF_CALIB_STRUCT.GLOBAL_ATT.CALIBRATION_METHOD = METHOD
    NCDF_CALIB_STRUCT.VARIABLES.REFL_BAND_IDS = IDX_VALID_BANDS
    
    ;----------------------
    ; COPY COMMON INFOS FROM INGESTION NCDF TO CALIBRATION NCDF
    STATUS = COPY_INGESTION_TO_CALIBRATION_NCDF_STRUCTURE(NCDF_INGEST_STRUCT=NCDF_INGEST_STRUCT, NCDF_CALIB_STRUCT=NCDF_CALIB_STRUCT, VERBOSE=VERBOSE)
    IF STATUS NE STATUS_OK THEN RETURN, STATUS
    
    ;----------------------
    ; LOOP OVER VIEWING DIRECTION
    
    AT_LEAST_ONE_DIR = 0
    
    FOR NUM_DIR=0, NB_DIRECTIONS-1 DO BEGIN
                  
      IF NUM_DIR+1 LT 10 THEN DIR_ID = 'DIR0' + STRTRIM(STRING(NUM_DIR+1),2) $
                         ELSE DIR_ID = 'DIR' + STRTRIM(STRING(NUM_DIR+1),2)
                          
      IF KEYWORD_SET(VERBOSE) THEN BEGIN
        PRINT, FCT_NAME + ': ----- PROCESS DIRECTION [' + DIR_ID + '/' + STRTRIM(STRING(NB_DIRECTIONS),1) + ']'
      ENDIF

      IF NCDF_INGEST_STRUCT.VARIABLES.ROI_STATUS[NUM_DIR] EQ 0 THEN BEGIN
        IF KEYWORD_SET(VERBOSE) THEN BEGIN
          PRINT, FCT_NAME + ': ROI STATUS WITH 0 VALUE >> DIRECTION SKIPPED'
        ENDIF
        GOTO, NEXT_DIR
      ENDIF

			;----------------------
			; SELECT ONLY THE DATA WHERE THE OBSERVATIONAL ANGLES ARE CLOSE TO ONE OF THOSE USED TO INVERT THE BRDF MODEL

			VZA = MEAN(NCDF_INGEST_STRUCT.VARIABLES.VZA[*,NUM_DIR])
			VAA = MEAN(NCDF_INGEST_STRUCT.VARIABLES.VAA[*,NUM_DIR])
			SZA = MEAN(NCDF_INGEST_STRUCT.VARIABLES.SZA[*,NUM_DIR])
			SAA = MEAN(NCDF_INGEST_STRUCT.VARIABLES.SAA[*,NUM_DIR])

			MAX_ANGULAR_DISTANCE = 50. ; 5 DEGREE IS THE MAX ANGULAR DISTANCE TO ONE OF THE MERIS OBSERVATIONS USED TO GENERATE THE BRDF MODEL
			MATCHING_GEOMETRIES = VALID_RPV_BRDF_GEOMETRY(VZA, VAA, SZA, SAA, MAX_ANGULAR_DISTANCE, SITE, /VERBOSE)

			; WE CHOSE ONLY THE IDENTICAL CONFIGURATIONS
			IF MATCHING_GEOMETRIES NE 1 THEN BEGIN
				PRINT, FCT_NAME + ': GEOMETRY NOT CLOSE TO ONE OF THOSE USED TO INVERT THE BRDF MODEL, SKIP DIRECTION'
				GOTO, NEXT_DIR
			ENDIF


			;-------------------
			; SIMULATION OF THE REMOTE SENSING DATA

			; START LOOPING ON EACH BAND
			FOR BAND=0, NB_VALID_BANDS-1 DO BEGIN
			
				SPECTRAL_BAND = IDX_VALID_BANDS[BAND]

        PRINT, 'SIMULATING DATA FROM BAND ', SPECTRAL_BAND+1

				IF KEYWORD_SET(VERBOSE) THEN PRINT, SENSOR + ' :: ID : ' + STRTRIM(STRING(SENSOR_CONFIG.BAND_ID[SPECTRAL_BAND]),1) + $
																						', LABEL_STD : ' + SENSOR_CONFIG.BAND_LABEL_STD[SPECTRAL_BAND] + $
																						', REF_LABEL : ' + SENSOR_CONFIG.BAND_REF_LABEL[SPECTRAL_BAND] + $
																						', WAVELENGTH : ', SENSOR_CONFIG.BAND_WAVELENGTH[SPECTRAL_BAND] + $
																						', WAVELENGTH MIN/MAX : ' + WAVELENGTH_MIN[SPECTRAL_BAND] + ' / ' + WAVELENGTH_MAX[SPECTRAL_BAND]

	      RTOA_OBS = REFORM(NCDF_INGEST_STRUCT.VARIABLES.REFL_BAND[*,NUM_DIR, SPECTRAL_BAND])
	      
				; SELECT ONLY THE DATA WHERE THE REFLECTANCE IS VALID 
				INDEX_VALID = WHERE((RTOA_OBS GT 0) AND (RTOA_OBS LT 5), NB_PIX)
				
				IF NB_PIX EQ 0 THEN BEGIN
					PRINT, FCT_NAME + ': NO VALID BAND VALUE, SKIP BAND'
					GOTO, NEXT_BAND
				ENDIF

				; GET OZONE/WATERVAPOUR VALUES
        OZONE = MEAN(OZONE_ALL[INDEX_VALID,NUM_DIR])
        WV = MEAN(WATERVAPOUR_ALL[INDEX_VALID,NUM_DIR])				              

				; GET ANGLES VALUES
				VZA = MEAN(NCDF_INGEST_STRUCT.VARIABLES.VZA[INDEX_VALID,NUM_DIR])
				VAA = MEAN(NCDF_INGEST_STRUCT.VARIABLES.VAA[INDEX_VALID,NUM_DIR])
				SZA = MEAN(NCDF_INGEST_STRUCT.VARIABLES.SZA[INDEX_VALID,NUM_DIR])
				SAA = MEAN(NCDF_INGEST_STRUCT.VARIABLES.SAA[INDEX_VALID,NUM_DIR])

				;-------------------
				; RUN MYSTIC WITH ALL INPUTS
				IF KEYWORD_SET(VERBOSE) THEN PRINT,FCT_NAME+': RUN MYSTIC MODEL'
				MC_BASENAME='mc_simulation'
				INPUT_FILE  = MAIN_DIRC+'/Temp_sim_files/'+MC_BASENAME+'.input'
				OUTPUT_FILE = MAIN_DIRC+'/Temp_sim_files/'+MC_BASENAME+'.rad.spc'
				OUTPUT_FILE_STD = MAIN_DIRC+'/Temp_sim_files/'+MC_BASENAME+'.rad.std.spc'
				
				WRITE_MYSTIC_RPV_INPUT, INPUT_FILE, MC_BASENAME+STRTRIM(AVAIL_CPU_INDEX[0], 2), $
					PHOTON_NB, WAVELENGTH_MIN[SPECTRAL_BAND], WAVELENGTH_MAX[SPECTRAL_BAND], $ 
					SZA, SAA, VZA, VAA-180., 0, 0, 0, 0, OZONE, WV, AOT_SCALING_FACTOR, AERO_TYPE, $ 
					RPV_FILE=MAIN_DIRC+'/AUX_DATA/PICS_BRDF_data/'+SITE+'_interpolated_RPV_model.txt'

        SPAWN, 'uvspec < '+INPUT_FILE+' >/dev/null ', /sh        

				; READ THE SIMULATION RESULT
				RHO_TOA = READ_MYSTIC_OUTPUT(OUTPUT_FILE)

				; READ THE STANDARD DEVIATION ASSOCIATED TO THE SIMULATION
				RHO_TOA_STD = READ_MYSTIC_OUTPUT(OUTPUT_FILE_STD)


				; CONVOLUTION OF THE SPECTRAL RESPONSE AND THE SIMULATE SIGNAL
				; WE SAMPLE THE SIGNAL AND THE SPECTRAL RESPONSE AND A REGULAR INTERVAL SPECTRAL GRID AT 0.1 NM

				WAVELENGTH_GRID = INDGEN(CEIL((WAVELENGTH_MAX[SPECTRAL_BAND]-WAVELENGTH_MIN[SPECTRAL_BAND])/SPECTRAL_RESOLUTION))*SPECTRAL_RESOLUTION+WAVELENGTH_MIN[SPECTRAL_BAND]
				RESAMPLED_SPECTRAL_RESPONSE = INTERPOL(SPECTRAL_RESPONSE.RESPONSE, SPECTRAL_RESPONSE.WAVELENGTH, WAVELENGTH_GRID)
				RESAMPLED_RHO_TOA = INTERPOL(RHO_TOA[1,*], RHO_TOA[0,*],WAVELENGTH_GRID)
				RESAMPLED_SOLAR_IRRADIANCE = INTERPOL(SOLAR_SPECTRUM.FIELD1[1,*], SOLAR_SPECTRUM.FIELD1[0,*],WAVELENGTH_GRID)

				; CONVOLUTION OF THE SPECTRAL RESPONSE AND THE SIMULATE SIGNAL
				RTOA_OBS_SIMU = TOTAL(RESAMPLED_RHO_TOA*RESAMPLED_SOLAR_IRRADIANCE*RESAMPLED_SPECTRAL_RESPONSE)/TOTAL(RESAMPLED_SOLAR_IRRADIANCE*RESAMPLED_SPECTRAL_RESPONSE)

				; COMPUTE THE MEAN STANDARD DEVIATION OVER ALL 1 NM MONOCHROMATIC COMPUTATIONS 
				RTOA_OBS_SIMU_STD = MEAN(RHO_TOA_STD[1,*])/SQRT(N_ELEMENTS(RHO_TOA_STD[1,*]))

				;REMOVE THE SIMULATION OUTPUT
				SPAWN, ['rm',OUTPUT_FILE,OUTPUT_FILE_STD], /noshell

				RTOA_OBS = MEAN(RTOA_OBS[INDEX_VALID])
				REF_TO_SIM_RATIO = RTOA_OBS / RTOA_OBS_SIMU

        IF NB_DIRECTIONS GT 1 THEN BEGIN
          OUT_FIG_FILENAME = OUT_FILEPATH + NCDF_YEAR_STR + DL + OUT_FILENAME_BASE + '_' + NCDF_YEAR_STR + NCDF_MONTH_STR + NCDF_DAY_STR $
                                        + '_' + NCDF_HOURS_STR + NCDF_MINUTES_STR $
                                        + '_' + DIR_ID $
                                        + '_' + SENSOR_CONFIG.BAND_REF_LABEL[SPECTRAL_BAND] $
                                        + '_' + STRTRIM(STRING(SENSOR_CONFIG.BAND_WAVELENGTH[SPECTRAL_BAND]),2) $
                                        + '.jpg'
        ENDIF ELSE BEGIN
          OUT_FIG_FILENAME = OUT_FILEPATH + NCDF_YEAR_STR + DL + OUT_FILENAME_BASE + '_' + NCDF_YEAR_STR + NCDF_MONTH_STR + NCDF_DAY_STR $
                                        + '_' + NCDF_HOURS_STR + NCDF_MINUTES_STR $
                                        + '_' + SENSOR_CONFIG.BAND_REF_LABEL[SPECTRAL_BAND] $
                                        + '_' + STRTRIM(STRING(SENSOR_CONFIG.BAND_WAVELENGTH[SPECTRAL_BAND]),2) $
                                        + '.jpg'
        ENDELSE                                
        RES = GET_SENSOR_TO_SIMULATION_TIMESERIES_PLOTS(OUT_FIG_FILENAME, RTOA_OBS, RTOA_OBS_SIMU, REF_TO_SIM_RATIO)

        ;-------------------
        ; COMPLETE NCDF CALIBRATION STRUCTURE
        
        NB_PIX = NCDF_CALIB_STRUCT.VARIABLES.CALIB_PIXEL_NUMBER(NUM_DIR)
        ;NCDF_CALIB_STRUCT.VARIABLES.BAND_GAZ_TRANS(0:NB_PIX-1,NUM_DIR,K)        = TO3_K
        NCDF_CALIB_STRUCT.VARIABLES.BAND_RHO_SIM(0:NB_PIX-1,NUM_DIR,K)          = RTOA_OBS_SIMU
        ;NCDF_CALIB_STRUCT.VARIABLES.BAND_RHO_SIM_UNCERT(0:NB_PIX-1,NUM_DIR,K)   = BAND_RHO_SIM_UNCERT
        NCDF_CALIB_STRUCT.VARIABLES.BAND_REF_TO_SIM_RATIO(0:NB_PIX-1,NUM_DIR,K) = REF_TO_SIM_RATIO
        NCDF_CALIB_STRUCT.VARIABLES.BAND_VALID_INDEX(0:NB_PIX-1,NUM_DIR,K)      = INDGEN(NB_PIX)

				NEXT_BAND:
				
			ENDFOR ; END LOOP ON BANDS

			AT_LEAST_ONE_DIR = 1
			
			NEXT_DIR:
			
		ENDFOR ; END LOOP ON DIRECTIONS

    ; CHECK IF AT LEAST ONE DIRECTION HAS BEEN PROCESSED 
    IF AT_LEAST_ONE_DIR EQ 1 THEN BEGIN
      
      ;----------------------
      ; WRITE CALIBRATION OUTPUT
      
      STATUS = NETCDFWRITE_CALIB_OUTPUT(PROCESS_DATE, NCDF_CALIB_STRUCT, NCDF_FILENAME=NCDF_FILENAME, VERBOSE=VERBOSE)
      IF STATUS NE STATUS_OK THEN BEGIN
        IF KEYWORD_SET(VERBOSE) THEN PRINT, FCT_NAME + ': ERROR DURING OUTPUT CALIBRATION WRITING >> RETURNING'    
        RETURN, STATUS_ERROR
      ENDIF
      
    ENDIF ELSE IF KEYWORD_SET(VERBOSE) THEN PRINT, FCT_NAME + ': NO DIRECTION WITH VALID PIXEL >> FILE SKIPPED'

		NEXT_IFILES:
		
	ENDFOR ; END LOOP ON FILES
	
  NO_IFILES:

  PRINT, FCT_NAME + ': ***** PROCESS COMPLETED SUCCESSFULLY *****'
  RETURN, STATUS_OK

END	
	


;  ;-------------------
;	; SIMULATION OF THE REMOTE SENSING DATA
;
;; START LOOPING ON EACH BAND
;FOR SPECTRAL_BAND=1, N_BANDS DO BEGIN
;
;;SELECT ONLY THE DATA WHERE THE REFLECTANCE IS VALID AND THE SZA AND VZA ARE WITHIN  THE DEFINITION RANGE OF THE RETRIEVED BRDF MODEL 
;;  MERIS_SZA_MAX=60.
;;  MERIS_VZA_MAX=38.
;;  INDEX_VALID=WHERE((GOOD_INDEX EQ 1) AND (SENSOR_L1B_REF[16+SPECTRAL_BAND,*] GT 0) AND (SENSOR_L1B_REF[16+SPECTRAL_BAND,*] LT 5) AND (SENSOR_L1B_REF[1,*] LT MERIS_VZA_MAX) AND (SENSOR_L1B_REF[3,*] LT MERIS_SZA_MAX))
;  
;  ;SELECT ONLY THE DATA WHERE THE REFLECTANCE IS VALID 
;  INDEX_VALID=WHERE((GOOD_INDEX EQ 1) AND (SENSOR_L1B_REF[16+SPECTRAL_BAND,*] GT 0) AND (SENSOR_L1B_REF[16+SPECTRAL_BAND,*] LT 5) )
;  
;  ;SELECT ONLY THE DATA WHERE THE OBSERVATIONAL ANGLES ARE CLOSE TO ONE OF THOSE USED TO INVERT THE BRDF MODEL
;  IF N_ELEMENTS(INDEX_VALID) GT 1 THEN BEGIN 
;    MAX_ANGULAR_DISTANCE=50. ; 5 DEGREE IS THE MAX ANGULAR DISTANCE TO ONE OF THE MERIS OBSERVATIONS USED TO GENERATE THE BRDF MODEL
;    MATCHING_GEOMETRIES=VALID_RPV_BRDF_GEOMETRY(SENSOR_L1B_REF[1,INDEX_VALID], SENSOR_L1B_REF[2,INDEX_VALID], SENSOR_L1B_REF[3,INDEX_VALID], SENSOR_L1B_REF[4,INDEX_VALID], MAX_ANGULAR_DISTANCE, SITE, /VERBOSE)
;    
;    ;INDEX_VALID=INDEX_VALID[WHERE(MATCHING_GEOMETRIES NE 0)]
;    INDEX_VALID=INDEX_VALID[WHERE(MATCHING_GEOMETRIES EQ 1)] ; WE CHOSE ONLY THE IDENTICAL CONFIGURATIONS
;    
;    ; DECLARE A VECTOR THAT CONTAINS -1 FOR A RECIPROCAL GEOMETRY MATCH AND 1 FOR AN IDENTICAL GEOMETRY MATCH
;    ; 
;    ; GEOMETRICAL_CONFIG=MATCHING_GEOMETRIES[WHERE(MATCHING_GEOMETRIES NE 0)]
;    GEOMETRICAL_CONFIG=MATCHING_GEOMETRIES[WHERE(MATCHING_GEOMETRIES EQ 1)] ; WE CHOSE ONLY THE IDENTICAL CONFIGURATIONS
;    
;  ENDIF
;  
;  ; IF WE HAVE VALID ACQUISITION THEN WE START TRYING TO MODEL THEM
;  IF N_ELEMENTS(INDEX_VALID) GT 1 THEN BEGIN 
;  
;      FILTERED_SENSOR_L1B_REF=SENSOR_L1B_REF[*,INDEX_VALID]
;      
;      ;COMPUTE THE NUMBER OF ACQUISITIONS
;      N_ACQUISITIONS=N_ELEMENTS(FILTERED_SENSOR_L1B_REF[0,*])
;      
;      ;DEFINE THE SIMULATED SENSOR AND A VECTOR THAT CONTAINS THE STANDARD DEVIATION FROM THE MC COMPUTATION
;      SIMUL_FILTERED_SENSOR_L1B_REF=FILTERED_SENSOR_L1B_REF
;      SIMUL_FILTERED_SENSOR_L1B_REF_STD=FLTARR(N_ACQUISITIONS)
;
;
;;BAH THIS TEMPLATE IS THE ONE PROVIDED BY MB (SRC) 
;     ;READ THE TEMPLATE FOR THE SPECTRAL RESPONSE ASCII FILE (RSR ARE FROM DIMITRI)
;      RSR_TEMPLATE  = GET_DIMITRI_RSR_TEMPLATE()
;      
;      ; DEFINE NAME OF THE SPECTRAL RESPONSE FILE
;      FILTER_FILENAME=MAIN_DIRC+'/AUX_DATA/spectral_response/'+SENSOR+'/RSR_'+SENSOR+'_BAND_'+STRTRIM(SPECTRAL_BAND-1, 2)+'.txt'
;      
;      ; READ THE SPECTRAL RESPONSE
;      SPECTRAL_RESPONSE=READ_ASCII(FILTER_FILENAME, TEMPLATE=RSR_TEMPLATE)
;     
;      ; ASSIGN MIN AND MAX WAVELENGHT OF SPECTRAL REPONSE TO THE VARIABLE USED TO DEFINE THE INTERVAL OF THE SIMULATION
;      WAVELENGTH_MIN=MIN(SPECTRAL_RESPONSE.WAVELENGTH)
;      WAVELENGTH_MAX=MAX(SPECTRAL_RESPONSE.WAVELENGTH)
;      
;;BAH THE RPV-TEMPLATE IS THE ONE PROVIDD BY M.B. (SRC) 
;       ; WE ONLY PROCEEED IF THE WAVELENGTH_MIN AND WAVELENGTH_MAX ARE WITHIN THE RANGE OF THE RPV SPECTRAL MODEL DEFINITION
;      RESTORE, MAIN_DIRC+'/AUX_DATA/PICS_BRDF_data/template_to_read_RPV_model_files_in_IDL.sav'
;      RPV_MODEL=READ_ASCII(MAIN_DIRC+'/AUX_DATA/PICS_BRDF_data/'+SITE+'_interpolated_RPV_model.txt', TEMPLATE=TEMPLATE_RPV)
;      WAVELENGTH_RPV_MIN=MIN(RPV_MODEL.FIELD1)
;      WAVELENGTH_RPV_MAX=MAX(RPV_MODEL.FIELD1)
;     
;      IF (WAVELENGTH_MIN GT WAVELENGTH_RPV_MIN) AND (WAVELENGTH_MAX LT WAVELENGTH_RPV_MAX) THEN BEGIN
;      
;          ; DEFINE A VECTOR THAT CONTAINS THE STATE OF THE CPU (RUNNING=1, AVAILABLE=0)
;          STATE_CPU=FLTARR(MAX_CPU)
;          DONE_CPU=FLTARR(MAX_CPU)
;          ACQUISITION_NB_PROCESSED_BY_CPU=FLTARR(MAX_CPU)
;          
;          ; DEFINE A ARRAY WHERE THE FILES BEING GENERATED BY MYSTIC ARE STORED
;          FILES_BEING_GENERATED=STRARR(MAX_CPU)+'null'
;        
;          PRINT, 'SIMULATING DATA FROM BAND ', SPECTRAL_BAND
;          
;          
;          ; REMOVE ALL PREVIOUS SIMULATION OUTPUTS
;          MC_BASENAME='mc_simulation_cpu_'
;          SIMULATION_OUTPUT_FILES=FILE_SEARCH(MAIN_DIRC+'/Temp_sim_files/'+MC_BASENAME+'*')
;          IF N_ELEMENTS(SIMULATION_OUTPUT_FILES) GT 1 THEN FOR I_FILE=0, N_ELEMENTS(SIMULATION_OUTPUT_FILES)-1 DO SPAWN, 'rm '+SIMULATION_OUTPUT_FILES[I_FILE]
;        
;          
;          ; INTIALIZE THE COUNTER FOR THE NUMBER OF ACQUISTIONS TO BE SIMULATED
;          I_ACQUISITION=0
;          
;          ; DEFINE TIME STAMPS USED TO MONITOR PERFORMANCE
;          SYS_TIMER_1=SYSTIME(/SECONDS)
;          DELTA_TIME=0
;
;          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;          ; START LOOPING ON THE OBSERVATIONS AND SIMULATE THEM
;          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;          WHILE I_ACQUISITION LT N_ACQUISITIONS  DO BEGIN
;            
;
;            
;            ; IF THERE ARE CPU AVAILABLE WE LAUNCH A SIMULATION ON THE NEXT OBSERVATION
;            IF TOTAL(STATE_CPU) LT MAX_CPU THEN BEGIN
;            
;            
;              ; DISPLAY THE TIME BETWEEN TWO SIMULATIONS
; ;             IF ((((I_ACQUISITION*100./N_ACQUISITIONS) MOD 1)) EQ 0) THEN  
;              PRINT, 'DONE ', STRTRIM(I_ACQUISITION*100./N_ACQUISITIONS,2), ' % OF THE JOB. LAST SIMULATION STARTED  '+ STRTRIM(DELTA_TIME,2)+' SECONDS AGO'
;              PRINT, 'DONE ', STRTRIM(I_ACQUISITION*100./N_ACQUISITIONS,2), ' % OF THE JOB. LAST SIMULATION STARTED  '+ STRTRIM(DELTA_TIME,2)+' SECONDS AGO'
;              PRINT, 'NB CPUS BUSY: ', TOTAL(STATE_CPU)
;              
;               ; AVAILABLE CPU
;               AVAIL_CPU_INDEX=WHERE(STATE_CPU EQ 0)
;           
;              ;BEFORE STARTING, WE MAKE SURE THE OZONE AND WATER VAPOUR ARE AVAILABLE IN THE FILE OTHERWIZE WE FILL UP WITH DUMMY VALUES
;              IF FILTERED_SENSOR_L1B_REF[5,I_ACQUISITION] EQ -999 THEN OZONE=300 ELSE OZONE=FILTERED_SENSOR_L1B_REF[5,I_ACQUISITION]
;          
;              ; GET THE WATER VAPOUR VALUE
;              IF FILTERED_SENSOR_L1B_REF[15,I_ACQUISITION] EQ -999 THEN WV=20 ELSE WV=FILTERED_SENSOR_L1B_REF[15,I_ACQUISITION]    
;          
;              
;              ; COMPUTE THE AOT SCALING FACTOR WHICH IS AOT_550 / AOT_550_HESS_MODEL
;              IF AERO_TYPE EQ 'continental_average' THEN AOT_550_HESS_MODEL=0.107539; VALUES FOR THE CONTINENTAL_AVERAGE
;              IF AERO_TYPE EQ 'desert' THEN AOT_550_HESS_MODEL=0.246745; VALUE FOR THE DESERT
;              AOT_SCALING_FACTOR=AOT_550/AOT_550_HESS_MODEL
;          
;          
;              ; Run Mystic with all inputs
;              IF KEYWORD_SET(VERBOSE) THEN PRINT,FCT_NAME+': RUN MYSTIC MODEL'
;              INPUT_FILE = MAIN_DIRC+'/Temp_sim_files/'+MC_BASENAME+STRTRIM(AVAIL_CPU_INDEX[0], 2)+'.input'
;              WRITE_MYSTIC_RPV_INPUT, INPUT_FILE, MC_BASENAME+STRTRIM(AVAIL_CPU_INDEX[0], 2), PHOTON_NB, WAVELENGTH_MIN, WAVELENGTH_MAX, $ 
;                FILTERED_SENSOR_L1B_REF[3,I_ACQUISITION], FILTERED_SENSOR_L1B_REF[4,I_ACQUISITION],FILTERED_SENSOR_L1B_REF[1,I_ACQUISITION], $ 
;                FILTERED_SENSOR_L1B_REF[2,I_ACQUISITION]-180., 0, 0, 0, 0, OZONE, WV, AOT_SCALING_FACTOR, AERO_TYPE, $ 
;                RPV_FILE=MAIN_DIRC+'/AUX_DATA/PICS_BRDF_data/'+SITE+'_interpolated_RPV_model.txt'
;
;
;
;             SPAWN, 'uvspec < '+INPUT_FILE+' >/dev/null  &', /sh        
;              
;              ; UPDATE THE LIST OF FILES BEING PROCESSED AND CPU STATE
;              STATE_CPU[AVAIL_CPU_INDEX[0]]=1
;              
;              ; ASSIGN TO THE CPU THE ACQUISTION NUMBER
;              ACQUISITION_NB_PROCESSED_BY_CPU[AVAIL_CPU_INDEX[0]]=I_ACQUISITION
;              
;              ; STORE FILENAME OF FILE BEING PROCESSED
;              FILES_BEING_GENERATED[AVAIL_CPU_INDEX[0]]=MC_BASENAME+STRTRIM(AVAIL_CPU_INDEX[0], 2)+'.rad.spc'
;          
;              I_ACQUISITION=I_ACQUISITION+1
;           ENDIF 
;                                
;            ; FIND OUT WHICH THREADS ARE DONE
;            FOR I_CPU=0, MAX_CPU-1 DO IF FILE_SEARCH(FILES_BEING_GENERATED[I_CPU]) NE  '' THEN DONE_CPU[I_CPU]=1
;            
;            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;            ; READ OUTPUT FOR ALL THREADS THAT ARE FINISHED
;            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;            FOR I_CPU=0, MAX_CPU-1 DO BEGIN
;              IF DONE_CPU[I_CPU] EQ 1 THEN BEGIN
;              
;                ; COMPUTE AND DISPLAY THE TIME BETWEEN TWO SIMULATIONS
;                DELTA_TIME=SYSTIME(/SECONDS)-SYS_TIMER_1
;                SYS_TIMER_1=SYSTIME(/SECONDS)
;                
;                ; READ THE SIMULATINO RESULT
;                RHO_TOA=READ_MYSTIC_OUTPUT(FILES_BEING_GENERATED[I_CPU])
;                
;                ; READ THE STANDARD DEVIATION ASSOCIATED TO THE SIMULATION
;                RHO_TOA_STD=READ_MYSTIC_OUTPUT(STRMID(FILES_BEING_GENERATED[I_CPU], 0, STRPOS(FILES_BEING_GENERATED[I_CPU], '.rad.spc'))+'.rad.std.spc')
;               
;                
;                ; CONVOLUTION OF THE SPECTRAL RESPONSE AND THE SIMULATE SIGNAL
;                ; WE SAMPLE THE SIGNAL AND THE SPECTRAL RESPONSE AND A REGULAR INTERVAL SPECTRAL GRID AT 0.1 NM
;                
;                ; READ THE EXTRATERRESTRIAL SOLAR IRRADIANCE
;                SOLAR_SPECTRUM=READ_ASCII(MAIN_DIRC+'/AUX_DATA/solar_spectrum/Thuillier_2003_solar_irradiance.txt', DATA_START=1) ; in mW.m-2.nm-1
;                
;                SPECTRAL_RESOLUTION=0.1 ; IN NM
;                WAVELENGTH_GRID=INDGEN(CEIL((WAVELENGTH_MAX-WAVELENGTH_MIN)/SPECTRAL_RESOLUTION))*SPECTRAL_RESOLUTION+WAVELENGTH_MIN
;                RESAMPLED_SPECTRAL_RESPONSE=INTERPOL(SPECTRAL_RESPONSE.RESPONSE, SPECTRAL_RESPONSE.WAVELENGTH, WAVELENGTH_GRID)
;                RESAMPLED_RHO_TOA=INTERPOL(RHO_TOA[1,*], RHO_TOA[0,*],WAVELENGTH_GRID)
;                RESAMPLED_SOLAR_IRRADIANCE=INTERPOL(SOLAR_SPECTRUM.FIELD1[1,*], SOLAR_SPECTRUM.FIELD1[0,*],WAVELENGTH_GRID)
;                
;                ; CONVOLUTION OF THE SPECTRAL RESPONSE AND THE SIMULATE SIGNAL
;                SIMUL_FILTERED_SENSOR_L1B_REF[17+SPECTRAL_BAND-1, ACQUISITION_NB_PROCESSED_BY_CPU[I_CPU]]=TOTAL(RESAMPLED_RHO_TOA*RESAMPLED_SOLAR_IRRADIANCE*RESAMPLED_SPECTRAL_RESPONSE)/TOTAL(RESAMPLED_SOLAR_IRRADIANCE*RESAMPLED_SPECTRAL_RESPONSE)
;    
;                ; COMPUTE THE MEAN STANDARD DEVIATION OVER ALL 1 NM MONOCHROMATIC COMPUTATIONS 
;                SIMUL_FILTERED_SENSOR_L1B_REF_STD[ACQUISITION_NB_PROCESSED_BY_CPU[I_CPU]]=MEAN(RHO_TOA_STD[1,*])/SQRT(N_ELEMENTS(RHO_TOA_STD[1,*]))
;                
;                ;REMOVE THE SIMULATION OUTPUT
;                SPAWN, ['rm',FILES_BEING_GENERATED[I_CPU]], /noshell
;    
;                FILES_BEING_GENERATED[I_CPU]='DONE'
;                STATE_CPU[I_CPU]=0
;                DONE_CPU[I_CPU]=0
;              ENDIF
;            ENDFOR
;          
;          ENDWHILE
;
;          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;          ; READ THE LAST SIMULATIONS THAT WERE GENERATED:
;          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;          FOR I_CPU=0, MAX_CPU-1 DO BEGIN
;            ; DO WE HAVE THE OUTPUT READY? IF YES, THEN SET STATE_CPU TO 0
;            IF STATE_CPU[I_CPU] EQ 1 THEN BEGIN
;              WHILE STATE_CPU[I_CPU] NE 0 DO  STATE_CPU[I_CPU]=FILE_SEARCH(FILES_BEING_GENERATED[I_CPU]) EQ ''
;            
;              ; READ THE OUTPUT
;              WAIT, .01 ; JUST TO MAKE SURE THE FILE IS WRITTEN TO THE END
;              RHO_TOA=READ_MYSTIC_OUTPUT(FILES_BEING_GENERATED[I_CPU])
;              
;              ; READ THE STANDARD DEVIATION ASSOCIATED TO THE SIMULATION
;              RHO_TOA_STD=READ_MYSTIC_OUTPUT(STRMID(FILES_BEING_GENERATED[I_CPU], 0, STRPOS(FILES_BEING_GENERATED[I_CPU], '.rad.spc'))+'.rad.std.spc')
;                        
;              ; CONVOLUTION OF THE SPECTRAL RESPONSE AND THE SIMULATE SIGNAL
;              ; WE SAMPLE THE SIGNAL AND THE SPECTRAL RESPONSE AND A REGULAR INTERVAL SPECTRAL GRID AT 0.1 NM
;              ; READ THE EXTRATERRESTRIAL SOLAR IRRADIANCE
;              SOLAR_SPECTRUM=READ_ASCII(MAIN_DIRC+'/AUX_DATA/solar_spectrum/Thuillier_2003_solar_irradiance.txt', DATA_START=1) ; in mW.m-2.nm-1
;              SPECTRAL_RESOLUTION=0.1 ; IN NM
;              WAVELENGTH_GRID=INDGEN(CEIL((WAVELENGTH_MAX-WAVELENGTH_MIN)/SPECTRAL_RESOLUTION))*SPECTRAL_RESOLUTION+WAVELENGTH_MIN
;              RESAMPLED_SPECTRAL_RESPONSE=INTERPOL(SPECTRAL_RESPONSE.RESPONSE, SPECTRAL_RESPONSE.WAVELENGTH, WAVELENGTH_GRID)
;              RESAMPLED_RHO_TOA=INTERPOL(RHO_TOA[1,*], RHO_TOA[0,*],WAVELENGTH_GRID)
;              RESAMPLED_SOLAR_IRRADIANCE=INTERPOL(SOLAR_SPECTRUM.FIELD1[1,*], SOLAR_SPECTRUM.FIELD1[0,*],WAVELENGTH_GRID)
;                
;              ; CONVOLUTION OF THE SPECTRAL RESPONSE AND THE SIMULATE SIGNAL
;              SIMUL_FILTERED_SENSOR_L1B_REF[17+SPECTRAL_BAND-1, ACQUISITION_NB_PROCESSED_BY_CPU[I_CPU]]=TOTAL(RESAMPLED_RHO_TOA*RESAMPLED_SOLAR_IRRADIANCE*RESAMPLED_SPECTRAL_RESPONSE)/TOTAL(RESAMPLED_SOLAR_IRRADIANCE*RESAMPLED_SPECTRAL_RESPONSE)
;                     
;              ; COMPUTE THE MEAN STANDARD DEVIATION OVER ALL 1 NM MONOCHROMATIC COMPUTATIONS 
;              SIMUL_FILTERED_SENSOR_L1B_REF_STD[ACQUISITION_NB_PROCESSED_BY_CPU[I_CPU]]=MEAN(RHO_TOA_STD[1,*])/SQRT(N_ELEMENTS(RHO_TOA_STD[1,*]))
;              
;              ;REMOVE THE SIMULATION OUTPUT
;              SPAWN, ['rm',FILES_BEING_GENERATED[I_CPU]], /noshell
;              
;              FILES_BEING_GENERATED[I_CPU]='DONE'
;           ENDIF 
;            
;          ENDFOR
;        
;          ; START FILTERING PROCESS BY WHICH ALL ACQUISTIONS FOR WHICH THE RELATIVE DIFFERENCE TO THE SIMULATION DIFFERS BY MORE THAT 3-SIGMA ARE DISCARDED
;          ;BAH: FINITE IS ADDED HERE TO AVOID NAN AND -NAN VALUES
;          RELATIVE_DIFF=(FILTERED_SENSOR_L1B_REF[16+SPECTRAL_BAND,*]-SIMUL_FILTERED_SENSOR_L1B_REF[16+SPECTRAL_BAND,*])/SIMUL_FILTERED_SENSOR_L1B_REF[16+SPECTRAL_BAND,*]*100.
;          STDDEV=STDDEV(RELATIVE_DIFF[WHERE(FINITE(RELATIVE_DIFF) EQ 1)])  
;          BIAS=MEAN(RELATIVE_DIFF[WHERE(FINITE(RELATIVE_DIFF) EQ 1)])    
;          FILTERED_FILTERED_SENSOR_L1B_REF=FILTERED_SENSOR_L1B_REF
;          FILTERED_SIMUL_FILTERED_SENSOR_L1B_REF=SIMUL_FILTERED_SENSOR_L1B_REF
;          FILTERED_SIMUL_FILTERED_SENSOR_L1B_REF_STD=SIMUL_FILTERED_SENSOR_L1B_REF_STD
;         
;          ;DO SOME 3-SIGMA FILTERING  
;          FOR I=0, 1 DO BEGIN 
;            INDEX_SORTED=WHERE((RELATIVE_DIFF LT BIAS+3.*STDDEV) AND (RELATIVE_DIFF GT BIAS-3.*STDDEV))
;            FILTERED_FILTERED_SENSOR_L1B_REF=FILTERED_FILTERED_SENSOR_L1B_REF[*,INDEX_SORTED]
;            GEOMETRICAL_CONFIG=GEOMETRICAL_CONFIG[INDEX_SORTED]
;            FILTERED_SIMUL_FILTERED_SENSOR_L1B_REF=FILTERED_SIMUL_FILTERED_SENSOR_L1B_REF[*,INDEX_SORTED]
;            FILTERED_SIMUL_FILTERED_SENSOR_L1B_REF_STD=FILTERED_SIMUL_FILTERED_SENSOR_L1B_REF_STD[INDEX_SORTED]
;            RELATIVE_DIFF=(FILTERED_FILTERED_SENSOR_L1B_REF[16+SPECTRAL_BAND,*]-FILTERED_SIMUL_FILTERED_SENSOR_L1B_REF[16+SPECTRAL_BAND,*])/FILTERED_SIMUL_FILTERED_SENSOR_L1B_REF[16+SPECTRAL_BAND,*]*100.
;            LINEAR_REGRESSION_COEF = POLY_FIT(FILTERED_FILTERED_SENSOR_L1B_REF[0,*], RELATIVE_DIFF, 1, SIGMA=SIGMA)
;            TREND_UNCERTAINTY=SIGMA[1]
;            STDDEV=STDDEV(RELATIVE_DIFF)
;            BIAS=MEAN(RELATIVE_DIFF)
;          ENDFOR
;         
;          
;          !P.MULTI=0
;          LOADCT, 39
;          PLOT,FILTERED_FILTERED_SENSOR_L1B_REF[0,*], RELATIVE_DIFF, BACKGROUND=255, YRANGE=[-20, 20], COLOR=0, CHARSIZE=1.5, CHARTHICK=1, XTITLE='DECIMAL YEAR', YTITLE='(rho_toa-rho_toa_sim)/rho_toa_sim x 100', $
;            TITLE=SENSOR+' (' +PROC_VER+') simulations in band '+STRTRIM(SPECTRAL_BAND,2)+' @ '+STRTRIM(BAND_WAVELENGTH[SPECTRAL_BAND-1],2)+' nm', PSYM=1
;          ; PLOT THE 1-SIGMA MC NOISE 
;          LOADCT, 0
;          OPLOTERROR,FILTERED_FILTERED_SENSOR_L1B_REF[0,*], RELATIVE_DIFF ,FILTERED_SIMUL_FILTERED_SENSOR_L1B_REF_STD/FILTERED_SIMUL_FILTERED_SENSOR_L1B_REF[16+SPECTRAL_BAND,*]*100., COLOR=0, PSYM=1, ERRCOLOR=200, ERRSTYLE=0
;          LOADCT, 39
;          OPLOT,FILTERED_FILTERED_SENSOR_L1B_REF[0,*], RELATIVE_DIFF, COLOR=0, PSYM=1
;          
;          ; PLOT THE SIMULATIONS FOR WHICH A RECIPROCAL GEOMETRY WAS USED
;          IF N_ELEMENTS(WHERE(GEOMETRICAL_CONFIG EQ -1)) GT 1 THEN OPLOT, FILTERED_FILTERED_SENSOR_L1B_REF[0,WHERE(GEOMETRICAL_CONFIG EQ -1)], RELATIVE_DIFF[WHERE(GEOMETRICAL_CONFIG EQ -1)],COLOR=50, PSYM=1
;          ; PLOT THE LINEAR REGRESSION
;          OPLOT,1900.+INDGEN(200), LINEAR_REGRESSION_COEF[0]+LINEAR_REGRESSION_COEF[1]* (1900.+INDGEN(200)), COLOR=50, LINE=0
;          OPLOT, 1900.+INDGEN(200), LINEAR_REGRESSION_COEF[0]+LINEAR_REGRESSION_COEF[1]* (1900.+INDGEN(200))+2.*STDDEV, COLOR=250
;          OPLOT, 1900.+INDGEN(200), LINEAR_REGRESSION_COEF[0]+LINEAR_REGRESSION_COEF[1]* (1900.+INDGEN(200))-2.*STDDEV, COLOR=250
;          
;          ; PRINT OUT STATISTICS
;          XYOUTS, 140, 820, 'Nb of simulations: '+STRMID(N_ELEMENTS(RELATIVE_DIFF),2),/DEVICE, COLOR=250, CHARSIZE=1.5
;          XYOUTS, 140, 800, 'Linear trend: '+ STRING(LINEAR_REGRESSION_COEF[1], FORMAT='(F6.2)')+' % / year'+' (95 % CI => +/-'+STRING(2.*TREND_UNCERTAINTY, FORMAT='(F6.2)')+' %'+' w/ norm. assump.)' , /DEVICE, COLOR=250, CHARSIZE=1.5
;          XYOUTS, 140, 780, 'Mean bias in % on 2008/01/01:  '+STRING( LINEAR_REGRESSION_COEF[0]+LINEAR_REGRESSION_COEF[1]*2008., FORMAT='(F6.2)')+' %'+' (95 % CI => +/-'+STRING(2.*STDDEV/SQRT(N_ELEMENTS(RELATIVE_DIFF)), FORMAT='(F6.2)')+' %'+' w/ norm. assump.)', /DEVICE, COLOR=250, CHARSIZE=1.5
;          XYOUTS, 140, 760, 'Standard deviation in %: '+STRING(STDDEV, FORMAT='(F6.2)')+' %',/DEVICE, COLOR=250, CHARSIZE=1.5
;          XYOUTS, 140, 740, 'Mean MYSTIC 1-sigma noise per sim: '+STRING(MEAN(FILTERED_SIMUL_FILTERED_SENSOR_L1B_REF_STD/FILTERED_SIMUL_FILTERED_SENSOR_L1B_REF[16+SPECTRAL_BAND,*]*100.), FORMAT='(F6.2)')+' %',/DEVICE, COLOR=250, CHARSIZE=1.5
;          ; PRINT MEAN DIFFERENCE BETWEEN RECIPROCAL AND IDENTICAL GEOMETRIES
;          IF N_ELEMENTS(WHERE(GEOMETRICAL_CONFIG EQ -1)) GT 1 THEN XYOUTS, 140, 720, 'Bias reciprocal - bias identical in %: '+STRING(MEAN(RELATIVE_DIFF[WHERE(GEOMETRICAL_CONFIG EQ -1)])-MEAN(RELATIVE_DIFF[WHERE(GEOMETRICAL_CONFIG EQ 1)]), FORMAT='(F6.2)')+ $
;          ' % (95 % CI => +/-'+STRING(2.*STDDEV(RELATIVE_DIFF[WHERE(GEOMETRICAL_CONFIG EQ -1)])/SQRT(N_ELEMENTS(RELATIVE_DIFF[WHERE(GEOMETRICAL_CONFIG EQ -1)])), FORMAT='(F6.2)') $
;          +'% and '+STRING(2.*STDDEV(RELATIVE_DIFF[WHERE(GEOMETRICAL_CONFIG EQ 1)])/SQRT(N_ELEMENTS(RELATIVE_DIFF[WHERE(GEOMETRICAL_CONFIG EQ 1)])), FORMAT='(F6.2)')+'% w/ norm. assump.)',/DEVICE, COLOR=250, CHARSIZE=1.5
;          
;          ; WRITE PLOT TO .JPG  
;          WRITE_JPEG, OUTPUT_FOLDER+'/Plot_sim_vs_true_'+SENSOR+'_Proc_'+PROC_VER+'_'+SITE+'_band_'+STRTRIM(SPECTRAL_BAND, 2)+'.jpeg',TVRD(TRUE=3), TRUE=3, QUALITY=100
;            
;          ; SAVE THE FILTERED SIMULATED SENSOR DATA
;          SAVE, FILTERED_SIMUL_FILTERED_SENSOR_L1B_REF, FILENAME=OUTPUT_FOLDER+'/Plot_sim_vs_true_'+SENSOR+'_Proc_'+PROC_VER+'_'+SITE+'_band_'+STRTRIM(SPECTRAL_BAND, 2)+'.sav'
;                    
;          ;;;;;;;;;;;;;;;;;;;;;
;          ; PREPARE PLOT SHOWING RESIDUAL ERROR ANALYSIS
;          ;;;;;;;;;;;;;;;;;;;;;
;          
;          !P.MULTI=[0,2,3]
;          
;          ; COMPUTE RESIDUAL ERROR HISTOGRAM
;          HISTO=HISTOGRAM(RELATIVE_DIFF, NBINS=N_ACQUISITIONS/5, LOCATIONS=ERRORS)
;          
;          PLOT,ERRORS, HISTO , BACKGROUND=255, COLOR=0, CHARSIZE=1.5, CHARTHICK=1, XTITLE='(obs-sim)/sim in %' , YTITLE='Frequency in # acquisitions', TITLE='Histogram of (obs-sim)/sim - Band '+STRING(SPECTRAL_BAND, FORMAT='(I2)')
;          XYOUTS, 100, 840, 'Mean bias in %          :  '+STRING(BIAS , FORMAT='(F10.2)')+' %', /DEVICE, COLOR=250, CHARSIZE=1.5
;          XYOUTS, 100, 820, 'Standard deviation in % : '+STRING(STDDEV, FORMAT='(F10.2)')+' %',/DEVICE, COLOR=250, CHARSIZE=1.5
;          
;          ;COMPUTE CORRESPONDING NORMAL DISTRIBUTION
;          NORMAL_DISTRIBUTION=1./STDDEV/SQRT(2*!PI)*EXP(-0.5*((ERRORS-BIAS)/STDDEV)^2)
;          OPLOT, ERRORS, NORMAL_DISTRIBUTION*TOTAL(HISTO)/TOTAL(NORMAL_DISTRIBUTION), COLOR=50, LINE=0
;          
;          PLOT, FILTERED_FILTERED_SENSOR_L1B_REF[1,*], RELATIVE_DIFF, COLOR=0, CHARSIZE=1.5, CHARTHICK=1, XTITLE='VZA in degrees' , YTITLE='(obs-sim)/sim in %', TITLE='(obs-sim)/sim vs. VZA - Band '+STRING(SPECTRAL_BAND, FORMAT='(I2)'), PSYM=1
;          XYOUTS, 750, 840, 'r^2 :  '+STRING((CORRELATE(FILTERED_FILTERED_SENSOR_L1B_REF[1,*], RELATIVE_DIFF) )^2, FORMAT='(F5.2)'), /DEVICE, COLOR=250, CHARSIZE=1.5
;          
;          
;          PLOT, FILTERED_FILTERED_SENSOR_L1B_REF[3,*], RELATIVE_DIFF, COLOR=0, CHARSIZE=1.5, CHARTHICK=1, XTITLE='SZA in degrees' , YTITLE='(obs-sim)/sim in %', TITLE='(obs-sim)/sim vs. SZA - Band '+STRING(SPECTRAL_BAND, FORMAT='(I2)'), PSYM=1
;          XYOUTS, 100, 540, 'r^2 :  '+STRING((CORRELATE(FILTERED_FILTERED_SENSOR_L1B_REF[3,*], RELATIVE_DIFF) )^2, FORMAT='(F5.2)'), /DEVICE, COLOR=250, CHARSIZE=1.5
;          
;          
;          
;          PLOT, (FILTERED_FILTERED_SENSOR_L1B_REF[4,*]-FILTERED_FILTERED_SENSOR_L1B_REF[2,*]), RELATIVE_DIFF, COLOR=0, CHARSIZE=1.5, CHARTHICK=1, XTITLE='dPhi in degrees' , YTITLE='(obs-sim)/sim in %', title='(obs-sim)/sim vs. dPhi - Band '+STRING(SPECTRAL_BAND, FORMAT='(I2)'), PSYM=1
;          XYOUTS, 750, 540, 'r^2 :  '+STRING((CORRELATE(FILTERED_FILTERED_SENSOR_L1B_REF[4,*]-FILTERED_FILTERED_SENSOR_L1B_REF[2,*], RELATIVE_DIFF) )^2, FORMAT='(F5.2)'), /DEVICE, COLOR=250, CHARSIZE=1.5
;          
;          
;          SCATT_ANGLE=180./!PI*ACOS(COS(FILTERED_FILTERED_SENSOR_L1B_REF[1,*]*!PI/180.)*COS(FILTERED_FILTERED_SENSOR_L1B_REF[3,*]*!PI/180.)+SIN(FILTERED_FILTERED_SENSOR_L1B_REF[1,*]*!PI/180.)*SIN(FILTERED_FILTERED_SENSOR_L1B_REF[3,*]*!PI/180.)*COS((FILTERED_FILTERED_SENSOR_L1B_REF[2,*]-FILTERED_FILTERED_SENSOR_L1B_REF[4,*])*!PI/180.))
;          SCATT_ANGLE=180-SCATT_ANGLE
;          PLOT, SCATT_ANGLE, RELATIVE_DIFF, COLOR=0, CHARSIZE=1.5, CHARTHICK=1, XTITLE='Scattering angle in degrees (BWD=180)' , YTITLE='(obs-sim)/sim in %', TITLE='(obs-sim)/sim vs. scatt angle - Band '+string(spectral_band, format='(I2)'), psym=1
;          XYOUTS, 100, 240, 'r^2 :  '+STRING((CORRELATE(SCATT_ANGLE, RELATIVE_DIFF) )^2, FORMAT='(F5.2)'), /DEVICE, COLOR=250, CHARSIZE=1.5
;          
;          
;;; PLOT THE SCATTERING ANGLE DISTRIBUTION
;;          HISTO=HISTOGRAM(SCATT_ANGLE, NBINS=N_ACQUISITIONS/5, LOCATIONS=ERRORS)
;;          PLOT,ERRORS, HISTO , BACKGROUND=255, COLOR=0, CHARSIZE=1.5, CHARTHICK=1, XTITLE='SCATT ANGLE IN DEGREES' , YTITLE='FREQUENCY IN # ACQUISITIONS', TITLE='SCATT ANGLE DISTRIBUTION - BAND '+STRING(SPECTRAL_BAND, FORMAT='(I2)')
;          
;          PLOT, FILTERED_FILTERED_SENSOR_L1B_REF[4,*], RELATIVE_DIFF, COLOR=0, CHARSIZE=1.5, CHARTHICK=1, XTITLE='Sun azimuth angle in degrees (BWD=180)' , YTITLE='(obs-sim)/sim in %', TITLE='(obs-sim)/sim vs. scatt angle - Band '+STRING(SPECTRAL_BAND, FORMAT='(I2)'), PSYM=1
;          XYOUTS, 750, 240, 'r^2 :  '+STRING((CORRELATE(FILTERED_FILTERED_SENSOR_L1B_REF[4,*], RELATIVE_DIFF) )^2, FORMAT='(F5.2)'), /DEVICE, COLOR=250, CHARSIZE=1.5
;          
;          
;          ;;;;;;;;;;;;;;;;;;;;;;;;
;          ; WRITE PLOT SHOWING THE INVERSION RESULTS TO A .JPG
;          ;;;;;;;;;;;;;;;;;;;;;;;;
;          WRITE_JPEG, OUTPUT_FOLDER+'/Plot_sim_vs_true_'+SENSOR+'_Proc_'+PROC_VER+'_'+SITE+'_band_'+STRTRIM(SPECTRAL_BAND, 2)+'_error_analysis.jpeg',TVRD(TRUE=3), TRUE=3, QUALITY=100
;          
;          ; SAVE THE STATISTICAL PARAMETERS ASSOCIATED TO EACH BAND TIME SERIES
;          SAVE, STDDEV, BIAS,LINEAR_REGRESSION_COEF,TREND_UNCERTAINTY, FILTERED_SIMUL_FILTERED_SENSOR_L1B_REF, FILTERED_SIMUL_FILTERED_SENSOR_L1B_REF_STD, FILENAME=OUTPUT_FOLDER+'/Plot_sim_vs_true_'+SENSOR+'_Proc_'+PROC_VER+'_'+SITE+'_band_'+STRTRIM(SPECTRAL_BAND, 2)+'_statistics.sav'
;                  
;      ENDIF ELSE PRINT, 'SPECTRAL BAND DEFINED OUTSIDE RPV SPECTRAL MODEL DOMAIN...'
;  ENDIF ELSE PRINT,'THERE ARE NO ACQUISTIONS TO SIMULATE...'      
;  
;ENDFOR   
;
;;-----------------------------------------------
;; RETURN DEVISE WINDOW TO NOMINAL SETTING
;
;IF KEYWORD_SET(VERBOSE) THEN PRINT, FCT_NAME+': PLOT OR RESETTING DEVICE WINDOW PROPERTIES'
;
;IF KEYWORD_SET(DISPLAY_PLOT) THEN PRINT, '' ELSE  SET_PLOT, 'X'
;
;IF KEYWORD_SET(VERBOSE) THEN PRINT, FCT_NAME+': SUCCESSFULL'
;
;RETURN,1
;
;END
;
