;**************************************************************************************
;**************************************************************************************
;*
;* NAME:
;*      SIMULATE_TOA_TIME_SERIES
;* 
;* PURPOSE:
;*      SIMULATING A TOA SERIES FROM A GIVEN SENSOR AS GIVEN BY
;*      DIMITRI FOR NON CLAUDY OBSERVATIONS FOLLOWING M. BOUVET 2011
;* 
;* CALLING SEQUENCE:
;*      RES = SIMULATE_TOA_TIME_SERIES(OUTPUT_FOLDER, SITE, SENSOR, PROC_VER, YEAR, PHOTON_NB, CPU_NB)
;* 
;* INPUTS:
;*      OUTPUT_FOLDER    - THE FULL PATH OF THE OUTPUT FOLDER
;*      SITE             - THE VALIDATION SITE NAME E.G. 'Libya4'
;*      SENSOR           - THE NAME OF THE SENSOR E.G. 'PARASOL'
;*      PROC_VER         - THE PROCESSING VERSION OF THE SENSOR
;*      YEAR             - THE YEAR E.G. 2003 OR 'ALL'
;*	    PHOTON_NB        - THE NUMBER OF PHOTONS USED FOR THE SIMULATION (DEFALT VALUE IS 1500)
;*	    CPU_NB           - THE NUMBER OF PARALLEL JOBS/CPUS (DEFALT VALUE IS 1)
;*
;* KEYWORDS:
;*      CONSOLIDATE      - ALLOWS SUBSTITUTING THE L1 AUX O3 AND WV DATA BY ERA-INTERIM CORRESPONDING DATA
;*      DISPLAY_PLOT     - ALLOW DISPLAYING RESULTS ON THE SCREEN
;*      VERBOSE          - PROCESSING STATUS OUTPUTS
;*
;* OUTPUTS:
;*      STATUS          - 1: NO ERRORS REPORTED, (-1) OR 0: ERRORS DURING SIMULATION 
;*
;* COMMON BLOCKS:
;*      NON
;*
;* MODIFICATION HISTORY:
;*        21 SEP 2014  - M BOUVET - FIRST DEVELOPEMENT OF THE METHODOLOGY
;*        15 JAN 2015  - B ALHAMMOUD - FIRST IMPLEMENTATION TO DIMITRI-V3.1a
;*
;* VALIDATION HISTORY:
;*        21 JAN 2015 -  B ALHAMMOUD - LINUX 64-BIT MACHINE IDL 8.2, NOMINAL COMPILATION AND OPERATION.
;*                                  TESTED FOR PARASOL OVER LIBYA4
;*
;**************************************************************************************
;**************************************************************************************

FUNCTION simulate_toa_time_series, output_folder, site,  sensor, proc_ver, year, photon_nb, cpu_nb, consolidated=consolidated, display_plot=display_plot, verbose=VERBOSE


;-----------------------------------------
; DEFINE CURRENT FUNCTION NAME

  FCT_NAME  = 'simulate_TOA_time_series'

;-----------------------------------------
; DEFINE INPUT/OUTPUT FILES AND DIRECTORIES

  IF KEYWORD_SET(VERBOSE) THEN PRINT,FCT_NAME+': DEFINING INPUT/OUTPUT FILES'
  SITE_FILE  = GET_DIMITRI_LOCATION('SITE_DATA')
  BANDS_FILE = GET_DIMITRI_LOCATION('BAND_NAME')
  DB_FILE    = GET_DIMITRI_LOCATION('DATABASE')
  MAIN_DIRC  = GET_DIMITRI_LOCATION('DIMITRI')
  IFILE      = FILEPATH(ROOT_DIR=MAIN_DIRC, SUBDIRECTORY=['Input','Site_'+SITE,SENSOR,'Proc_'+PROC_VER], SENSOR+'_TOA_REF.dat')

;-----------------------------------------
; CHECK DIMITRI DATABASE EXISTS

  TEMP = FILE_INFO(DB_FILE)
  IF TEMP.EXISTS EQ 0 THEN BEGIN
    PRINT, FCT_NAME+': ERROR, DIMITRI DATABASE FILE DOES NOT EXIST'
    STOP
  ENDIF

;--------------------------------
; CREATE OUTPUT FOLDER IF IT DOESN'T EXIST

  RES = FILE_INFO(OUTPUT_FOLDER)
  IF RES.EXISTS NE 1 OR RES.DIRECTORY NE 1 THEN BEGIN
    IF KEYWORD_SET(VERBOSE) THEN PRINT,FCT_NAME+": OUTPUT FOLDER DOESN'T EXIST, CREATING"
    FILE_MKDIR,OUTPUT_FOLDER
  ENDIF
  
;---------------------------
; IF KEYWORD_SET(VERBOSE) THEN PRINT,FCT_NAME+': LOOKING FOR BEST AEROSOL TYPE AND TOA THAT WERE OBTAINED DURING THE BRDF INVERSION BASED ON MERIS MEASUREMENT IN BAND 412'

RESTORE, MAIN_DIRC+'/AUX_DATA/PICS_BRDF_data/template_aero_data.sav'
BEST_AEROSOL=READ_ASCII(MAIN_DIRC+'/AUX_DATA/PICS_BRDF_data/'+SITE+'_aero_data.txt', TEMPLATE=TEMPLATE_AERO_DATA)
AERO_TYPE=BEST_AEROSOL.FIELD1
AOT_550=BEST_AEROSOL.FIELD2

; DEFINE THE NUMBER OF PARALLEL JOBS/CPUS
MAX_CPU=!CPU.HW_NCPU
;MAX_CPU=4
IF (CPU_NB NE 0 ) AND ( CPU_NB LT MAX_CPU) THEN BEGIN
   MAX_CPU=CPU_NB
ENDIF

; DEFINE THE NUMBER OF PHOTON PER SIMULATION
;BAH PHOTON_NB=1500

; GRAPHIC SETTINGS
IF KEYWORD_SET(DISPLAY_PLOT) THEN BEGIN
  WINDOW, 10,RETAIN=2, XSIZE=1200, YSIZE=900
  DEVICE, DECOMPOSED=0
ENDIF ELSE BEGIN
  SET_PLOT, 'Z'
  DEVICE, DECOMPOSED=0, SET_RESOLUTION=[1200, 900],SET_PIXEL_DEPTH=24
ENDELSE



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; READ THE SENSOR DATA AND CONSOLIDATE THE METEO DATA IF NEEDED
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

FILENAME=MAIN_DIRC+'/Input/Site_'+SITE+'/'+SENSOR+'/Proc_'+PROC_VER+'/'+SENSOR+'_TOA_REF.dat'
IF KEYWORD_SET(CONSOLIDATED) THEN BEGIN
  ; IF A CONSOLIDATED FILE IS NOT YET PRESENT
  IF FILE_SEARCH(STRMID(FILENAME, 0, STRPOS(FILENAME, '.dat'))+'.consolidated.dat') EQ '' THEN BEGIN
    
;-----------------------------------------
; GET ROI COORDINATES
;-----------------------------------------
   ICOORDS = GET_SITE_COORDINATES(SITE,SITE_FILE,VERBOSE=VERBOSE)
     IF ICOORDS[0] EQ -1 THEN BEGIN
        PRINT,FCT_NAME+': ERROR, REGION COORDINATES NOT FOUND'
        STOP
     ENDIF

    LAT_ROI_center=(ICOORDS[0]+ICOORDS[1])/2.
    LON_ROI_center=(ICOORDS[2]+ICOORDS[3])/2.
   
    RESTORE, FILENAME

;BAH: I'LL CONSIDER THAT SENSOR_L1B_REF COMES FROM " RESTORE, FILENAME "
    
    TCO_TIME_SERIES=READ_ECMWF_INTERIM(SENSOR_L1B_REF[0,*], FLTARR(N_ELEMENTS(SENSOR_L1B_REF[0,*]))+LAT_ROI_CENTER, FLTARR(N_ELEMENTS(SENSOR_L1B_REF[0,*]))+LON_ROI_CENTER, 'TCO')
    WV_TIME_SERIES=READ_ECMWF_INTERIM(SENSOR_L1B_REF[0,*], FLTARR(N_ELEMENTS(SENSOR_L1B_REF[0,*]))+LAT_ROI_CENTER, FLTARR(N_ELEMENTS(SENSOR_L1B_REF[0,*]))+LON_ROI_CENTER, 'WV')
    
        
    SENSOR_L1B_REF[5,*]=TCO_TIME_SERIES
    SENSOR_L1B_REF[6,*]=-999
    
    SENSOR_L1B_REF[15,*]=WV_TIME_SERIES
    SENSOR_L1B_REF[16,*]=-999
    
    SAVE, SENSOR_L1B_REF, FILENAME=STRMID(FILENAME, 0, STRPOS(FILENAME, '.dat'))+'.consolidated.dat'
   ; IF A CONSOLIDATED FILE IS ALREADY AVAILABLE THEN WE JUST READ IT
   ENDIF ELSE RESTORE, STRMID(FILENAME, 0, STRPOS(FILENAME, '.dat'))+'.consolidated.dat'
; IF CONSOLIDATION WAS NOT REQUESTED, WE READ THE ORGINAL DATA FROM DIMITRI   
ENDIF ELSE RESTORE, FILENAME


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; READ THE DIMITRI DATABASE FILES
; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

IF KEYWORD_SET(VERBOSE) THEN PRINT,FCT_NAME+': READING DIMITRI DATABASE'
  DB_TEMPLATE = GET_DIMITRI_TEMPLATE(1,/TEMPLATE)
  DB_DATA     = READ_ASCII(DB_FILE,TEMPLATE=DB_TEMPLATE)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; SORT OUT THE DATA THAT ARE REQUESTED FROM THE DATABASE
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; SELECT DATA FOR WHICH THE SENSOR IS AS REQUESTED
 FLAG_REQUESTED=FLOAT(DB_DATA.SENSOR EQ SENSOR)

;; SELECT DATA FOR WHICH THE PROCESSING VERSION IS AS REQUESTED
 FLAG_REQUESTED=FLAG_REQUESTED*FLOAT(DB_DATA.PROCESSING_VERSION EQ PROC_VER)

;; SELECT DATA FOR WHICH THE SITE IS AS REQUESTED
 FLAG_REQUESTED=FLAG_REQUESTED*FLOAT(DB_DATA.REGION EQ SITE)

;; SELECT DATA FOR WHICH AUTOMATIC CLOUD SCREENING AND MANUAL CLOUD SCREENING GIVE NO CLOUD AT ALL
 FLAG_REQUESTED=FLAG_REQUESTED*FLOAT(((DB_DATA.AUTO_CS EQ 0) AND (DB_DATA.MANUAL_CS NE 1)) OR (DB_DATA.MANUAL_CS EQ 0))

;; SELECT DATA FOR WHICH THE YEAR IS AS REQUESTED
  CYEAR = STRTRIM(YEAR,2)
  IF CYEAR EQ 'ALL' THEN BEGIN
     PRINT, 'SELECTION IS DONE OVER '+CYEAR+' AVAILABLE YEARS'  ; IN FACT WE SKIP THE YEAR SELECTION HERE, AUTOMATICALY WE TAKE ALL THE DATES
  ENDIF ELSE BEGIN
     FLAG_REQUESTED=FLAG_REQUESTED*FLOAT(DB_DATA.YEAR EQ YEAR)
 ENDELSE

;; SELECT DATA FOR WHICH THE ROI IS FULLY COVERED
 FLAG_REQUESTED=FLAG_REQUESTED*FLOAT(DB_DATA.ROI_COVER EQ 1)

;; GET THE INDEX OF THE ACQUISITION REQUESTED IN THE DATABASE
 INDEX_REQUESTED_ACQUISTION=WHERE(FLAG_REQUESTED)

;; EXTRACT THE DECIMAL DATE OF THE CORRESPONDING SELECTED DATA
  GOOD_DATES=DB_DATA.DECIMAL_YEAR[INDEX_REQUESTED_ACQUISTION]


;;;;;;;;;;;;;
; START EXTRACTING THE DATA IN SENSOR_L1B_REF DATA THAT MATCH THE DECIMAL DATES EXTRACTED FROM THE DATABASE
;;;;;;;;;;;;;
GOOD_INDEX=FLTARR(N_ELEMENTS(SENSOR_L1B_REF[0,*]))

; DEFINE TOLERANCE BETWEEN THE DECIMAL DATES IN DIMITRI DB AND IN .DAT FILE CONTAINING THE DATA
TOL=0.00005

FOR I_DATES=0L, N_ELEMENTS(GOOD_DATES)-1 DO BEGIN
  DUMMY=WHERE(ABS(SENSOR_L1B_REF[0,*] - GOOD_DATES[I_DATES]) LE TOL)
  IF DUMMY[0] EQ -1 THEN BEGIN
    PRINT, MIN(ABS(SENSOR_L1B_REF[0,*] - GOOD_DATES[I_DATES]))
    PRINT, 'I CANNOT SEEM TO FIND ALL ACQUISITIONS IN THE FILES' +FILENAME
  ENDIF
  IF DUMMY[0] GT -1 THEN BEGIN
    GOOD_INDEX[DUMMY]=1
  ENDIF
ENDFOR

  
; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; READ THE SPECTRAL BANDS INFO CORRESPONDING TO THE SENSOR 
; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
IF KEYWORD_SET(VERBOSE) THEN PRINT,FCT_NAME+': READING Band_Names file'
SPECTRAL_BANDS_TEMPLATE = GET_DIMITRI_BAND_NAME_TEMPLATE()
BAND_NUMBERING  = READ_ASCII(MAIN_DIRC+'/Bin/DIMITRI_Band_Names.txt',TEMPLATE=SPECTRAL_BANDS_TEMPLATE)

; FIND OUT THE SENSOR IN THIS FILE
TNAMES=TAG_NAMES(BAND_NUMBERING)
DUMMY_INDEX=INTARR(N_TAGS(BAND_NUMBERING))
FOR I_TAGS=0, N_TAGS(BAND_NUMBERING)-1 DO BEGIN
  DUMMY_INDEX[I_TAGS]=STRCMP(TNAMES(I_TAGS), SENSOR)
ENDFOR

; EXTRACT THE BAND WAVELENGTH
BAND_WAVELENGTH=BAND_NUMBERING.(WHERE(DUMMY_INDEX EQ 1))[*]
BAND_WAVELENGTH=BAND_WAVELENGTH[WHERE(BAND_WAVELENGTH NE -2)]


N_BANDS=N_ELEMENTS(BAND_WAVELENGTH)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; SIMULATION OF THE REMOTE SENSING DATA
; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 
; START LOOPING ON EACH BAND
FOR SPECTRAL_BAND=1, N_BANDS DO BEGIN

;SELECT ONLY THE DATA WHERE THE REFLECTANCE IS VALID AND THE SZA AND VZA ARE WITHIN  THE DEFINITION RANGE OF THE RETRIEVED BRDF MODEL 
;  MERIS_SZA_MAX=60.
;  MERIS_VZA_MAX=38.
;  INDEX_VALID=WHERE((GOOD_INDEX EQ 1) AND (SENSOR_L1B_REF[16+SPECTRAL_BAND,*] GT 0) AND (SENSOR_L1B_REF[16+SPECTRAL_BAND,*] LT 5) AND (SENSOR_L1B_REF[1,*] LT MERIS_VZA_MAX) AND (SENSOR_L1B_REF[3,*] LT MERIS_SZA_MAX))
  
  ;SELECT ONLY THE DATA WHERE THE REFLECTANCE IS VALID 
  INDEX_VALID=WHERE((GOOD_INDEX EQ 1) AND (SENSOR_L1B_REF[16+SPECTRAL_BAND,*] GT 0) AND (SENSOR_L1B_REF[16+SPECTRAL_BAND,*] LT 5) )
  
  ;SELECT ONLY THE DATA WHERE THE OBSERVATIONAL ANGLES ARE CLOSE TO ONE OF THOSE USED TO INVERT THE BRDF MODEL
  IF N_ELEMENTS(INDEX_VALID) GT 1 THEN BEGIN 
    MAX_ANGULAR_DISTANCE=50. ; 5 DEGREE IS THE MAX ANGULAR DISTANCE TO ONE OF THE MERIS OBSERVATIONS USED TO GENERATE THE BRDF MODEL
    MATCHING_GEOMETRIES=VALID_RPV_BRDF_GEOMETRY(SENSOR_L1B_REF[1,INDEX_VALID], SENSOR_L1B_REF[2,INDEX_VALID], SENSOR_L1B_REF[3,INDEX_VALID], SENSOR_L1B_REF[4,INDEX_VALID], MAX_ANGULAR_DISTANCE, SITE, /VERBOSE)
    
    ;INDEX_VALID=INDEX_VALID[WHERE(MATCHING_GEOMETRIES NE 0)]
    INDEX_VALID=INDEX_VALID[WHERE(MATCHING_GEOMETRIES EQ 1)] ; WE CHOSE ONLY THE IDENTICAL CONFIGURATIONS
    
    ; DECLARE A VECTOR THAT CONTAINS -1 FOR A RECIPROCAL GEOMETRY MATCH AND 1 FOR AN IDENTICAL GEOMETRY MATCH
    ; 
    ; GEOMETRICAL_CONFIG=MATCHING_GEOMETRIES[WHERE(MATCHING_GEOMETRIES NE 0)]
    GEOMETRICAL_CONFIG=MATCHING_GEOMETRIES[WHERE(MATCHING_GEOMETRIES EQ 1)] ; WE CHOSE ONLY THE IDENTICAL CONFIGURATIONS
    
  ENDIF
  
  ; IF WE HAVE VALID ACQUISITION THEN WE START TRYING TO MODEL THEM
  IF N_ELEMENTS(INDEX_VALID) GT 1 THEN BEGIN 
  
      FILTERED_SENSOR_L1B_REF=SENSOR_L1B_REF[*,INDEX_VALID]
      
      ;COMPUTE THE NUMBER OF ACQUISITIONS
      N_ACQUISITIONS=N_ELEMENTS(FILTERED_SENSOR_L1B_REF[0,*])
      
      ;DEFINE THE SIMULATED SENSOR AND A VECTOR THAT CONTAINS THE STANDARD DEVIATION FROM THE MC COMPUTATION
      SIMUL_FILTERED_SENSOR_L1B_REF=FILTERED_SENSOR_L1B_REF
      SIMUL_FILTERED_SENSOR_L1B_REF_STD=FLTARR(N_ACQUISITIONS)


;BAH THIS TEMPLATE IS THE ONE PROVIDED BY MB (SRC) 
     ;READ THE TEMPLATE FOR THE SPECTRAL RESPONSE ASCII FILE (RSR ARE FROM DIMITRI)
      RSR_TEMPLATE  = GET_DIMITRI_RSR_TEMPLATE()
      
      ; DEFINE NAME OF THE SPECTRAL RESPONSE FILE
      FILTER_FILENAME=MAIN_DIRC+'/AUX_DATA/spectral_response/'+SENSOR+'/RSR_'+SENSOR+'_BAND_'+STRTRIM(SPECTRAL_BAND-1, 2)+'.txt'
      
      ; READ THE SPECTRAL RESPONSE
      SPECTRAL_RESPONSE=READ_ASCII(FILTER_FILENAME, TEMPLATE=RSR_TEMPLATE)
     
      ; ASSIGN MIN AND MAX WAVELENGHT OF SPECTRAL REPONSE TO THE VARIABLE USED TO DEFINE THE INTERVAL OF THE SIMULATION
      WAVELENGTH_MIN=MIN(SPECTRAL_RESPONSE.WAVELENGTH)
      WAVELENGTH_MAX=MAX(SPECTRAL_RESPONSE.WAVELENGTH)
      
;BAH THE RPV-TEMPLATE IS THE ONE PROVIDD BY M.B. (SRC) 
       ; WE ONLY PROCEEED IF THE WAVELENGTH_MIN AND WAVELENGTH_MAX ARE WITHIN THE RANGE OF THE RPV SPECTRAL MODEL DEFINITION
      RESTORE, MAIN_DIRC+'/AUX_DATA/PICS_BRDF_data/template_to_read_RPV_model_files_in_IDL.sav'
      RPV_MODEL=READ_ASCII(MAIN_DIRC+'/AUX_DATA/PICS_BRDF_data/'+SITE+'_interpolated_RPV_model.txt', TEMPLATE=TEMPLATE_RPV)
      WAVELENGTH_RPV_MIN=MIN(RPV_MODEL.FIELD1)
      WAVELENGTH_RPV_MAX=MAX(RPV_MODEL.FIELD1)
     
      IF (WAVELENGTH_MIN GT WAVELENGTH_RPV_MIN) AND (WAVELENGTH_MAX LT WAVELENGTH_RPV_MAX) THEN BEGIN
      
          ; DEFINE A VECTOR THAT CONTAINS THE STATE OF THE CPU (RUNNING=1, AVAILABLE=0)
          STATE_CPU=FLTARR(MAX_CPU)
          DONE_CPU=FLTARR(MAX_CPU)
          ACQUISITION_NB_PROCESSED_BY_CPU=FLTARR(MAX_CPU)
          
          ; DEFINE A ARRAY WHERE THE FILES BEING GENERATED BY MYSTIC ARE STORED
          FILES_BEING_GENERATED=STRARR(MAX_CPU)+'null'
        
          PRINT, 'SIMULATING DATA FROM BAND ', SPECTRAL_BAND
          
          
          ; REMOVE ALL PREVIOUS SIMULATION OUTPUTS
          MC_BASENAME='mc_simulation_cpu_'
          SIMULATION_OUTPUT_FILES=FILE_SEARCH(MAIN_DIRC+'/Temp_sim_files/'+MC_BASENAME+'*')
          IF N_ELEMENTS(SIMULATION_OUTPUT_FILES) GT 1 THEN FOR I_FILE=0, N_ELEMENTS(SIMULATION_OUTPUT_FILES)-1 DO SPAWN, 'rm '+SIMULATION_OUTPUT_FILES[I_FILE]
        
          
          ; INTIALIZE THE COUNTER FOR THE NUMBER OF ACQUISTIONS TO BE SIMULATED
          I_ACQUISITION=0
          
          ; DEFINE TIME STAMPS USED TO MONITOR PERFORMANCE
          SYS_TIMER_1=SYSTIME(/SECONDS)
          DELTA_TIME=0

          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
          ; START LOOPING ON THE OBSERVATIONS AND SIMULATE THEM
          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
          WHILE I_ACQUISITION LT N_ACQUISITIONS  DO BEGIN
            

            
            ; IF THERE ARE CPU AVAILABLE WE LAUNCH A SIMULATION ON THE NEXT OBSERVATION
            IF TOTAL(STATE_CPU) LT MAX_CPU THEN BEGIN
            
            
              ; DISPLAY THE TIME BETWEEN TWO SIMULATIONS
 ;             IF ((((I_ACQUISITION*100./N_ACQUISITIONS) MOD 1)) EQ 0) THEN  
              PRINT, 'DONE ', STRTRIM(I_ACQUISITION*100./N_ACQUISITIONS,2), ' % OF THE JOB. LAST SIMULATION STARTED  '+ STRTRIM(DELTA_TIME,2)+' SECONDS AGO'
              PRINT, 'DONE ', STRTRIM(I_ACQUISITION*100./N_ACQUISITIONS,2), ' % OF THE JOB. LAST SIMULATION STARTED  '+ STRTRIM(DELTA_TIME,2)+' SECONDS AGO'
              PRINT, 'NB CPUS BUSY: ', TOTAL(STATE_CPU)
              
               ; AVAILABLE CPU
               AVAIL_CPU_INDEX=WHERE(STATE_CPU EQ 0)
           
              ;BEFORE STARTING, WE MAKE SURE THE OZONE AND WATER VAPOUR ARE AVAILABLE IN THE FILE OTHERWIZE WE FILL UP WITH DUMMY VALUES
              IF FILTERED_SENSOR_L1B_REF[5,I_ACQUISITION] EQ -999 THEN OZONE=300 ELSE OZONE=FILTERED_SENSOR_L1B_REF[5,I_ACQUISITION]
          
              ; GET THE WATER VAPOUR VALUE
              IF FILTERED_SENSOR_L1B_REF[15,I_ACQUISITION] EQ -999 THEN WV=20 ELSE WV=FILTERED_SENSOR_L1B_REF[15,I_ACQUISITION]    
          
              
              ; COMPUTE THE AOT SCALING FACTOR WHICH IS AOT_550 / AOT_550_HESS_MODEL
              IF AERO_TYPE EQ 'continental_average' THEN AOT_550_HESS_MODEL=0.107539; VALUES FOR THE CONTINENTAL_AVERAGE
              IF AERO_TYPE EQ 'desert' THEN AOT_550_HESS_MODEL=0.246745; VALUE FOR THE DESERT
              AOT_SCALING_FACTOR=AOT_550/AOT_550_HESS_MODEL
          
          
              ; Run Mystic with all inputs
              IF KEYWORD_SET(VERBOSE) THEN PRINT,FCT_NAME+': RUN MYSTIC MODEL'
              INPUT_FILE = MAIN_DIRC+'/Temp_sim_files/'+MC_BASENAME+STRTRIM(AVAIL_CPU_INDEX[0], 2)+'.input'
              WRITE_MYSTIC_RPV_INPUT, INPUT_FILE, MC_BASENAME+STRTRIM(AVAIL_CPU_INDEX[0], 2), PHOTON_NB, WAVELENGTH_MIN, WAVELENGTH_MAX, $ 
                FILTERED_SENSOR_L1B_REF[3,I_ACQUISITION], FILTERED_SENSOR_L1B_REF[4,I_ACQUISITION],FILTERED_SENSOR_L1B_REF[1,I_ACQUISITION], $ 
                FILTERED_SENSOR_L1B_REF[2,I_ACQUISITION]-180., 0, 0, 0, 0, OZONE, WV, AOT_SCALING_FACTOR, AERO_TYPE, $ 
                RPV_FILE=MAIN_DIRC+'/AUX_DATA/PICS_BRDF_data/'+SITE+'_interpolated_RPV_model.txt'



             SPAWN, 'uvspec < '+INPUT_FILE+' >/dev/null  &', /sh        
              
              ; UPDATE THE LIST OF FILES BEING PROCESSED AND CPU STATE
              STATE_CPU[AVAIL_CPU_INDEX[0]]=1
              
              ; ASSIGN TO THE CPU THE ACQUISTION NUMBER
              ACQUISITION_NB_PROCESSED_BY_CPU[AVAIL_CPU_INDEX[0]]=I_ACQUISITION
              
              ; STORE FILENAME OF FILE BEING PROCESSED
              FILES_BEING_GENERATED[AVAIL_CPU_INDEX[0]]=MC_BASENAME+STRTRIM(AVAIL_CPU_INDEX[0], 2)+'.rad.spc'
          
              I_ACQUISITION=I_ACQUISITION+1
           ENDIF 
                                
            ; FIND OUT WHICH THREADS ARE DONE
            FOR I_CPU=0, MAX_CPU-1 DO IF FILE_SEARCH(FILES_BEING_GENERATED[I_CPU]) NE  '' THEN DONE_CPU[I_CPU]=1
            
            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
            ; READ OUTPUT FOR ALL THREADS THAT ARE FINISHED
            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
            FOR I_CPU=0, MAX_CPU-1 DO BEGIN
              IF DONE_CPU[I_CPU] EQ 1 THEN BEGIN
              
                ; COMPUTE AND DISPLAY THE TIME BETWEEN TWO SIMULATIONS
                DELTA_TIME=SYSTIME(/SECONDS)-SYS_TIMER_1
                SYS_TIMER_1=SYSTIME(/SECONDS)
                
                ; READ THE SIMULATINO RESULT
                RHO_TOA=READ_MYSTIC_OUTPUT(FILES_BEING_GENERATED[I_CPU])
                
                ; READ THE STANDARD DEVIATION ASSOCIATED TO THE SIMULATION
                RHO_TOA_STD=READ_MYSTIC_OUTPUT(STRMID(FILES_BEING_GENERATED[I_CPU], 0, STRPOS(FILES_BEING_GENERATED[I_CPU], '.rad.spc'))+'.rad.std.spc')
               
                
                ; CONVOLUTION OF THE SPECTRAL RESPONSE AND THE SIMULATE SIGNAL
                ; WE SAMPLE THE SIGNAL AND THE SPECTRAL RESPONSE AND A REGULAR INTERVAL SPECTRAL GRID AT 0.1 NM
                
                ; READ THE EXTRATERRESTRIAL SOLAR IRRADIANCE
                SOLAR_SPECTRUM=READ_ASCII(MAIN_DIRC+'/AUX_DATA/solar_spectrum/Thuillier_2003_solar_irradiance.txt', DATA_START=1) ; in mW.m-2.nm-1
                
                SPECTRAL_RESOLUTION=0.1 ; IN NM
                WAVELENGTH_GRID=INDGEN(CEIL((WAVELENGTH_MAX-WAVELENGTH_MIN)/SPECTRAL_RESOLUTION))*SPECTRAL_RESOLUTION+WAVELENGTH_MIN
                RESAMPLED_SPECTRAL_RESPONSE=INTERPOL(SPECTRAL_RESPONSE.RESPONSE, SPECTRAL_RESPONSE.WAVELENGTH, WAVELENGTH_GRID)
                RESAMPLED_RHO_TOA=INTERPOL(RHO_TOA[1,*], RHO_TOA[0,*],WAVELENGTH_GRID)
                RESAMPLED_SOLAR_IRRADIANCE=INTERPOL(SOLAR_SPECTRUM.FIELD1[1,*], SOLAR_SPECTRUM.FIELD1[0,*],WAVELENGTH_GRID)
                
                ; CONVOLUTION OF THE SPECTRAL RESPONSE AND THE SIMULATE SIGNAL
                SIMUL_FILTERED_SENSOR_L1B_REF[17+SPECTRAL_BAND-1, ACQUISITION_NB_PROCESSED_BY_CPU[I_CPU]]=TOTAL(RESAMPLED_RHO_TOA*RESAMPLED_SOLAR_IRRADIANCE*RESAMPLED_SPECTRAL_RESPONSE)/TOTAL(RESAMPLED_SOLAR_IRRADIANCE*RESAMPLED_SPECTRAL_RESPONSE)
    
                ; COMPUTE THE MEAN STANDARD DEVIATION OVER ALL 1 NM MONOCHROMATIC COMPUTATIONS 
                SIMUL_FILTERED_SENSOR_L1B_REF_STD[ACQUISITION_NB_PROCESSED_BY_CPU[I_CPU]]=MEAN(RHO_TOA_STD[1,*])/SQRT(N_ELEMENTS(RHO_TOA_STD[1,*]))
                
                ;REMOVE THE SIMULATION OUTPUT
                SPAWN, ['rm',FILES_BEING_GENERATED[I_CPU]], /noshell
    
                FILES_BEING_GENERATED[I_CPU]='DONE'
                STATE_CPU[I_CPU]=0
                DONE_CPU[I_CPU]=0
              ENDIF
            ENDFOR
          
          ENDWHILE

          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
          ; READ THE LAST SIMULATIONS THAT WERE GENERATED:
          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
          FOR I_CPU=0, MAX_CPU-1 DO BEGIN
            ; DO WE HAVE THE OUTPUT READY? IF YES, THEN SET STATE_CPU TO 0
            IF STATE_CPU[I_CPU] EQ 1 THEN BEGIN
              WHILE STATE_CPU[I_CPU] NE 0 DO  STATE_CPU[I_CPU]=FILE_SEARCH(FILES_BEING_GENERATED[I_CPU]) EQ ''
            
              ; READ THE OUTPUT
              WAIT, .01 ; JUST TO MAKE SURE THE FILE IS WRITTEN TO THE END
              RHO_TOA=READ_MYSTIC_OUTPUT(FILES_BEING_GENERATED[I_CPU])
              
              ; READ THE STANDARD DEVIATION ASSOCIATED TO THE SIMULATION
              RHO_TOA_STD=READ_MYSTIC_OUTPUT(STRMID(FILES_BEING_GENERATED[I_CPU], 0, STRPOS(FILES_BEING_GENERATED[I_CPU], '.rad.spc'))+'.rad.std.spc')
                        
              ; CONVOLUTION OF THE SPECTRAL RESPONSE AND THE SIMULATE SIGNAL
              ; WE SAMPLE THE SIGNAL AND THE SPECTRAL RESPONSE AND A REGULAR INTERVAL SPECTRAL GRID AT 0.1 NM
              ; READ THE EXTRATERRESTRIAL SOLAR IRRADIANCE
              SOLAR_SPECTRUM=READ_ASCII(MAIN_DIRC+'/AUX_DATA/solar_spectrum/Thuillier_2003_solar_irradiance.txt', DATA_START=1) ; in mW.m-2.nm-1
              SPECTRAL_RESOLUTION=0.1 ; IN NM
              WAVELENGTH_GRID=INDGEN(CEIL((WAVELENGTH_MAX-WAVELENGTH_MIN)/SPECTRAL_RESOLUTION))*SPECTRAL_RESOLUTION+WAVELENGTH_MIN
              RESAMPLED_SPECTRAL_RESPONSE=INTERPOL(SPECTRAL_RESPONSE.RESPONSE, SPECTRAL_RESPONSE.WAVELENGTH, WAVELENGTH_GRID)
              RESAMPLED_RHO_TOA=INTERPOL(RHO_TOA[1,*], RHO_TOA[0,*],WAVELENGTH_GRID)
              RESAMPLED_SOLAR_IRRADIANCE=INTERPOL(SOLAR_SPECTRUM.FIELD1[1,*], SOLAR_SPECTRUM.FIELD1[0,*],WAVELENGTH_GRID)
                
              ; CONVOLUTION OF THE SPECTRAL RESPONSE AND THE SIMULATE SIGNAL
              SIMUL_FILTERED_SENSOR_L1B_REF[17+SPECTRAL_BAND-1, ACQUISITION_NB_PROCESSED_BY_CPU[I_CPU]]=TOTAL(RESAMPLED_RHO_TOA*RESAMPLED_SOLAR_IRRADIANCE*RESAMPLED_SPECTRAL_RESPONSE)/TOTAL(RESAMPLED_SOLAR_IRRADIANCE*RESAMPLED_SPECTRAL_RESPONSE)
                     
              ; COMPUTE THE MEAN STANDARD DEVIATION OVER ALL 1 NM MONOCHROMATIC COMPUTATIONS 
              SIMUL_FILTERED_SENSOR_L1B_REF_STD[ACQUISITION_NB_PROCESSED_BY_CPU[I_CPU]]=MEAN(RHO_TOA_STD[1,*])/SQRT(N_ELEMENTS(RHO_TOA_STD[1,*]))
              
              ;REMOVE THE SIMULATION OUTPUT
              SPAWN, ['rm',FILES_BEING_GENERATED[I_CPU]], /noshell
              
              FILES_BEING_GENERATED[I_CPU]='DONE'
           ENDIF 
            
          ENDFOR
        
          ; START FILTERING PROCESS BY WHICH ALL ACQUISTIONS FOR WHICH THE RELATIVE DIFFERENCE TO THE SIMULATION DIFFERS BY MORE THAT 3-SIGMA ARE DISCARDED
          ;BAH: FINITE IS ADDED HERE TO AVOID NAN AND -NAN VALUES
          RELATIVE_DIFF=(FILTERED_SENSOR_L1B_REF[16+SPECTRAL_BAND,*]-SIMUL_FILTERED_SENSOR_L1B_REF[16+SPECTRAL_BAND,*])/SIMUL_FILTERED_SENSOR_L1B_REF[16+SPECTRAL_BAND,*]*100.
          STDDEV=STDDEV(RELATIVE_DIFF[WHERE(FINITE(RELATIVE_DIFF) EQ 1)])  
          BIAS=MEAN(RELATIVE_DIFF[WHERE(FINITE(RELATIVE_DIFF) EQ 1)])    
          FILTERED_FILTERED_SENSOR_L1B_REF=FILTERED_SENSOR_L1B_REF
          FILTERED_SIMUL_FILTERED_SENSOR_L1B_REF=SIMUL_FILTERED_SENSOR_L1B_REF
          FILTERED_SIMUL_FILTERED_SENSOR_L1B_REF_STD=SIMUL_FILTERED_SENSOR_L1B_REF_STD
         
          ;DO SOME 3-SIGMA FILTERING  
          FOR I=0, 1 DO BEGIN 
            INDEX_SORTED=WHERE((RELATIVE_DIFF LT BIAS+3.*STDDEV) AND (RELATIVE_DIFF GT BIAS-3.*STDDEV))
            FILTERED_FILTERED_SENSOR_L1B_REF=FILTERED_FILTERED_SENSOR_L1B_REF[*,INDEX_SORTED]
            GEOMETRICAL_CONFIG=GEOMETRICAL_CONFIG[INDEX_SORTED]
            FILTERED_SIMUL_FILTERED_SENSOR_L1B_REF=FILTERED_SIMUL_FILTERED_SENSOR_L1B_REF[*,INDEX_SORTED]
            FILTERED_SIMUL_FILTERED_SENSOR_L1B_REF_STD=FILTERED_SIMUL_FILTERED_SENSOR_L1B_REF_STD[INDEX_SORTED]
            RELATIVE_DIFF=(FILTERED_FILTERED_SENSOR_L1B_REF[16+SPECTRAL_BAND,*]-FILTERED_SIMUL_FILTERED_SENSOR_L1B_REF[16+SPECTRAL_BAND,*])/FILTERED_SIMUL_FILTERED_SENSOR_L1B_REF[16+SPECTRAL_BAND,*]*100.
            LINEAR_REGRESSION_COEF = POLY_FIT(FILTERED_FILTERED_SENSOR_L1B_REF[0,*], RELATIVE_DIFF, 1, SIGMA=SIGMA)
            TREND_UNCERTAINTY=SIGMA[1]
            STDDEV=STDDEV(RELATIVE_DIFF)
            BIAS=MEAN(RELATIVE_DIFF)
          ENDFOR
         
          
          !P.MULTI=0
          LOADCT, 39
          PLOT,FILTERED_FILTERED_SENSOR_L1B_REF[0,*], RELATIVE_DIFF, BACKGROUND=255, YRANGE=[-20, 20], COLOR=0, CHARSIZE=1.5, CHARTHICK=1, XTITLE='DECIMAL YEAR', YTITLE='(rho_toa-rho_toa_sim)/rho_toa_sim x 100', $
            TITLE=SENSOR+' (' +PROC_VER+') simulations in band '+STRTRIM(SPECTRAL_BAND,2)+' @ '+STRTRIM(BAND_WAVELENGTH[SPECTRAL_BAND-1],2)+' nm', PSYM=1
          ; PLOT THE 1-SIGMA MC NOISE 
          LOADCT, 0
          OPLOTERROR,FILTERED_FILTERED_SENSOR_L1B_REF[0,*], RELATIVE_DIFF ,FILTERED_SIMUL_FILTERED_SENSOR_L1B_REF_STD/FILTERED_SIMUL_FILTERED_SENSOR_L1B_REF[16+SPECTRAL_BAND,*]*100., COLOR=0, PSYM=1, ERRCOLOR=200, ERRSTYLE=0
          LOADCT, 39
          OPLOT,FILTERED_FILTERED_SENSOR_L1B_REF[0,*], RELATIVE_DIFF, COLOR=0, PSYM=1
          
          ; PLOT THE SIMULATIONS FOR WHICH A RECIPROCAL GEOMETRY WAS USED
          IF N_ELEMENTS(WHERE(GEOMETRICAL_CONFIG EQ -1)) GT 1 THEN OPLOT, FILTERED_FILTERED_SENSOR_L1B_REF[0,WHERE(GEOMETRICAL_CONFIG EQ -1)], RELATIVE_DIFF[WHERE(GEOMETRICAL_CONFIG EQ -1)],COLOR=50, PSYM=1
          ; PLOT THE LINEAR REGRESSION
          OPLOT,1900.+INDGEN(200), LINEAR_REGRESSION_COEF[0]+LINEAR_REGRESSION_COEF[1]* (1900.+INDGEN(200)), COLOR=50, LINE=0
          OPLOT, 1900.+INDGEN(200), LINEAR_REGRESSION_COEF[0]+LINEAR_REGRESSION_COEF[1]* (1900.+INDGEN(200))+2.*STDDEV, COLOR=250
          OPLOT, 1900.+INDGEN(200), LINEAR_REGRESSION_COEF[0]+LINEAR_REGRESSION_COEF[1]* (1900.+INDGEN(200))-2.*STDDEV, COLOR=250
          
          ; PRINT OUT STATISTICS
          XYOUTS, 140, 820, 'Nb of simulations: '+STRMID(N_ELEMENTS(RELATIVE_DIFF),2),/DEVICE, COLOR=250, CHARSIZE=1.5
          XYOUTS, 140, 800, 'Linear trend: '+ STRING(LINEAR_REGRESSION_COEF[1], FORMAT='(F6.2)')+' % / year'+' (95 % CI => +/-'+STRING(2.*TREND_UNCERTAINTY, FORMAT='(F6.2)')+' %'+' w/ norm. assump.)' , /DEVICE, COLOR=250, CHARSIZE=1.5
          XYOUTS, 140, 780, 'Mean bias in % on 2008/01/01:  '+STRING( LINEAR_REGRESSION_COEF[0]+LINEAR_REGRESSION_COEF[1]*2008., FORMAT='(F6.2)')+' %'+' (95 % CI => +/-'+STRING(2.*STDDEV/SQRT(N_ELEMENTS(RELATIVE_DIFF)), FORMAT='(F6.2)')+' %'+' w/ norm. assump.)', /DEVICE, COLOR=250, CHARSIZE=1.5
          XYOUTS, 140, 760, 'Standard deviation in %: '+STRING(STDDEV, FORMAT='(F6.2)')+' %',/DEVICE, COLOR=250, CHARSIZE=1.5
          XYOUTS, 140, 740, 'Mean MYSTIC 1-sigma noise per sim: '+STRING(MEAN(FILTERED_SIMUL_FILTERED_SENSOR_L1B_REF_STD/FILTERED_SIMUL_FILTERED_SENSOR_L1B_REF[16+SPECTRAL_BAND,*]*100.), FORMAT='(F6.2)')+' %',/DEVICE, COLOR=250, CHARSIZE=1.5
          ; PRINT MEAN DIFFERENCE BETWEEN RECIPROCAL AND IDENTICAL GEOMETRIES
          IF N_ELEMENTS(WHERE(GEOMETRICAL_CONFIG EQ -1)) GT 1 THEN XYOUTS, 140, 720, 'Bias reciprocal - bias identical in %: '+STRING(MEAN(RELATIVE_DIFF[WHERE(GEOMETRICAL_CONFIG EQ -1)])-MEAN(RELATIVE_DIFF[WHERE(GEOMETRICAL_CONFIG EQ 1)]), FORMAT='(F6.2)')+ $
          ' % (95 % CI => +/-'+STRING(2.*STDDEV(RELATIVE_DIFF[WHERE(GEOMETRICAL_CONFIG EQ -1)])/SQRT(N_ELEMENTS(RELATIVE_DIFF[WHERE(GEOMETRICAL_CONFIG EQ -1)])), FORMAT='(F6.2)') $
          +'% and '+STRING(2.*STDDEV(RELATIVE_DIFF[WHERE(GEOMETRICAL_CONFIG EQ 1)])/SQRT(N_ELEMENTS(RELATIVE_DIFF[WHERE(GEOMETRICAL_CONFIG EQ 1)])), FORMAT='(F6.2)')+'% w/ norm. assump.)',/DEVICE, COLOR=250, CHARSIZE=1.5
          
          ; WRITE PLOT TO .JPG  
          WRITE_JPEG, OUTPUT_FOLDER+'/Plot_sim_vs_true_'+SENSOR+'_Proc_'+PROC_VER+'_'+SITE+'_band_'+STRTRIM(SPECTRAL_BAND, 2)+'.jpeg',TVRD(TRUE=3), TRUE=3, QUALITY=100
            
          ; SAVE THE FILTERED SIMULATED SENSOR DATA
          SAVE, FILTERED_SIMUL_FILTERED_SENSOR_L1B_REF, FILENAME=OUTPUT_FOLDER+'/Plot_sim_vs_true_'+SENSOR+'_Proc_'+PROC_VER+'_'+SITE+'_band_'+STRTRIM(SPECTRAL_BAND, 2)+'.sav'
                    
          ;;;;;;;;;;;;;;;;;;;;;
          ; PREPARE PLOT SHOWING RESIDUAL ERROR ANALYSIS
          ;;;;;;;;;;;;;;;;;;;;;
          
          !P.MULTI=[0,2,3]
          
          ; COMPUTE RESIDUAL ERROR HISTOGRAM
          HISTO=HISTOGRAM(RELATIVE_DIFF, NBINS=N_ACQUISITIONS/5, LOCATIONS=ERRORS)
          
          PLOT,ERRORS, HISTO , BACKGROUND=255, COLOR=0, CHARSIZE=1.5, CHARTHICK=1, XTITLE='(obs-sim)/sim in %' , YTITLE='Frequency in # acquisitions', TITLE='Histogram of (obs-sim)/sim - Band '+STRING(SPECTRAL_BAND, FORMAT='(I2)')
          XYOUTS, 100, 840, 'Mean bias in %          :  '+STRING(BIAS , FORMAT='(F10.2)')+' %', /DEVICE, COLOR=250, CHARSIZE=1.5
          XYOUTS, 100, 820, 'Standard deviation in % : '+STRING(STDDEV, FORMAT='(F10.2)')+' %',/DEVICE, COLOR=250, CHARSIZE=1.5
          
          ;COMPUTE CORRESPONDING NORMAL DISTRIBUTION
          NORMAL_DISTRIBUTION=1./STDDEV/SQRT(2*!PI)*EXP(-0.5*((ERRORS-BIAS)/STDDEV)^2)
          OPLOT, ERRORS, NORMAL_DISTRIBUTION*TOTAL(HISTO)/TOTAL(NORMAL_DISTRIBUTION), COLOR=50, LINE=0
          
          PLOT, FILTERED_FILTERED_SENSOR_L1B_REF[1,*], RELATIVE_DIFF, COLOR=0, CHARSIZE=1.5, CHARTHICK=1, XTITLE='VZA in degrees' , YTITLE='(obs-sim)/sim in %', TITLE='(obs-sim)/sim vs. VZA - Band '+STRING(SPECTRAL_BAND, FORMAT='(I2)'), PSYM=1
          XYOUTS, 750, 840, 'r^2 :  '+STRING((CORRELATE(FILTERED_FILTERED_SENSOR_L1B_REF[1,*], RELATIVE_DIFF) )^2, FORMAT='(F5.2)'), /DEVICE, COLOR=250, CHARSIZE=1.5
          
          
          PLOT, FILTERED_FILTERED_SENSOR_L1B_REF[3,*], RELATIVE_DIFF, COLOR=0, CHARSIZE=1.5, CHARTHICK=1, XTITLE='SZA in degrees' , YTITLE='(obs-sim)/sim in %', TITLE='(obs-sim)/sim vs. SZA - Band '+STRING(SPECTRAL_BAND, FORMAT='(I2)'), PSYM=1
          XYOUTS, 100, 540, 'r^2 :  '+STRING((CORRELATE(FILTERED_FILTERED_SENSOR_L1B_REF[3,*], RELATIVE_DIFF) )^2, FORMAT='(F5.2)'), /DEVICE, COLOR=250, CHARSIZE=1.5
          
          
          
          PLOT, (FILTERED_FILTERED_SENSOR_L1B_REF[4,*]-FILTERED_FILTERED_SENSOR_L1B_REF[2,*]), RELATIVE_DIFF, COLOR=0, CHARSIZE=1.5, CHARTHICK=1, XTITLE='dPhi in degrees' , YTITLE='(obs-sim)/sim in %', title='(obs-sim)/sim vs. dPhi - Band '+STRING(SPECTRAL_BAND, FORMAT='(I2)'), PSYM=1
          XYOUTS, 750, 540, 'r^2 :  '+STRING((CORRELATE(FILTERED_FILTERED_SENSOR_L1B_REF[4,*]-FILTERED_FILTERED_SENSOR_L1B_REF[2,*], RELATIVE_DIFF) )^2, FORMAT='(F5.2)'), /DEVICE, COLOR=250, CHARSIZE=1.5
          
          
          SCATT_ANGLE=180./!PI*ACOS(COS(FILTERED_FILTERED_SENSOR_L1B_REF[1,*]*!PI/180.)*COS(FILTERED_FILTERED_SENSOR_L1B_REF[3,*]*!PI/180.)+SIN(FILTERED_FILTERED_SENSOR_L1B_REF[1,*]*!PI/180.)*SIN(FILTERED_FILTERED_SENSOR_L1B_REF[3,*]*!PI/180.)*COS((FILTERED_FILTERED_SENSOR_L1B_REF[2,*]-FILTERED_FILTERED_SENSOR_L1B_REF[4,*])*!PI/180.))
          SCATT_ANGLE=180-SCATT_ANGLE
          PLOT, SCATT_ANGLE, RELATIVE_DIFF, COLOR=0, CHARSIZE=1.5, CHARTHICK=1, XTITLE='Scattering angle in degrees (BWD=180)' , YTITLE='(obs-sim)/sim in %', TITLE='(obs-sim)/sim vs. scatt angle - Band '+string(spectral_band, format='(I2)'), psym=1
          XYOUTS, 100, 240, 'r^2 :  '+STRING((CORRELATE(SCATT_ANGLE, RELATIVE_DIFF) )^2, FORMAT='(F5.2)'), /DEVICE, COLOR=250, CHARSIZE=1.5
          
          
;; PLOT THE SCATTERING ANGLE DISTRIBUTION
;          HISTO=HISTOGRAM(SCATT_ANGLE, NBINS=N_ACQUISITIONS/5, LOCATIONS=ERRORS)
;          PLOT,ERRORS, HISTO , BACKGROUND=255, COLOR=0, CHARSIZE=1.5, CHARTHICK=1, XTITLE='SCATT ANGLE IN DEGREES' , YTITLE='FREQUENCY IN # ACQUISITIONS', TITLE='SCATT ANGLE DISTRIBUTION - BAND '+STRING(SPECTRAL_BAND, FORMAT='(I2)')
          
          PLOT, FILTERED_FILTERED_SENSOR_L1B_REF[4,*], RELATIVE_DIFF, COLOR=0, CHARSIZE=1.5, CHARTHICK=1, XTITLE='Sun azimuth angle in degrees (BWD=180)' , YTITLE='(obs-sim)/sim in %', TITLE='(obs-sim)/sim vs. scatt angle - Band '+STRING(SPECTRAL_BAND, FORMAT='(I2)'), PSYM=1
          XYOUTS, 750, 240, 'r^2 :  '+STRING((CORRELATE(FILTERED_FILTERED_SENSOR_L1B_REF[4,*], RELATIVE_DIFF) )^2, FORMAT='(F5.2)'), /DEVICE, COLOR=250, CHARSIZE=1.5
          
          
          ;;;;;;;;;;;;;;;;;;;;;;;;
          ; WRITE PLOT SHOWING THE INVERSION RESULTS TO A .JPG
          ;;;;;;;;;;;;;;;;;;;;;;;;
          WRITE_JPEG, OUTPUT_FOLDER+'/Plot_sim_vs_true_'+SENSOR+'_Proc_'+PROC_VER+'_'+SITE+'_band_'+STRTRIM(SPECTRAL_BAND, 2)+'_error_analysis.jpeg',TVRD(TRUE=3), TRUE=3, QUALITY=100
          
          ; SAVE THE STATISTICAL PARAMETERS ASSOCIATED TO EACH BAND TIME SERIES
          SAVE, STDDEV, BIAS,LINEAR_REGRESSION_COEF,TREND_UNCERTAINTY, FILTERED_SIMUL_FILTERED_SENSOR_L1B_REF, FILTERED_SIMUL_FILTERED_SENSOR_L1B_REF_STD, FILENAME=OUTPUT_FOLDER+'/Plot_sim_vs_true_'+SENSOR+'_Proc_'+PROC_VER+'_'+SITE+'_band_'+STRTRIM(SPECTRAL_BAND, 2)+'_statistics.sav'
                  
      ENDIF ELSE PRINT, 'SPECTRAL BAND DEFINED OUTSIDE RPV SPECTRAL MODEL DOMAIN...'
  ENDIF ELSE PRINT,'THERE ARE NO ACQUISTIONS TO SIMULATE...'      
  
ENDFOR   

;-----------------------------------------------
; RETURN DEVISE WINDOW TO NOMINAL SETTING

IF KEYWORD_SET(VERBOSE) THEN PRINT, FCT_NAME+': PLOT OR RESETTING DEVICE WINDOW PROPERTIES'

IF KEYWORD_SET(DISPLAY_PLOT) THEN PRINT, '' ELSE  SET_PLOT, 'X'

IF KEYWORD_SET(VERBOSE) THEN PRINT, FCT_NAME+': SUCCESSFULL'

RETURN,1

END

