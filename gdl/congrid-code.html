<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Tue Jul  2 12:50:48 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>congrid.pro (Documentation for /home/marrabld/projects/DIMITRI_2.0/Source/)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="congrid.pro (Documentation for /home/marrabld/projects/DIMITRI_2.0/Source/)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">; $Id: //depot/Release/ENVI50_IDL82/idl/idldir/lib/congrid.pro#1 $</span>
<span class="comments">;</span>
<span class="comments">; Copyright (c) 1988-2012, Exelis Visual Information Solutions, Inc. All</span>
<span class="comments">;       rights reserved. Unauthorized reproduction is prohibited.</span>
<span class="comments">;</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;   CONGRID</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;       Shrink or expand the size of an array by an arbitrary amount.</span>
<span class="comments">;       This IDL procedure simulates the action of the VAX/VMS</span>
<span class="comments">;       CONGRID/CONGRIDI function.</span>
<span class="comments">;</span>
<span class="comments">;   This function is similar to "REBIN" in that it can resize a</span>
<span class="comments">;       one, two, or three dimensional array.   "REBIN", however,</span>
<span class="comments">;       requires that the new array size must be an integer multiple</span>
<span class="comments">;       of the original size.   CONGRID will resize an array to any</span>
<span class="comments">;       arbitrary size (REBIN is somewhat faster, however).</span>
<span class="comments">;       REBIN averages multiple points when shrinking an array,</span>
<span class="comments">;       while CONGRID just resamples the array.</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;       Array Manipulation.</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;   array = CONGRID(array, x, y, z)</span>
<span class="comments">;</span>
<span class="comments">; INPUTS:</span>
<span class="comments">;       array:  A 1, 2, or 3 dimensional array to resize.</span>
<span class="comments">;               Data Type : Any type except string or structure.</span>
<span class="comments">;</span>
<span class="comments">;       x:      The new X dimension of the resized array.</span>
<span class="comments">;               Data Type : Int or Long (greater than or equal to 2).</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL INPUTS:</span>
<span class="comments">;       y:      The new Y dimension of the resized array.   If the original</span>
<span class="comments">;               array has only 1 dimension then y is ignored.   If the</span>
<span class="comments">;               original array has 2 or 3 dimensions then y MUST be present.</span>
<span class="comments">;</span>
<span class="comments">;       z:      The new Z dimension of the resized array.   If the original</span>
<span class="comments">;               array has only 1 or 2 dimensions then z is ignored.   If the</span>
<span class="comments">;               original array has 3 dimensions then z MUST be present.</span>
<span class="comments">;</span>
<span class="comments">; KEYWORD PARAMETERS:</span>
<span class="comments">;</span>
<span class="comments">;   CENTER: If this keyword is set, shift the interpolation so that points</span>
<span class="comments">;       in the input and output arrays are assumed to lie at the midpoint</span>
<span class="comments">;       of their coordinates rather than at their lower-left corner.</span>
<span class="comments">;</span>
<span class="comments">;   INTERP: If set, causes linear interpolation to be used.</span>
<span class="comments">;       Otherwise, the nearest-neighbor method is used.</span>
<span class="comments">;</span>
<span class="comments">;   CUBIC:  If specified and non-zero, "Cubic convolution"</span>
<span class="comments">;       interpolation is used.  This is a more</span>
<span class="comments">;       accurate, but more time-consuming, form of interpolation.</span>
<span class="comments">;       CUBIC has no effect when used with 3 dimensional arrays.</span>
<span class="comments">;       If this parameter is negative and non-zero, it specifies the</span>
<span class="comments">;       value of the cubic interpolation parameter as described</span>
<span class="comments">;       in the INTERPOLATE function.  Valid ranges are -1 &lt;= Cubic &lt; 0.</span>
<span class="comments">;       Positive non-zero values of CUBIC (e.g. specifying /CUBIC)</span>
<span class="comments">;       produce the default value of the interpolation parameter</span>
<span class="comments">;       which is -1.0.</span>
<span class="comments">;</span>
<span class="comments">;       MINUS_ONE:</span>
<span class="comments">;               If set, will prevent CONGRID from extrapolating one row or</span>
<span class="comments">;               column beyond the bounds of the input array.   For example,</span>
<span class="comments">;               If the input array has the dimensions (i, j) and the</span>
<span class="comments">;               output array has the dimensions (x, y), then by</span>
<span class="comments">;               default the array is resampled by a factor of (i/x)</span>
<span class="comments">;               in the X direction and (j/y) in the Y direction.</span>
<span class="comments">;               If MINUS_ONE is present (AND IS NON-ZERO) then the array</span>
<span class="comments">;               will be resampled by the factors (i-1)/(x-1) and (j-1)/(y-1).</span>
<span class="comments">;</span>
<span class="comments">; OUTPUTS:</span>
<span class="comments">;   The returned array has the same number of dimensions as the original</span>
<span class="comments">;       array and is of the same data type.   The returned array will have</span>
<span class="comments">;       the dimensions (x), (x, y), or (x, y, z) depending on how many</span>
<span class="comments">;       dimensions the input array had.</span>
<span class="comments">;</span>
<span class="comments">; PROCEDURE:</span>
<span class="comments">;       IF the input array has three dimensions, or if INTERP is set,</span>
<span class="comments">;       then the IDL interpolate function is used to interpolate the</span>
<span class="comments">;       data values.</span>
<span class="comments">;       If the input array has two dimensions, and INTERP is NOT set,</span>
<span class="comments">;       then the IDL POLY_2D function is used for nearest neighbor sampling.</span>
<span class="comments">;       If the input array has one dimension, and INTERP is NOT set,</span>
<span class="comments">;       then nearest neighbor sampling is used.</span>
<span class="comments">;</span>
<span class="comments">; EXAMPLE:</span>
<span class="comments">;       ; vol is a 3-D array with the dimensions (80, 100, 57)</span>
<span class="comments">;       ; Resize vol to be a (90, 90, 80) array</span>
<span class="comments">;       vol = CONGRID(vol, 90, 90, 80)</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">;       DMS, Sept. 1988.</span>
<span class="comments">;       DMS, Added the MINUS_ONE keyword, Sept. 1992.</span>
<span class="comments">;   Daniel Carr. Re-wrote to handle one and three dimensional arrays</span>
<span class="comments">;                    using INTERPOLATE function.</span>
<span class="comments">;   DMS, RSI, Nov, 1993.  Added CUBIC keyword.</span>
<span class="comments">;       SJL, Nov, 1997.  Formatting, conform to IDL style guide.</span>
<span class="comments">;       CT, RSI, April 2001. Added /CENTER keyword. Correct POLY_2D interp.</span>
<span class="comments">;-</span>

<a id="CONGRID:source"></a>function CONGRID, arr, x, y, z, $
    CENTER=center, $
    CUBIC = cubicIn, $
    INTERP=interp, $
    MINUS_ONE=minus_one

    COMPILE_OPT idl2, hidden
    ON_ERROR, 2     <span class="comments">;Return to caller if error</span>

    ndim = SIZE(arr, /N_DIMENSIONS)
    dims = SIZE(arr, /DIMENSIONS)

    if ((ndim lt 1) or (ndim gt 3)) then $
      Message, 'Array must have 1, 2, or 3 dimensions.'

    <span class="comments">;;  Supply defaults = no interpolate, and no minus_one.</span>
    int = KEYWORD_SET(interp)
    m1 = KEYWORD_SET(minus_one)
    cubic = (N_ELEMENTS(cubicIn) gt 0) ? cubicIn : 0
    if (cubic ne 0) then int = 1    <span class="comments">;Cubic implies interpolate</span>
    offset = KEYWORD_SET(center) ? 0.5 : 0.0

    <span class="comments">; Construct new interpolate coordinates.</span>
    <span class="comments">; Skip this for 2D nearest-neighbor since we use POLY_2D instead.</span>
    if ((ndim ne 2) or ((ndim eq 2) and int)) then begin
        <span class="comments">; Note that we need to use "offset" twice: Once to shift the new</span>
        <span class="comments">; coordinates to the midpoint, and again to shift the location of</span>
        <span class="comments">; the original coordinates to their midpoint.</span>
        switch ndim of  <span class="comments">; Fall through for ndim>1.</span>
            3: srz = float(dims[2]-m1)/(z-m1)*(findgen(z) + offset) - offset
            2: sry = float(dims[1]-m1)/(y-m1)*(findgen(y) + offset) - offset
            1: srx = float(dims[0]-m1)/(x-m1)*(findgen(x) + offset) - offset
        endswitch
    endif

    case ndim of
        1: begin                <span class="comments">; *** ONE DIMENSIONAL ARRAY</span>
            arr_r = (int) ? INTERPOLATE(arr, srx, CUBIC = cubic) : $
                arr[ROUND(srx)]
           end
        2: begin                <span class="comments">; *** TWO DIMENSIONAL ARRAY</span>
            if (int) then begin  <span class="comments">; bilinear or cubic</span>
                arr_r = INTERPOLATE(arr, srx, sry, /GRID, CUBIC=cubic)
            endif else begin  <span class="comments">; nearest neighbor</span>
                <span class="comments">; Note: For expansion, divide by (x-1) so that CONGRID</span>
                <span class="comments">; will agree with REBIN.</span>
                expand = (x gt dims[0])
                xm1 = (m1 or expand) ? x-1 : x
                arr_r = POLY_2D(arr, $
                    [[0,0],[(dims[0]-m1)/float(xm1),0]], $ <span class="comments">;Use poly_2d</span>
                    [[0,(dims[1]-m1)/float(y-m1)],[0,0]],int,x,y)
            endelse
           end
        3: begin                <span class="comments">; *** THREE DIMENSIONAL ARRAY</span>
            <span class="comments">; Only supports linear interpolation.</span>
            arr_r = INTERPOLATE(arr, srx, sry, srz, /GRID)
           end
    endcase

    return, arr_r
end
</code>
    </div>
  </body>
</html>