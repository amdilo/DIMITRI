;**************************************************************************************
;**************************************************************************************
;*
;* NAME:
;*     INVERSE_XC
;* 
;* PURPOSE:
;*      INVERSE RHOPATH/RHORAY RATIO TO RETRIEVE TAU AT GIVEN WIND, GEOMETRY AND BAND
;*      WITH MULTILINEAR INTERPOLATION IN 4-DIMENSIONNAL ARRAY 
;* 
;* CALLING SEQUENCE:
;*      RES = INVERSE_XC(WIND, RAA, VZA, SZA, ZETA, IBAND)
;* 
;* INPUTS:
;*      WIND  - THE WIND SPEED IN M/S.
;*      RAA   - THE RELATIVE AZIMUTH ANGLE IN DEGREES
;*      VZA   - THE VIEWING ZENITH ANGLE IN DEGREES 
;*      SZA   - THE SOLAR ZENITH ANGLE IN DEGREES
;*      ZETA  - RHOPATH/RHOR RATIO
;*      IBAND - THE INDEX OF WAVELENGTH FOR GIVEN SENSOR
;*
;* KEYWORDS:
;*      COS              - INTERPOLATE ZENITH ANGLES IN COSINE
;*      VERBOSE          - PROCESSING STATUS OUTPUTS
;*
;* OUTPUTS:
;*      RHOR             - RAYLEIGH REFLECTANCE 
;*
;* COMMON BLOCKS:
;*      RTM_LUT
;*
;* MODIFICATION HISTORY:
;*        01 NOV 2013 - C MAZERAN - FIRST IMPLEMENTATION
;*
;* VALIDATION HISTORY:
;*        01 NOV 2013 - C MAZERAN - LINUX 64-BIT MACHINE IDL 8.2, NOMINAL COMPILATION AND OPERATION. 
;*
;**************************************************************************************
;**************************************************************************************
FUNCTION INVERSE_XC, WIND, RAA, VZA, SZA, ZETA, IBAND, COS=COS, VERBOSE=VERBOSE

 COMMON RTM_LUT

;-----------------------------------------
; DEFINE CURRENT FUNCTION NAME

 FCT_NAME = "INVERSE_XC"

;-----------------------------------------
; CHECK INPUTS CORRESPOND TO
; A ONE-DIMENSIONNAL ARRAY

 S0 = SIZE(WIND,/N_DIMENSIONS)
 S1 = SIZE(RAA,/N_DIMENSIONS)
 S2 = SIZE(VZA,/N_DIMENSIONS)
 S3 = SIZE(SZA,/N_DIMENSIONS)
 S4 = SIZE(ZETA,/N_DIMENSIONS)
 S  = [S0, S1, S2, S3, S4]

 IF N_ELEMENTS(UNIQ(S(SORT(S)))) NE 1 THEN BEGIN
   PRINT, FCT_NAME+":ERROR, WORKS ONLY FOR 1D ARRAY"
   RETURN, -1
 ENDIF

;-----------------------------------------
; CHECK INPUTS HAVE THE SAME DIMENSION
 
 N0 = N_ELEMENTS(WIND)
 N1 = N_ELEMENTS(RAA)
 N2 = N_ELEMENTS(VZA)
 N3 = N_ELEMENTS(SZA)
 N4 = N_ELEMENTS(ZETA)
 N  = [N0, N1, N2, N3, N4]
 IF N_ELEMENTS(UNIQ(N(SORT(N)))) NE 1 THEN BEGIN
   PRINT, FCT_NAME+":ERROR, INPUTS DON'T HAVE SAME DIMENSION"
   RETURN, -1
 ENDIF

;-----------------------------------------
; COPY INPUT ARRAY IN GENERIC NAME 

 X = DBLARR([4,N0])
 X[0,*] = WIND
 X[1,*] = RAA
 IF KEYWORD_SET(COS) THEN BEGIN
   X[2,*] = COS(VZA*!DTOR)
   X[3,*] = COS(SZA*!DTOR)
 ENDIF ELSE BEGIN
   X[2,*] = VZA
   X[3,*] = SZA
 ENDELSE

;-----------------------------------------
; COMPUTE INDICES AND WEIGHTS OF THE
; INTERPOLATION 

 IF KEYWORD_SET(VERBOSE) THEN PRINT,FCT_NAME+': COMPUTE INDICES AND WEIGHTS'
 
 INDEX  = INTARR(4,N0)
 WEIGHT = DBLARR(4,N0)

 FOR I=0, 3 DO BEGIN

    IF ( (I EQ 2 OR I EQ 3) AND KEYWORD_SET(COS) ) THEN XREF = COS(XC_LUT.(I)*!DTOR) ELSE XREF = XC_LUT.(I)

    INDEX[I,*]  = VALUE_LOCATE(XREF, X[I,*])

    ID=WHERE(INDEX[I,*] GE 0 AND INDEX[I,*] LT N_ELEMENTS(XREF)-1, COUNT, NCOMPLEMENT=NCOUNT)
    IF COUNT NE 0 THEN WEIGHT[I,ID]=(X[I,ID]-XREF[INDEX[I,ID]])/(XREF[INDEX[I,ID]+1]-XREF[INDEX[I,ID]])
    IF NCOUNT NE 0 THEN BEGIN
      ID=WHERE(INDEX[I,*] EQ -1 )
      IF ID[0] NE -1 THEN BEGIN
        INDEX[I,ID]   = 0
        WEIGHT[I,ID]  = 0.
      ENDIF
      ID=WHERE(INDEX[I,*] EQ N_ELEMENTS(XREF)-1 )
      IF ID[0] NE -1 THEN BEGIN
        INDEX[I,ID]   = N_ELEMENTS(XREF) - 2
        WEIGHT[I,ID]  = 1.
      ENDIF
    ENDIF

 ENDFOR
 
;-----------------------------------------
; INTERPOLATE IN THE LUT

 IF KEYWORD_SET(VERBOSE) THEN PRINT,FCT_NAME+': INTERPOMATE IN RAYLEIGH LUT'

 DATA = REFORM(XC_LUT.DATA[*,*,*,*,*,IBAND])
 
 XC = MAKE_ARRAY(3,N0,/FLOAT,VALUE=0.)
 ;XC=MAKE_ARRAY(N0,/FLOAT,VALUE=0.)
 
 FOR I=0, N0-1 DO BEGIN
 FOR I0 = 0, 1 DO BEGIN
 FOR I1 = 0, 1 DO BEGIN
 FOR I2 = 0, 1 DO BEGIN
 FOR I3 = 0, 1 DO BEGIN
 FOR coeff = 0, 2 DO BEGIN
    XC[coeff, I] += (I0?WEIGHT[0,I]:(1.-WEIGHT[0,I]))*$
                    (I1?WEIGHT[1,I]:(1.-WEIGHT[1,I]))*$
                    (I2?WEIGHT[2,I]:(1.-WEIGHT[2,I]))*$
                    (I3?WEIGHT[3,I]:(1.-WEIGHT[3,I]))*DATA[coeff,INDEX[0,I]+I0,INDEX[1,I]+I1,INDEX[2,I]+I2,INDEX[3,I]+I3]
 ENDFOR
 ENDFOR
 ENDFOR
 ENDFOR
 ENDFOR
 ENDFOR

;-----------------------------------------
; APPLY POLYNOMIAL

 TAU = MAKE_ARRAY(N0,/FLOAT,VALUE=0.)

 XC[0,*] -= ZETA[*]

 FOR I=0, N0-1 DO BEGIN
    TEMP = FZ_ROOTS(REFORM(XC[*,I]))
    TEMP = REAL_PART(TEMP)
    INDEX = WHERE(TEMP GT 0.)
    IF INDEX[0] NE -1 THEN TAU[I] = MIN(TEMP[INDEX]) ELSE TAU[I]=-999.
 ENDFOR

 RETURN, TAU

END
