<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Tue Jul  2 12:51:07 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>convert_timeseries_to_sade.pro (Documentation for /home/marrabld/projects/DIMITRI_2.0/Source/)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="convert_timeseries_to_sade.pro (Documentation for /home/marrabld/projects/DIMITRI_2.0/Source/)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source">PRO CONVERT_TIMESERIES_TO_SADE,SENSOR,proc_ver,SENSOR_DATA,NUMPIXS,BANDS_INDEX,SITE,prodnames,PFLAG

<span class="comments">;NEED INPUT = SENSOR, BANDS INDEX, NUM DIRECTIONS,SITENAME AND ICOORDS</span>
<span class="comments">;INPUT TIME SERIES WILL BE OF FORM</span>
<span class="comments">;[PARAMS,OBSERVATIONS]</span>
<span class="comments">;------------------------------</span>
ft = get_dimitri_location('SITE_DATA')
icoords = get_site_coordinates(SITE,ft)

<span class="comments">;-----------------------------</span>
<span class="comments">; DEFINE OUTPUT FILE - MAKE SURE YOU ARE IN CORRECT CD</span>

  rdifol = get_dimitri_location('INPUT')
  rdofol = '/mnt/Projects/MEREMSII/WG_Reference_Dataset/'
  dl = PATH_SEP()
  OUTPUTFILE = rdofol+SITE+dl+site+'_'+SENSOR+'_'+proc_ver+'.SADE'
  OPENW,OUTF,OUTPUTFILE,/GET_LUN

  jpgfol = rdofol+SITE+dl+sensor
  if file_test(jpgfol) eq 0 then file_mkdir,jpgfol

<span class="comments">;------------------------------</span>
<span class="comments">; GET SITE LAT AND LON FROM ICOORDS </span>

  SITE_LAT = MEAN(ICOORDS[0:1])
  SITE_LON = MEAN(ICOORDS[2:3])

<span class="comments">;------------------------------</span>
<span class="comments">; ASSUME IF THERE ARE MULTIPLE DIRECTIONS THAT THE OBSERVATIONS ARE NEXT TO EACH OTHER</span>
<span class="comments">; GET NUMBER OF INDIVICUAL OBSERVATIONS (NUM VALUES DIVIDED BY DIRECTIONS)</span>

  NOVAL     = -999.
  NUMNONREF = 5+12
  NOBSERS = n_elements(sensor_data[0,*])
  NBANDS    = N_ELEMENTS(BANDS_INDEX)
  vzaid = 1
  vaaid = 2
  szaid = 3
  saaid = 4

  <span class="comments">;IF ABS(NINOBS-long(NINOBS)) GT 0. THEN BEGIN</span>
  <span class="comments">;  PRINT, 'ERROR, NOT ALL DIRECTIONS ARE PRESENT'</span>
  <span class="comments">;  RETURN ;MAYBE JUST FILL THESE IN AS EMPTY THEN?</span>
  <span class="comments">;ENDIF</span>

<span class="comments">;if parasol:::::</span>
if pflag then begin
<span class="comments">;get all of the uniq product names</span>
uprds = prodnames[uniq(prodnames,sort(prodnames))]

paravza = make_array(n_elements(BANDS_INDEX),16,n_elements(uprds),/float,value=-999.)
paravaa = make_array(n_elements(BANDS_INDEX),16,n_elements(uprds),/float,value=-999.)

<span class="comments">; loop over each product name and compute new vza and vaa angles</span>
for iprd=0,n_elements(uprds)-1 do begin
<span class="comments">;if iprd gt 0 then continue</span>
print, 'product ', iprd, ' of' ,n_elements(uprds)
<span class="comments">;print,'VZA ',SENSOR_DATA[1,0]</span>
angles = get_parasol_viewing_geometries(uprds[iprd],icoords,site)
<span class="comments">;returns,[nband,ndirs,2 angles]</span>
paravza[*,*,iprd] = angles[*,*,0]
paravaa[*,*,iprd] = angles[*,*,1]
endfor
endif

<span class="comments">;when loop over each parasol observation</span>
<span class="comments">; get find which product it's from, send the vza and vaa to find which direction</span>
<span class="comments">; return the vza and vaa for all bands within that direction</span>


<span class="comments">;------------------------------</span>
<span class="comments">; LOOP OVER EACH IND OBS</span>
  dircount=0l
  FOR II=0l,NOBSERS-1 DO BEGIN<span class="comments">;,NUM_DIRECTIONS DO BEGIN</span>

<span class="comments">;------------------------------</span>
<span class="comments">; CONVERT TIME FROM DECIMAL TO DD/MM/YYYY-HH:MM:SS, AND TODAYS DATE AS THE PROCESSING TIME STRING</span>
  
    ACQ_TIME    = SENSOR_DATA[0,II]
    <span class="comments">;TTIME       = ACQ_TIME+DOUBLE(JULDAY(1, 0, FLOOR(ACQ_TIME), 0, 0, 0))</span>
    if floor(acq_time) mod 4 eq 0 then diy=366 else diy=365
    ttime = diy*(acq_time-floor(acq_time))+DOUBLE(JULDAY(1, 0, FLOOR(ACQ_TIME), 0, 0, 0))
    CALDAT,TTIME,MONTH,DAY,YEAR,HOUR,MINUTE,SECOND

    MONTH       = MONTH Lt 10. ?  '0'+STRTRIM(STRING(MONTH,FORMAT='(I)'),2) : STRTRIM(STRING(MONTH,FORMAT='(I)'),2)
    DAY         = DAY Lt 10. ? '0'+STRTRIM(STRING(DAY,FORMAT='(I)'),2) : STRTRIM(STRING(DAY,FORMAT='(I)'),2)
    YEAR        = STRTRIM(STRING(YEAR,FORMAT='(I)'),2)
    HOUR        = HOUR Lt 10. ? '0'+STRTRIM(STRING(HOUR,FORMAT='(I)'),2) : STRTRIM(STRING(HOUR,FORMAT='(I)'),2)
    MINUTE      = MINUTE Lt 10. ? '0'+STRTRIM(STRING(MINUTE,FORMAT='(I)'),2) : STRTRIM(STRING(MINUTE,FORMAT='(I)'),2)
    SECOND      = SECOND Lt 10. ? '0'+STRTRIM(STRING(SECOND,FORMAT='(I)'),2) : STRTRIM(STRING(SECOND,FORMAT='(I)'),2)
    
    ACQ_STRING  = DAY+'/'+MONTH+'/'+YEAR+'-'+HOUR+':'+MINUTE+':'+SECOND
    PROC_STRING = ACQ_STRING<span class="comments">;FOR NOW</span>

<span class="comments">;------------------------------</span>
<span class="comments">; GET TOA REFLECTANCE, STDEV AND VZA AND VAA</span>

    TOA_REF = SENSOR_DATA[NUMNONREF+BANDs_INDEX,II]
    if sensor eq 'MODISA' then tband=22 else tband=nbands
    TOA_STD = SENSOR_DATA[NUMNONREF+tBAND+BANDs_INDEX,II]
  
  <span class="comments">;ADD EXCEPTION ON MODIS BANDS TO RESORT THE DATA>>> DONE, will be passed through bands_index!!!</span>
  <span class="comments">; ADD IT TO THE DOUBLET EXTRACTION ROUTINE</span>
  <span class="comments">; MERIS ET AL BANDS_INDEX = INDGEN(NBANDS) </span>
  <span class="comments">; MODISA BANDS_INDEX = [0,1,15,2,16,20,21,17,18,19]</span>
   
    VZA = MAKE_ARRAY(NBANDS,/FLOAT,VALUE=SENSOR_DATA[VZAID,II])
    VAA = MAKE_ARRAY(NBANDS,/FLOAT,VALUE=SENSOR_DATA[VAAID,II])
    
  <span class="comments">;ADD EXCEPTION FOR PARASOL VIEWING GEOMETRY RECALCULATION>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>></span>
    IF PFLAG EQ 1 THEN BEGIN
    <span class="comments">;SEND THE OBSERVATION TIME, REGION AND FILENAME, TO ANOTHER FUNCTION WHICH WILL GET THE </span>

    <span class="comments">;when loop over each parasol observation</span>
    <span class="comments">; get find which product it's from, send the vza and vaa to find which direction</span>
    <span class="comments">; return the vza and vaa for all bands within that direction</span>

    prdid = where(uprds eq prodnames[ii])
    prdid = prdid[0]
    
    <span class="comments">;compute which direction</span>
    <span class="comments">;returns,[nband,ndirs]</span>
    tvza = reform(paravza[3,*,prdid],16)
    temp = abs(tvza-SENSOR_DATA[VZAID,II])
    p1 = min(temp)
    dirid = where(abs(temp-p1) lt 0.00001)
    dirid = dirid[0]
        
    <span class="comments">;para = get_parasol_viewing_geometries(ACQ_TIME,site,prodnames[ii],icoords,direction)</span>
    <span class="comments">;READ IN THE PIXEL DATA, CALULATE THE NEW VZA AND VAA FOR EACH BAND</span>
   
    VZA[*] = paravza[*,dirid,prdid]
    VAa[*] = paravaa[*,dirid,prdid]

    ENDIF
         
<span class="comments">;    IF NUM_DIRECTIONS GT 1 THEN BEGIN</span>
<span class="comments">;      FOR JJ=1,NUM_DIRECTIONS-1 DO BEGIN</span>
<span class="comments">;        TOA_REF = [TOA_REF,SENSOR_DATA[NUMNONREF+BANDs_INDEX,II+JJ]]</span>
<span class="comments">;        TOA_STD = [TOA_STD,SENSOR_DATA[NUMNONREF+NBANDS+BANDs_INDEX,II+JJ]]</span>
<span class="comments">;        VZA     = [VZA,MAKE_ARRAY(NBANDS,/FLOAT,VALUE=SENSOR_DATA[VZAID,II+JJ])]</span>
<span class="comments">;        VAA     = [VAA,MAKE_ARRAY(NBANDS,/FLOAT,VALUE=SENSOR_DATA[VAAID,II+JJ])]</span>
<span class="comments">;      ENDFOR</span>
<span class="comments">;    ENDIF</span>
  
    RES = WHERE(TOA_REF LT 0.,COUNT)
    IF COUNT GT 0 THEN TOA_REF[RES] = NOVAL
    RES = WHERE(TOA_STD LT 0.,COUNT)
    IF COUNT GT 0 THEN TOA_STD[RES] = NOVAL

<span class="comments">;------------------------------</span>
<span class="comments">; GET SZA AND SAA AND NUMBER OF PIXELS</span>

    PIX = numpixs[II]
    SZA = SENSOR_DATA[SZAID,II]
    SAA = SENSOR_DATA[SAAID,II]

  <span class="comments">;COPY QUICKLOOKS TO AN OUTPUT FOLDER>done</span>
 QL_FOLDER =rdifol+'Site_'+site+dl+sensor+dl+'Proc_'+proc_ver+dl+year+dl
  TMP       = STRLEN(prodnames[ii])
  JPG_FILE  = FILE_SEARCH(QL_FOLDER,string(STRMID(prodnames[ii],0,TMP-4)+'*.jpg'))
  IF SENSOR EQ 'VEGETATION' THEN BEGIN
    TT = STRSPLIT(prodnames[ii],'_',/EXTRACT,/preserve_null)
    QLFOLDER = ql_folder+strjoin(tt[0:n_elements(tt)-4],'_')+dl+'0001'+dl
    JPG_FILE  = FILE_SEARCH(QLFOLDER,'*QUICKLOOK.jpg')
  endif
  if jpg_file[0] eq '' then begin
  print, 'missing quicklook:',prodnames[ii]
  endif else begin
  file_copy,jpg_file[0],jpgfol+dl+string(prodnames[ii]+'.jpg'),/overwrite

<span class="comments">;------------------------------</span>
<span class="comments">; PRINT ALL DATA AS AN INDIVIDUAL LINE, SPACE DELIMITED, TO THE OUTPUTFILE</span>

    PRINTF,OUTF,string(SENSOR+'_'+proc_ver),ACQ_STRING,PROC_STRING,SITE,TOA_REF,TOA_STD,$
      VZA,VAA,PIX,SITE_LAT,SITE_LON,SZA,SAA,string(prodnames[ii]+'.jpg'),$
      FORMAT = '(4(A,1H ),'+STRTRIM(FIX(4*nBANDS),2)+'(F11.6,1H ),1(i10,1H ),2(F10.3,1H ),2(F10.6,1H ),1(A))'

  endelse




  dircount++

  ENDFOR

<span class="comments">;------------------------------</span>
<span class="comments">; CLOSE THE OUTPUT FILE</span>

  FREE_LUN,OUTF

<span class="comments">;------------------------------</span>
<span class="comments">; PRINT END STRING</span>

  PRINT, 'COMPLETED SADE CONVERSION'

END
</code>
    </div>
  </body>
</html>