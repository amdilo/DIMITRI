;**************************************************************************************
;**************************************************************************************
;*
;* NAME:
;*     COMPUTE_RAYLEIGH
;* 
;* PURPOSE:
;*      COMPUTE RAYLEIGH REFLECTANCE AT GIVEN WIND, GEOMETRY AND BAND
;*      WITH MULTILINEAR INTERPOLATION IN 4-DIMENSIONNAL ARRAY 
;* 
;* CALLING SEQUENCE:
;*      RES = COMPUTE_RAYLEIGH(WIND, RAA, VZA, SZA, IBAND)
;* 
;* INPUTS:
;*      WIND  - THE WIND SPEED IN M/S.
;*      RAA   - THE RELATIVE AZIMUTH ANGLE IN DEGREES
;*      VZA   - THE VIEWING ZENITH ANGLE IN DEGREES 
;*      SZA   - THE SOLAR ZENITH ANGLE IN DEGREES
;*      IBAND - THE INDEX OF WAVELENGTH FOR GIVEN SENSOR
;*
;* KEYWORDS:
;*      COS              - INTERPOLATE ZENITH ANGLES IN COSINE
;*      VERBOSE          - PROCESSING STATUS OUTPUTS
;*
;* OUTPUTS:
;*      RHOR             - RAYLEIGH REFLECTANCE 
;*
;* COMMON BLOCKS:
;*      RTM_LUT
;*
;* MODIFICATION HISTORY:
;*        01 NOV 2013 - C MAZERAN - FIRST IMPLEMENTATION
;*
;* VALIDATION HISTORY:
;*        01 NOV 2013 - C MAZERAN - LINUX 64-BIT MACHINE IDL 8.2, NOMINAL COMPILATION AND OPERATION.
;*
;**************************************************************************************
;**************************************************************************************
FUNCTION COMPUTE_RAYLEIGH, WIND, RAA, VZA, SZA, IBAND, COS=COS, VERBOSE=VERBOSE

 COMMON RTM_LUT

;-----------------------------------------
; DEFINE CURRENT FUNCTION NAME

 FCT_NAME = "COMPUTE_RAYLEIGH"

;-----------------------------------------
; CHECK INPUTS CORRESPOND TO
; A ONE-DIMENSIONNAL ARRAY

 S0 = SIZE(WIND,/N_DIMENSIONS)
 S1 = SIZE(RAA,/N_DIMENSIONS)
 S2 = SIZE(VZA,/N_DIMENSIONS)
 S3 = SIZE(SZA,/N_DIMENSIONS)
 S  = [S0, S1, S2, S3]

 IF N_ELEMENTS(UNIQ(S(SORT(S)))) NE 1 THEN BEGIN
   PRINT, FCT_NAME+":ERROR, WORKS ONLY FOR 1D ARRAY"
   RETURN, -1
 ENDIF

;-----------------------------------------
; CHECK INPUTS HAVE THE SAME DIMENSION
 
 N0 = N_ELEMENTS(WIND)
 N1 = N_ELEMENTS(RAA)
 N2 = N_ELEMENTS(VZA)
 N3 = N_ELEMENTS(SZA)
 N  = [N0, N1, N2, N3]
 IF N_ELEMENTS(UNIQ(N(SORT(N)))) NE 1 THEN BEGIN
   PRINT, FCT_NAME+":ERROR, INPUTS DON'T HAVE SAME DIMENSION"
   RETURN, -1
 ENDIF

;-----------------------------------------
; CHECK RHOR_LUT IS LOADED

 IF N_ELEMENTS(RHOR_LUT) EQ 0 THEN BEGIN
   PRINT, FCT_NAME+":ERROR, RHOR_LUT NOT LOADED"
   RETURN, -1
 ENDIF

;-----------------------------------------
; COPY INPUT ARRAY IN GENERIC NAME 

 X = DBLARR([4,N0])
 X[0,*] = WIND
 X[1,*] = RAA
 IF KEYWORD_SET(COS) THEN BEGIN
   X[2,*] = COS(VZA*!DTOR)
   X[3,*] = COS(SZA*!DTOR)
 ENDIF ELSE BEGIN
   X[2,*] = VZA
   X[3,*] = SZA
 ENDELSE

;-----------------------------------------
; COMPUTE INDICES AND WEIGHTS OF THE
; INTERPOLATION 

 IF KEYWORD_SET(VERBOSE) THEN PRINT,FCT_NAME+': COMPUTE INDICES AND WEIGHTS'
 
 INDEX  = INTARR(4,N0)
 WEIGHT = DBLARR(4,N0)

 FOR I=0, 3 DO BEGIN

    IF ( (I EQ 2 OR I EQ 3) AND KEYWORD_SET(COS) ) THEN XREF = COS(RHOR_LUT.(I)*!DTOR) ELSE XREF = RHOR_LUT.(I)

    INDEX[I,*]  = VALUE_LOCATE(XREF, X[I,*])

    ID=WHERE(INDEX[I,*] GE 0 AND INDEX[I,*] LT N_ELEMENTS(XREF)-1, COUNT, NCOMPLEMENT=NCOUNT)
    IF COUNT NE 0 THEN WEIGHT[I,ID]=(X[I,ID]-XREF[INDEX[I,ID]])/(XREF[INDEX[I,ID]+1]-XREF[INDEX[I,ID]])
    IF NCOUNT NE 0 THEN BEGIN
      ID=WHERE(INDEX[I,*] EQ -1 )
      IF ID[0] NE -1 THEN BEGIN
        INDEX[I,ID]   = 0
        WEIGHT[I,ID]  = 0.
      ENDIF
      ID=WHERE(INDEX[I,*] EQ N_ELEMENTS(XREF)-1 )
      IF ID[0] NE -1 THEN BEGIN
        INDEX[I,ID]   = N_ELEMENTS(XREF) - 2
        WEIGHT[I,ID]  = 1.
      ENDIF
    ENDIF

 ENDFOR
 
;-----------------------------------------
; INTERPOLATE IN THE LUT

 IF KEYWORD_SET(VERBOSE) THEN PRINT,FCT_NAME+': INTERPOMATE IN RAYLEIGH LUT'

 DATA = REFORM(RHOR_LUT.DATA[*,*,*,*,IBAND])
 
 RHOR=MAKE_ARRAY(N0,/FLOAT,VALUE=0.)

 FOR I0 = 0, 1 DO BEGIN
 FOR I1 = 0, 1 DO BEGIN
 FOR I2 = 0, 1 DO BEGIN
 FOR I3 = 0, 1 DO BEGIN
    RHOR[*] += (I0?WEIGHT[0,*]:(1.-WEIGHT[0,*]))*$
               (I1?WEIGHT[1,*]:(1.-WEIGHT[1,*]))*$
               (I2?WEIGHT[2,*]:(1.-WEIGHT[2,*]))*$
               (I3?WEIGHT[3,*]:(1.-WEIGHT[3,*]))*DATA[INDEX[0,*]+I0,INDEX[1,*]+I1,INDEX[2,*]+I2,INDEX[3,*]+I3]
 ENDFOR
 ENDFOR
 ENDFOR
 ENDFOR
 
 RETURN, RHOR

END
