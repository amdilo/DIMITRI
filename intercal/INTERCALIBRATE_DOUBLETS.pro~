;**************************************************************************************
;**************************************************************************************
;*
;* NAME:
;*      INTERCALIBRATE_DOUBLETS       
;* 
;* PURPOSE:
;*      COMPUTES THE INTERCALIBRATION COEFICIENTS OF THE DOUBLET DATA FOR TWO SENSORS. 
;*      THE DATA IS SAVED AS SAV VARIABLES WITHIN THE DEFINED OUTPUT FOLDER.
;* 
;* CALLING SEQUENCE:
;*      RES = INTERCALIBRATE_DOUBLETS(OUTPUT_FOLDER,ID_REGION,SENSOR1,BID1,SENSOR2,BID2)      
;* 
;* INPUTS:
;*      OUTPUT_FOLDER     - THE FULL PATH OF THE OUTPUT FOLDER  
;*      ID_REGION         - THE VALIDATION SITE NAME E.G. 'Uyuni'
;*      SENSOR1           - THE NAME OF THE REFERENCE SENSOR FOR INTERCALIBRATION
;*      PROC_VER1         - THE PROCESSING VERISON OF THE REFERENCE SENSOR
;*      BID1              - THE BAND ID FOR THE REFENCE SENSOR BAND E.G. 0 = MERIS 412NM
;*      SENSOR2           - THE NAME OF THE 2ND SENSOR FOR INTERCALIBRATION
;*      PROC_VER2         - THE PROCESSING VERISON OF THE 2ND SENSOR
;*      BID2              - THE BAND ID FOR THE 2ND SENSOR BAND E.G. 0 = MERIS 412NM
;*
;* KEYWORDS:
;*      VERBOSE           - PROCESSING STATUS OUTPUTS
;*
;* OUTPUTS:
;*      STATUS            - 1: NO ERRORS REPORTED, (-1) OR 0: ERRORS DURING INGESTION 
;*
;* COMMON BLOCKS:
;*      NONE
;*
;* MODIFICATION HISTORY:
;*                    - M BOUVET  - PROTOTYPE DIMITRI VERSION
;*        19 JAN 2011 - C KENT    - DIMITRI-2 V1.0
;*        08 FEB 2011 - C KENT    - NOW USING CRAIG B. MARKWARDT'S MPCURVEFIT FUNCTION 
;*                                  INSTEAD OF POLY_FIT AS IT IS MORE FLEXIBLE AND RELIABLE
;*        21 MAR 2011 - C KENT    - MODIFIED FILE DEFINITION TO USE GET_DIMITRI_LOCATION
;*        13 APR 2011 - C KENT    - MODIFIED CSV OUTPUT SECTION
;*        22 APR 2011 - C KENT    - ADDED UNCERTAINTY OUTPUT
;*        06 MAY 2011 - C KENT    - ADDED JPEG OUTPUT
;*        04 JUL 2011 - C KENT    - UPDATE NUMBER OF NON REFLECTANCE VALUES IN SAV ARRAYS
;*        05 JUL 2011 - C KENT    - ADDED MODISA SURFACE DEPENDANCE
;*        08 JUL 2011 - C KENT    - ADDED DIFFERENCE TO REFERENCE SENSOR OUTPUT
;*
;* VALIDATION HISTORY:
;*        13 APR 2011 - C KENT    - WINDOWS 32-BIT IDL 7.1 AND LINUX 64-BIT IDL 8.0 NOMINAL 
;*                                  COMPILATION AND BEHAVIOUR. TESTED FOR MERIS VS MERIS 
;*                                  AND MERIS VS MODIS 
;*
;**************************************************************************************
;**************************************************************************************

FUNCTION INTERCALIBRATE_DOUBLETS,OUTPUT_FOLDER,ID_REGION,SENSOR1,PROC_VER1,BID1,SENSOR2,PROC_VER2,BID2,VERBOSE=VERBOSE

;-----------------------------------------
; CHECK BOTH BIDS ARE VALID
  
  IF KEYWORD_SET(VERBOSE) THEN PRINT,'INTERCALIBRATE_DOUBLETS: STARTNG INTERCALIBRATION, SENSOR1 = ',SENSOR1,' SENSOR2 = ',SENSOR2
  IF BID1 LT 0 OR BID2 LT 0 THEN BEGIN
    PRINT,'INTERCALIBRATE_DOUBLETS: ERROR, BAND INDEXES ARE INVALID'
    RETURN,-1
  ENDIF
 
;----------------------------------------- 
; CHECK INPUT SENSORS AND PROC_VERSIONS 

  IF STRCMP(SENSOR1,SENSOR2) EQ 1 AND $
     STRCMP(PROC_VER1,PROC_VER2) EQ 1 THEN BEGIN
    PRINT, 'INTERCALIBRATE_DOUBLETS: ERROR, TRYING TO COMPARE THE SAME DATA'
    RETURN,-1     
  ENDIF

;-----------------------------------------
; RETRIEVE THE SITE TYPE

  SITE_TYPE = GET_SITE_TYPE(ID_REGION,VERBOSE=VERBOSE)

;-----------------------------------------
; ADD MODIS LAND/OCEAN EXCEPTION
      
  IF SENSOR1 EQ 'MODISA' THEN BEGIN
    IF STRUPCASE(SITE_TYPE) EQ 'OCEAN' THEN TEMP_SENSOR1 = SENSOR1+'_O' ELSE TEMP_SENSOR1 = SENSOR1+'_L'
  ENDIF ELSE TEMP_SENSOR1 = SENSOR1

  IF SENSOR2 EQ 'MODISA' THEN BEGIN
    IF STRUPCASE(SITE_TYPE) EQ 'OCEAN' THEN TEMP_SENSOR2 = SENSOR2+'_O' ELSE TEMP_SENSOR2 = SENSOR2+'_L'
  ENDIF ELSE TEMP_SENSOR2 = SENSOR2
  
;-----------------------------------------
; GET WAVELENGTH ASSOCIATED WITH SENSOR BID
  
  BAND_NAME1 = CONVERT_INDEX_TO_WAVELENGTH(BID1,TEMP_SENSOR1,VERBOSE=VERBOSE)
  BAND_NAME2 = CONVERT_INDEX_TO_WAVELENGTH(BID2,TEMP_SENSOR2,VERBOSE=VERBOSE)
  IF STRCMP(BAND_NAME1,BAND_NAME2)  EQ 0 OR $
     STRCMP(BAND_NAME1,'ERROR')     EQ 1 OR $
     STRCMP(BAND_NAME2,'ERROR')     EQ 1 THEN BEGIN
    PRINT,'INTERCALIBRATE_DOUBLETS: ERROR, TRYING TO COMPARE DIFFERENT WAVELENGTHS OR WAVELENGTH IDS NOT FOUND'
    RETURN,-1
  ENDIF
  IF KEYWORD_SET(VERBOSE) THEN PRINT,'INTERCALIBRATE_DOUBLETS: INPUT BAND INDEXES NOMINAL'

;-----------------------------------------
; CHECK OFOLDER EXISTS AND IS CORRECT FORMAT
  
  RES = FILE_INFO(OUTPUT_FOLDER)
  IF RES.EXISTS EQ 0 THEN BEGIN
    PRINT,"INTERCALIBRATE_DOUBLETS: OUTPUT FOLDER DOESN'T EXIST"
    RETURN,-1
  ENDIF
  
  DL      = GET_DIMITRI_LOCATION('DL')
  OFOLDER = STRING(OUTPUT_FOLDER+DL)

;-----------------------------------------
; DEFINE INPUT/OUTPUT FILES

  IF KEYWORD_SET(VERBOSE) THEN PRINT,'INTERCALIBRATE_DOUBLETS: DEFINING INPUT/OUTPUT FILES'
  CFIG_DATA     = GET_DIMITRI_CONFIGURATION()
  ED_FOLDER= STRING(OFOLDER+'DOUBLET_EXTRACTION'+DL)
  IC_FOLDER= STRING(OFOLDER+'INTERCALIBRATION'+DL)
  S1_IFILE = STRING(ED_FOLDER+'ED_'+ID_REGION+'_'+SENSOR1+'_'+PROC_VER1+'_'+SENSOR2+'_'+PROC_VER2+'.dat')
  S2_IFILE = STRING(ED_FOLDER+'ED_'+ID_REGION+'_'+SENSOR2+'_'+PROC_VER2+'_'+SENSOR1+'_'+PROC_VER1+'.dat')
  CSV_FILE = STRING(OFOLDER  +'ICOEF_'+ID_REGION+'_'+SENSOR2+'_'+PROC_VER2+'_REF_'+SENSOR1+'_'+PROC_VER1+'.csv')
  S2_OFILE = STRING(IC_FOLDER+'ICOEF_'+ID_REGION+'_'+SENSOR2+'_'+PROC_VER2+'_REF_'+SENSOR1+'_'+PROC_VER1+'_'+BAND_NAME1+'.dat')
  S2_EFILE = STRING(IC_FOLDER+'ICERR_'+ID_REGION+'_'+SENSOR2+'_'+PROC_VER2+'_REF_'+SENSOR1+'_'+PROC_VER1+'_'+BAND_NAME1+'.dat')
  H_FILE   = STRING(IC_FOLDER+'HIST_' +ID_REGION+'_'+SENSOR2+'_'+PROC_VER2+'_REF_'+SENSOR1+'_'+PROC_VER1+'_'+BAND_NAME1+'.jpg')
  UC_OFILE = STRING(IC_FOLDER+'IUCRT_'+ID_REGION+'_'+SENSOR2+'_'+PROC_VER2+'_REF_'+SENSOR1+'_'+PROC_VER1+'_'+BAND_NAME1+'.dat')
  JPG_FILE = STRING(IC_FOLDER+'ICREF_'+ID_REGION+'_'+SENSOR2+'_'+PROC_VER2+'_REF_'+SENSOR1+'_'+PROC_VER1+'_'+BAND_NAME1+'.JPG')
  DIF_FILE = STRING(IC_FOLDER+'ICDIF_'+ID_REGION+'_'+SENSOR2+'_'+PROC_VER2+'_REF_'+SENSOR1+'_'+PROC_VER1+'_'+BAND_NAME1+'.dat') 

;--------------------------------
; CREATE INTERCAL FOLDER IF IT DOESN'T EXIST

  RES = FILE_INFO(IC_FOLDER)
  IF RES.EXISTS NE 1 OR RES.DIRECTORY NE 1 THEN BEGIN
    IF KEYWORD_SET(VERBOSE) THEN PRINT,"DIMITRI INTERFACE DOUBLET: INTERCAL FOLDER DOESN'T EXIST, CREATING"
    FILE_MKDIR,IC_FOLDER 
  ENDIF

;-----------------------------------------
; CHECK INPUT FILES EXIST

  TMP_S1 = FILE_INFO(S1_IFILE)
  TMP_S2 = FILE_INFO(S2_IFILE)
  IF TMP_S1.EXISTS EQ 0 OR TMP_S2.EXISTS EQ 0 THEN BEGIN
    PRINT,'INTERCALIBRATE_DOUBLETS: ERROR, INPUT FILES DO NOT EXIST'
    RETURN,-1
  ENDIF

;-----------------------------------------
; SET SENSOR RANDOM UNCERTAINTY AT 5% 
; (IDEALLY SHOULD BE DERIVED FROM EARLIER)

  SEN_UNCERTR = 0.05
  SEN_UNCERTS = 0.03

;-----------------------------------------
; RESTORE THE DATA AND STORE REQUESTED 
; BAND INFORMATION

  IF KEYWORD_SET(VERBOSE) THEN PRINT,'INTERCALIBRATE_DOUBLETS: RESTORING DOUBLET DATA'
  NUM_RECS  = 5+12 ;TIME, ANGLES (4) AND AUX_INFO (12)
  UNCERT_ARRAY = FLTARR(3) ;SYSTEMTIC_ERROR, RANDOM_UNCERTAINTY, POLY_ERROR_FLAG
  UNCERT_ARRAY[0] = SEN_UNCERTS
  RESTORE,S1_IFILE
  RESTORE,S2_IFILE
  S1_DATA   = ED_SENSOR1_SENSOR2[NUM_RECS+BID1,*]
  S2_DATA   = ED_SENSOR2_SENSOR1[NUM_RECS+BID2,*]


;----------------------------------------
; FILTER TO ONLY USE NOMINAL DATA
 
  RAISE_EXCEPTION=1
  RES = WHERE(S1_DATA GT 0.0 AND S1_DATA LT 5.0,VCOUNT)
  IF VCOUNT GT 0 THEN BEGIN
    S1_DATA = S1_DATA[0,RES] 
    S2_DATA = S2_DATA[0,RES]
    TEMPX = ED_SENSOR1_SENSOR2[0,RES]
    RAISE_EXCEPTION=0
  ENDIF

  RES = WHERE(S2_DATA GT 0.0 AND S2_DATA LT 5.0,VCOUNT)
  IF VCOUNT GT 0 THEN BEGIN
    IF RAISE_EXCEPTION EQ 1 THEN GOTO, NO_DOUBLET_DATA
    S2_DATA = S2_DATA[0,RES] 
    S1_DATA = S1_DATA[0,RES]
    TEMPX = TEMPX[0,RES]
  ENDIF
  
  IF VCOUNT EQ 0 OR N_ELEMENTS(S1_DATA[0,*]) LT 3 THEN BEGIN
    NO_DOUBLET_DATA:
    PRINT,'INTERCALIBRATE_DOUBLETS: ERROR, NOT ENOUGH DOUBLETS TO GENERATE POLYNOMIAL' 
    RETURN,-1
  ENDIF

;-----------------------------------------
; FIT THE TEMPORAL EVOLUTION OF THE BIAS BETWEEN 
; THE TWO SENSORS WITH A 2ND ORDER POLYNOMIAL
; USING CRAIG B. MARKWARDT'S MPCURVEFIT FUNCTION TO 
; COMPUTE POLYNOMIAL COEFICIENTS.
; HTTP://COW.PHYSICS.WISC.EDU/~CRAIGM/IDL/IDL.HTML

  IF KEYWORD_SET(VERBOSE) THEN PRINT,'INTERCALIBRATE_DOUBLETS: COMPUTING POLYNOMIAL FIT' 
  ;TEMPX = TRANSPOSE(DOUBLE(ED_SENSOR1_SENSOR2[0,*]))
  TEMPX = TRANSPOSE(TEMPX)
  TEMPY = TRANSPOSE((S2_DATA[0,*]-S1_DATA[0,*])/S1_DATA[0,*]*100.0)
  WEIGHTS = TEMPX
  WEIGHTS[*] = 1.0
  POLY_COEFS = [1.0,1.0,1.0]
  YTEMP = MPCURVEFIT(TEMPX, TEMPY, WEIGHTS, POLY_COEFS, FUNCTION_NAME='DIMITRI_POLYNOMIAL_FIT_FUNCTION', $
                     /AUTODERIVATIVE,STATUS=STATUS)

  IF KEYWORD_SET(VERBOSE) THEN PRINT,'INTERCALIBRATE_DOUBLETS: POLYNOMIAL COEFICIENTS =',POLY_COEFS

;-----------------------------------------
; SAVE THE ACTUAL DIFFERENCE TO THE REFERENCE 
; SENSOR IN A INTERNAL SAV FILE

  ICDIFF_DATA = FLTARR(N_ELEMENTS(TEMPX),3)
  ICDIFF_DATA[*,0] = TEMPX
  ICDIFF_DATA[*,1] = TEMPY  
  ICDIFF_DATA[*,2] = YTEMP
  SAVE, ICDIFF_DATA,FILENAME=DIF_FILE

;-----------------------------------------
; COMPUTE THE ERROR BETWEEN THE POLYNOMIAL 
; FIT AND FITTED POINTS

  IF KEYWORD_SET(VERBOSE) THEN PRINT,'INTERCALIBRATE_DOUBLETS: COMPUTING POLYNOMIAL ERRORS'
  POLY_ERRORS = FLOAT(YTEMP)-TEMPY
  RMSE = 0.01*SQRT(TOTAL(POLY_ERRORS^2)/N_ELEMENTS(POLY_ERRORS))

  IF SEN_UNCERTR LT 3*(RMSE) THEN BEGIN
    UNCERT_ARRAY[1] = 3.*(RMSE)
    UNCERT_ARRAY[2] = 1.
  ENDIF ELSE BEGIN
    UNCERT_ARRAY[1] = SEN_UNCERTR
    UNCERT_ARRAY[2] = 0.  
  ENDELSE

  IF KEYWORD_SET(VERBOSE) THEN PRINT,'INTERCALIBRATE_DOUBLETS: MEAN POLYNOMIAL ERRORS =',MEAN(POLY_ERRORS)

  ERRORS_OUTPUT = MAKE_ARRAY(/FLOAT,N_ELEMENTS(POLY_ERRORS),2)
  ERRORS_OUTPUT[*,0] = TEMPX
  ERRORS_OUTPUT[*,1] = POLY_ERRORS

;------------------------------------------------
; SETUP WINDOW PROPERTIES

  MACHINE_WINDOW = !D.NAME
  YMIN = MIN([TEMPY,YTEMP])
  YMAX = MAX([TEMPY,YTEMP])
  SET_PLOT, 'Z'
  DEVICE, SET_RESOLUTION=[CFIG_DATA.(1)[0],CFIG_DATA.(1)[1]],SET_PIXEL_DEPTH=24
  DEVICE, DECOMPOSED = 0
  ERASE  
  LOADCT, 39

    PLOT,TEMPX,TEMPY,/NODATA,$
      COLOR = 0, BACKGROUND = 255,$
      title  = 'DOUBLET ERROR VS POLYNOMINAL FIT @'+BAND_NAME1,$
      YTITLE = 'DIFFERENCE TO REF SENSOR (%)',$
      XTITLE = 'DECIMAL YEAR',$
      YRANGE = [YMIN,YMAX],$
      XTICKFORMAT='((F8.3))'

    OPLOT,TEMPX,TEMPY,COLOR = 70
    OPLOT,TEMPX,YTEMP,COLOR = 240

    TEMP = TVRD(TRUE=1)
    WRITE_JPEG,JPG_FILE,TEMP,TRUE=1,QUALITY=100
    ERASE
    SET_PLOT, MACHINE_WINDOW


;-----------------------------------------
; OUTPUT HISTOGRAM OF THE ERROR
  
  IF KEYWORD_SET(VERBOSE) THEN PRINT,'INTERCALIBRATE_DOUBLETS: GENERATING HISTOGRAM OF DATA'
  TEMP = GET_HISTOGRAM(H_FILE,POLY_ERRORS,200,HTITLE=STRING('('+SENSOR2+'-'+SENSOR1+')/'+SENSOR1+' IN % @ '+BAND_NAME1),$
                       HX_TITLE='ERROR BETWEEN POLYNOMIAL FIT TO RADIOMETRIC DIFFERENCES AND ACTUAL RADIOMETRIC DIFFERENCES',$
                       HY_TITLE='FREQUENCY')

;-----------------------------------------
; SAVE THE CALIBRATION COEFIFICIENTS

  IF KEYWORD_SET(VERBOSE) THEN PRINT,'INTERCALIBRATE_DOUBLETS: SAVING POLYNOMIAL COEFICIENTS AND ERRORS'
  SAVE, POLY_COEFS    , FILENAME=S2_OFILE
  SAVE, ERRORS_OUTPUT , FILENAME=S2_EFILE
  SAVE, UNCERT_ARRAY  , FILENAME=UC_OFILE

;-----------------------------------------
; STORE DATA IN CSV FILE

  TMP_HEADER = 'REGION;SENSOR;PROCESSING_VERSION;REF_SENSOR;REF_PROCESSING_VERSION;BAND;POLY_COEF_1;POLY_COEF_2;POLY_COEF_3;POLY_ERR_AVG;POLY_ERR_STD;SYS_UNCERT;RAN_UNCERT;POLY_ERR_FLAG'
  TMP_FORMAT = '(6(A,1H;),7(F20.5,1H;),1(F20.5))'
  RES = FILE_INFO(CSV_FILE)
  IF RES.EXISTS EQ 1 THEN OPENW,OUTF,CSV_FILE,/GET_LUN,/APPEND $
  ELSE BEGIN
    OPENW,OUTF,CSV_FILE,/get_lun
    PRINTF,OUTF,TMP_HEADER
  ENDELSE
  PRINTF,OUTF,FORMAT=TMP_FORMAT,ID_REGION,SENSOR2,PROC_VER2,SENSOR1,PROC_VER1,STRING(BAND_NAME1+'_NM'),POLY_COEFS,MEAN(POLY_ERRORS),STDDEV(POLY_ERRORS),UNCERT_ARRAY
  FREE_LUN,OUTF

;-----------------------------------------
; RETURN TO CALLING FUNCTION

  RETURN,1
END