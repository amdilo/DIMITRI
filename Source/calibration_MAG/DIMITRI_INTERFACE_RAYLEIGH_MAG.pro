;**************************************************************************************
;**************************************************************************************
;*
;* NAME:
;*      DIMITRI_INTERFACE_RAYLEIGH_MAG       
;* 
;* PURPOSE:
;*      MAIN RAYLEIGH SENSOR TO SIMULATION COMPARISON ROUTINE 
;* 
;* CALLING SEQUENCE:
;*      RES = DIMITRI_INTERFACE_RAYLEIGH_MAG(SITE_NAME,SENSOR,PROC_VERSION)      
;* 
;* INPUTS:
;*      SITE_NAME = A STRING CONTAINING THE NAME OF THE REGION TO BE USED
;*      SENSOR = A STRING CONTAINING THE NAME OF THE SENSOR TO BE USED
;*      PROC_VERSION = A STRING CONTAINING THE NAME OF THE PROCESSING_VERSION TO BE USED
;*
;* KEYWORDS:
;*      ALL      - SET TO SEARCH FOR ALL DIMITRI PRODUCTS
;*      YEAR     - A STRING OF THE YEAR TO BE INGESTED (E.G. '2002')
;*      VERBOSE  - PROCESSING STATUS OUTPUTS
;*
;* OUTPUTS:
;*      STATUS   - 1: NOMINAL, (-1): ERROR, 0: NO PRODUCTS FOUND
;*
;* COMMON BLOCKS:
;*      NONE
;*
;* MODIFICATION HISTORY:
;*      24 NOV 2014 - NCG / MAGELLIUM      - CREATION
;*
;* VALIDATION HISTORY:
;*      20 JAN 2015 - NCG / MAGELLIUM      - WINDOWS 64BIT MACHINE IDL 8.0: COMPILATION AND OPERATION SUCCESSFUL 
;*      30 MAR 2015 - NCG / MAGELLIUM      - WINDOWS 64BIT MACHINE IDL 8.0: COMPILATION AND OPERATION SUCCESSFUL (DIMITRI V4.0) 
;*
;**************************************************************************************
;**************************************************************************************

FUNCTION DIMITRI_INTERFACE_RAYLEIGH_MAG,SITE_NAME,SENSOR,PROC_VERSION,ALL=ALL,YEAR=YEAR,VERBOSE=VERBOSE

  DEBUG_MODE=0       ; SET TO 1 IF WANT TO DEBUG THIS PROCEDURE
  
  FCT_NAME = 'DIMITRI_INTERFACE_RAYLEIGH_MAG'
  
  METHOD = 'RAYLEIGH_MAG'
  
  ;----------------------
  STATUS_OK = GET_DIMITRI_LOCATION('STATUS_OK')
  STATUS_ERROR = GET_DIMITRI_LOCATION('STATUS_ERROR')
  STATUS_NODATA = GET_DIMITRI_LOCATION('STATUS_NODATA')

  DL         = GET_DIMITRI_LOCATION('DL')
  DIMITRI_DB    = GET_DIMITRI_LOCATION('DATABASE',VERBOSE=VERBOSE)
  INPUT_FOLDER  = GET_DIMITRI_LOCATION('INGESTION_OUTPUT')
  OUTPUT_FOLDER = GET_DIMITRI_LOCATION('OUTPUT')
  MISSING_VALUE_FLT = FLOAT(GET_DIMITRI_LOCATION('NCDF_MISSING_VALUE'))
  MISSING_VALUE_LONG = LONG(GET_DIMITRI_LOCATION('NCDF_MISSING_VALUE'))
  
  MIN_NIR_RAY_CALIBRATION=GET_DIMITRI_LOCATION('MIN_NIR_RAY_CALIBRATION')
  MAX_WS_RAY_CALIBRATION=GET_DIMITRI_LOCATION('MAX_WS_RAY_CALIBRATION')
  MIN_PIXEL_NB_CALIB_PROCESS=GET_DIMITRI_LOCATION('MIN_PIXEL_NB_CALIB_PROCESS')
  MAX_TAU_RAY_CALIBRATION=GET_DIMITRI_LOCATION('MAX_TAU_RAY_CALIBRATION')
  MAX_WAVELENGTH_VALUE_FOR_RAYLEIGH = GET_DIMITRI_LOCATION('MAX_WAVELENGTH_VALUE_FOR_RAYLEIGH')
  
  PRESSURE_CSTE=GET_DIMITRI_LOCATION('PRESSURE_CSTE') ; PRESSURE AS CONSTANTE VALUE / USED IN SMAC CALC
  
  ;---------------------
  ; SEARCH FOR DATA PRODUCTS
  IF KEYWORD_SET(VERBOSE) THEN PRINT, FCT_NAME + ': RETRIEVING PRODUCT SEARCH FILTER'
  SEARCH_FOLDER = INPUT_FOLDER + DL + 'Site_' + SITE_NAME + DL + SENSOR + DL + 'Proc_' + PROC_VERSION + DL

  ;----------------------
  ;  READ THE DIMITRI DATABASE 

  IF KEYWORD_SET(VERBOSE) THEN PRINT, FCT_NAME + ': CHECKING EXISTENCE OF DATABASE FILE'  
  DB_TEMPLATE = GET_DIMITRI_TEMPLATE(1,/TEMPLATE)   
  DB_TEMP = FILE_INFO(DIMITRI_DB)
  IF DB_TEMP.EXISTS EQ 0 THEN BEGIN
    IF KEYWORD_SET(VERBOSE) THEN PRINT, FCT_NAME + ': DATABASE FILE NOT FOUND'
    RETURN, STATUS_ERROR
  ENDIF ELSE BEGIN
    DB_DATA = READ_ASCII(DIMITRI_DB,TEMPLATE=DB_TEMPLATE)
  ENDELSE

  ;----------------------
  ; GET FILES FROM DATABASE
  
  IF KEYWORD_SET(ALL) THEN BEGIN
    ; WITHOUT YEAR FILTERING
    IDX_FILES = WHERE( STRCMP(DB_DATA.SENSOR,SENSOR,/FOLD_CASE) EQ 1 AND $
                       STRCMP(DB_DATA.SITE_NAME,SITE_NAME,/FOLD_CASE) EQ 1 AND $
                       STRCMP(DB_DATA.PROCESSING_VERSION,PROC_VERSION,/FOLD_CASE) EQ 1 AND $
                       DB_DATA.ROI_STATUS EQ 1, NB_FILES) 

  ENDIF ELSE BEGIN
    ; WITH YEAR FILTERING
    IDX_FILES = WHERE( STRCMP(DB_DATA.SENSOR,SENSOR,/FOLD_CASE) EQ 1 AND $
                       STRCMP(DB_DATA.SITE_NAME,SITE_NAME,/FOLD_CASE) EQ 1 AND $
                       STRCMP(DB_DATA.PROCESSING_VERSION,PROC_VERSION,/FOLD_CASE) EQ 1 AND $
                       DB_DATA.ROI_STATUS EQ 1 AND $
                       DB_DATA.YEAR EQ LONG(YEAR) , NB_FILES)        
  ENDELSE

  IF NB_FILES EQ 0 THEN BEGIN
    PRINT, FCT_NAME + ': NO PRODUCTS FOR CALIBRATION'
    RETURN, STATUS_NODATA
  ENDIF
  
  ;----------------------
  ; GET INGESTION OUTPUT FILENAME FROM DATABASE
  
  I_FILES = SEARCH_FOLDER + DL + STRTRIM(STRING(DB_DATA.YEAR[IDX_FILES]),2) + DL + DB_DATA.L1_INGESTED_FILENAME[IDX_FILES]
  FILE_RESULT = FILE_SEARCH(I_FILES, COUNT=NB_FILES_SEARCH)
  
  IF NB_FILES_SEARCH NE NB_FILES THEN BEGIN
    IF KEYWORD_SET(VERBOSE) THEN PRINT, FCT_NAME + ': THE NUMBER OF INGESTION PRODUCTS ON DISK (', NB_FILES_SEARCH, $
                                                    ') DOES NOT MATCH THE NUMBER OF INGESTED PRODUCT IN THE DATABASE (', NB_FILES, ')'
    RETURN, STATUS_ERROR
  ENDIF
  
  ;----------------------
  ; GET BAND INFO STRUCTURE (NB_BANDS, BAND_ID, BAND_LABEL_STD, BAND_WAVELENGTH)
  
  CUR_SENSOR_BAND_INFOS = GET_SENSOR_BAND_INFO(SENSOR)
  NB_BANDS_SENSOR  = CUR_SENSOR_BAND_INFOS.NB_BAND
  NB_DIRECTIONS = SENSOR_DIRECTION_INFO(SENSOR)
  NB_DIRECTIONS = NB_DIRECTIONS[0]

  SENSOR_CONFIG = GET_SENSOR_BAND_CONFIG(SENSOR) ; GET USED CHANNELS / STD LABELS / SMAC FILENAME / LUT FILENAME

  ;-------------------
  ; COMPUTE SENSOR BAND WAVELENGTH TO PROCESS 
  
  SENSOR_BAND_WAVELENGTH = CUR_SENSOR_BAND_INFOS.BAND_WAVELENGTH
  IDX_BANDS_SENSOR_PROCESS = WHERE(SENSOR_BAND_WAVELENGTH LE MAX_WAVELENGTH_VALUE_FOR_RAYLEIGH, NB_BANDS_SENSOR_PROCESS)

  IF NB_BANDS_SENSOR_PROCESS EQ 0 THEN BEGIN
    IF KEYWORD_SET(VERBOSE) THEN PRINT, ': NO SENSOR BAND WAVELENGTHS LOWER THAN RAYLEIGH MAX WAVELENGTH >> RETURNING'
    RETURN, STATUS_ERROR
  ENDIF

  ;-------------------
  ; IDENTIFY NIR SENSOR BAND WAVELENGTH USED FOR TAU ESTIMATION
  
  NIR_BAND_IDX = WHERE( STRMATCH(SENSOR_CONFIG.BAND_LABEL_STD, 'NIR') EQ 1, COUNT)
  IF COUNT EQ 0 THEN BEGIN
    IF KEYWORD_SET(VERBOSE) THEN PRINT, ': NO NIR SENSOR BAND IDENTIFIED >> RETURNING'
    RETURN, STATUS_ERROR
  ENDIF
  IF COUNT GT 1 THEN BEGIN
    IF KEYWORD_SET(VERBOSE) THEN PRINT, ': MORE THAN ONE NIR SENSOR BAND IDENTIFIED >> RETURNING'
    RETURN, STATUS_ERROR
  ENDIF  
  NIR_BAND_IDX = NIR_BAND_IDX[0]
  
  ;----------------------
  ; GET SMAC COEFFICIENTS
  ; SMAC_FILE_STRUCT = { SMAC_FILE_EXIST, SMAC_FILE_LABEL, SMAC_COEFFS }
  
  IF KEYWORD_SET(VERBOSE) THEN PRINT, FCT_NAME + ': READ SMAC COEFFICIENTS FOR SENSOR : ' + SENSOR
  STATUS = GET_SMAC_COEFFICIENTS(SENSOR, SMAC_FILE_STRUCT=SMAC_FILE_STRUCT, VERBOSE=VERBOSE)
  IF STATUS NE STATUS_OK THEN BEGIN
    IF KEYWORD_SET(VERBOSE) THEN PRINT, FCT_NAME + ': ERROR DURING SMAC COEFFICIENTS RETRIEVING >> RETURNING'
    RETURN, STATUS
  ENDIF

  IDX_SMAC_FILE_EXIST = WHERE(SMAC_FILE_STRUCT.SMAC_FILE_EXIST EQ 1, COUNT_SMAC_FILE)
  IF COUNT_SMAC_FILE EQ 0 THEN BEGIN
    IF KEYWORD_SET(VERBOSE) THEN PRINT, FCT_NAME + ': NO SMAC FILE AVAILABLE FOR SENSOR ', SENSOR, ' >> RETURNING'
    RETURN, STATUS_ERROR
  ENDIF
  IF SMAC_FILE_STRUCT.SMAC_FILE_EXIST(NIR_BAND_IDX) EQ 0 THEN BEGIN
    PRINT, FCT_NAME + ': ERROR, NO SMAC FILE AVAILABLE FOR NIR BAND FOR SENSOR ', SENSOR, ' >> RETURNING'
    RETURN, STATUS_ERROR
  ENDIF
   
  ;----------------------
  ; GET RAYLEIGH LUTS COEFFICIENTS
  ;  RAYLEIGH_LUT_FILE_STRUCT = { IDX_VALID_LUT_FILE: IDX_VALID_LUT_FILE, $
  ;                                 LUT_FILE_LABEL: LUT_FILE_LABEL, $
  ;                                 RAYLEIGH_LUT_STRUCT: RAYLEIGH_LUT_STRUCT, $
  ;                                 RAYLEIGH_LUT_NIR_STRUCT: RAYLEIGH_LUT_NIR_STRUCT }
  ;  RAYLEIGH_LUT_STRUCT = { REFL_TOA: MAKE_ARRAY(NB_LINES, COUNT_VALID_LUT_FILE), $
  ;                                  THETA_S : MAKE_ARRAY(NB_LINES), $
  ;                                  THETA_V : MAKE_ARRAY(NB_LINES), $
  ;                                  DPHI    : MAKE_ARRAY(NB_LINES), $
  ;                                  WV      : MAKE_ARRAY(NB_LINES), $
  ;                                  TAU     : MAKE_ARRAY(NB_LINES), $
  ;                                  CHLOROPHYLL : MAKE_ARRAY(NB_LINES) }

  IF KEYWORD_SET(VERBOSE) THEN PRINT, FCT_NAME + ': READ RAYLEIGH LUTS FOR SENSOR : ' + SENSOR
	STATUS = GET_RAYLEIGH_LUTS(SENSOR, RAYLEIGH_LUT_FILE_STRUCT=RAYLEIGH_LUT_FILE_STRUCT, VERBOSE=VERBOSE)
	IF STATUS NE STATUS_OK THEN BEGIN
		IF KEYWORD_SET(VERBOSE) THEN BEGIN
			PRINT, FCT_NAME + ': ERROR DURING READING OF RAYLEIGH LUT VALUES FOR SENSOR ' + SENSOR
		ENDIF
		RETURN, STATUS
	ENDIF
	RAYLEIGH_LUT_STRUCT = RAYLEIGH_LUT_FILE_STRUCT.RAYLEIGH_LUT_STRUCT
	RAYLEIGH_LUT_NIR_STRUCT = RAYLEIGH_LUT_FILE_STRUCT.RAYLEIGH_LUT_NIR_STRUCT
	
  ;----------------------
	; COMPUTE RATIO LUT / TG FOR EACH BANDS TO PROCESS AND NIR BAND
	
  ; NIR BAND
  TG = GET_SMAC_GT_VALUES(SMAC_FILE_STRUCT.SMAC_COEFFS(*,NIR_BAND_IDX), $
                              THETA_S = RAYLEIGH_LUT_NIR_STRUCT.THETA_S, $
                              THETA_V = RAYLEIGH_LUT_NIR_STRUCT.THETA_V, $
                              PRESSURE = PRESSURE_CSTE, OZONE = 0.3, $
                              WATERVAPOUR = RAYLEIGH_LUT_NIR_STRUCT.WV, /RAYLEIGH)
  RAYLEIGH_LUT_NIR_STRUCT.REFL_TOA = RAYLEIGH_LUT_NIR_STRUCT.REFL_TOA / TG
    
	; OTHER BANDS
	FOR NUM_BAND=0, NB_BANDS_SENSOR_PROCESS-1 DO BEGIN  
	  ; CHECK IF SMAC AND LUT FILES AVAILABLE  
	  IDX_NUM_BAND = IDX_BANDS_SENSOR_PROCESS[NUM_BAND]
	  IDX_LUT = WHERE(RAYLEIGH_LUT_FILE_STRUCT.IDX_VALID_LUT_FILE EQ IDX_NUM_BAND, COUNT)	  
	  IF COUNT EQ 1 THEN BEGIN
	    IF SMAC_FILE_STRUCT.SMAC_FILE_EXIST[IDX_NUM_BAND] EQ 0 THEN BEGIN
	      PRINT, FCT_NAME + ': ERROR, NO SMAC FILE AVAILABLE FOR LUT/TG RATIO COMPUTING >> RETURNING'
        RETURN, STATUS_ERROR
      ENDIF      
      TG = GET_SMAC_GT_VALUES(SMAC_FILE_STRUCT.SMAC_COEFFS(*,IDX_NUM_BAND), $
                              THETA_S = RAYLEIGH_LUT_STRUCT.THETA_S, $
                              THETA_V = RAYLEIGH_LUT_STRUCT.THETA_V, $
                              PRESSURE = PRESSURE_CSTE, OZONE = 0.3, $
                              WATERVAPOUR = RAYLEIGH_LUT_STRUCT.WV, /RAYLEIGH)
      RAYLEIGH_LUT_STRUCT.REFL_TOA(*,IDX_LUT) = RAYLEIGH_LUT_STRUCT.REFL_TOA(*,IDX_LUT) / TG            
	  ENDIF
	ENDFOR
		
	; SET ESTIMATION MATRIX DIMENSIONS FOR NIR BAND
	TSI_NIR = RAYLEIGH_LUT_NIR_STRUCT.THETA_S[UNIQ(RAYLEIGH_LUT_NIR_STRUCT.THETA_S, SORT(RAYLEIGH_LUT_NIR_STRUCT.THETA_S))]
	TVI_NIR = RAYLEIGH_LUT_NIR_STRUCT.THETA_V[UNIQ(RAYLEIGH_LUT_NIR_STRUCT.THETA_V, SORT(RAYLEIGH_LUT_NIR_STRUCT.THETA_V))]
	DPI_NIR = RAYLEIGH_LUT_NIR_STRUCT.DPHI[UNIQ(RAYLEIGH_LUT_NIR_STRUCT.DPHI, SORT(RAYLEIGH_LUT_NIR_STRUCT.DPHI))]
	WVI_NIR = RAYLEIGH_LUT_NIR_STRUCT.WV[UNIQ(RAYLEIGH_LUT_NIR_STRUCT.WV, SORT(RAYLEIGH_LUT_NIR_STRUCT.WV))]
	TAI_NIR = RAYLEIGH_LUT_NIR_STRUCT.TAU[UNIQ(RAYLEIGH_LUT_NIR_STRUCT.TAU, SORT(RAYLEIGH_LUT_NIR_STRUCT.TAU))]

	; SET ESTIMATION MATRIX DIMENSIONS FOR OTHER BANDS
	TSI = RAYLEIGH_LUT_STRUCT.THETA_S[UNIQ(RAYLEIGH_LUT_STRUCT.THETA_S, SORT(RAYLEIGH_LUT_STRUCT.THETA_S))]
	TVI = RAYLEIGH_LUT_STRUCT.THETA_V[UNIQ(RAYLEIGH_LUT_STRUCT.THETA_V, SORT(RAYLEIGH_LUT_STRUCT.THETA_V))]
	DPI = RAYLEIGH_LUT_STRUCT.DPHI[UNIQ(RAYLEIGH_LUT_STRUCT.DPHI, SORT(RAYLEIGH_LUT_STRUCT.DPHI))]
	WVI = RAYLEIGH_LUT_STRUCT.WV[UNIQ(RAYLEIGH_LUT_STRUCT.WV, SORT(RAYLEIGH_LUT_STRUCT.WV))]
	TAI = RAYLEIGH_LUT_STRUCT.TAU[UNIQ(RAYLEIGH_LUT_STRUCT.TAU, SORT(RAYLEIGH_LUT_STRUCT.TAU))]
	CLI = RAYLEIGH_LUT_STRUCT.CHLOROPHYLL[UNIQ(RAYLEIGH_LUT_STRUCT.CHLOROPHYLL, SORT(RAYLEIGH_LUT_STRUCT.CHLOROPHYLL))]

	ROR=LINSPACE(0,0.35,INC=0.05) ; roR= ref/tg

  ;----------------------
  ; SET OUTPUT CALIB FOLDER
  
  CALDAT, SYSTIME(/UTC,/JULIAN),TMM,TDD,TYY,THR,TMN,TSS

  TYY = STRTRIM(STRING(TYY),2)
  TMM = TMM LT 10 ? '0'+STRTRIM(STRING(TMM),2) : STRTRIM(STRING(TMM),2)
  TDD = TDD LT 10 ? '0'+STRTRIM(STRING(TDD),2) : STRTRIM(STRING(TDD),2)
  THR = THR LT 10 ? '0'+STRTRIM(STRING(THR),2) : STRTRIM(STRING(THR),2)
  TMN = TMN LT 10 ? '0'+STRTRIM(STRING(TMN),2) : STRTRIM(STRING(TMN),2)
  TSS = TSS LT 10 ? '0'+STRTRIM(STRING(TSS,FORMAT='(I)'),2) : STRTRIM(STRING(TSS,FORMAT='(I)'),2)

  PROCESS_DATE = TYY+TMM+TDD+'-'+THR+TMN

  OUT_FILEPATH = OUTPUT_FOLDER + DL + METHOD + '_' + PROCESS_DATE + DL + 'Site_'+ SITE_NAME + DL + SENSOR + DL + 'Proc_' + PROC_VERSION + DL
  OUT_FILENAME_BASE =  SITE_NAME + '_' + SENSOR + '_' + PROC_VERSION + '_' + METHOD 
          
  ;----------------------
  ; LOOP OVER NCDF FILE IN PROCESSING DATASET

  FOR IDX_FILE=0, NB_FILES-1 DO BEGIN

    NCDF_FILENAME = FILE_RESULT[IDX_FILE]
    NCDF_INFOS = FILE_INFO(NCDF_FILENAME)
    
    IF NCDF_INFOS.EXISTS EQ 0 OR STRLEN(NCDF_FILENAME) EQ 0 THEN BEGIN
      IF KEYWORD_SET(VERBOSE) THEN PRINT,FCT_NAME + ': FILE ',NCDF_FILENAME,' IS MISSING, PLEASE CHECK YOUR INGESTION PROGRESS'
      GOTO, NEXT_IFILES
    ENDIF

    CUR_NCFILE = FILE_BASENAME(NCDF_FILENAME)
    
    ;----------------------
    ; GET ACQUISITION DATE FROM NCDF FILE
    CUR_NCDF_DATE = STRTRIM(GET_NCDF_GLOBAL_ATT(NCDF_FILENAME, 'ACQUISITION_DATE'))
    NCDF_YEAR_STR=STRMID(CUR_NCDF_DATE,0,4)
    NCDF_MONTH_STR=STRMID(CUR_NCDF_DATE,5,2)
    NCDF_DAY_STR=STRMID(CUR_NCDF_DATE,8,2)
    NCDF_HOURS_STR=STRMID(CUR_NCDF_DATE,11,2)
    NCDF_MINUTES_STR=STRMID(CUR_NCDF_DATE,14,2)
    
    NCDF_YEAR=UINT(NCDF_YEAR_STR)
    NCDF_MONTH=UINT(NCDF_MONTH_STR)
    NCDF_DAY=UINT(NCDF_DAY_STR)
    NCDF_HOURS=UINT(NCDF_HOURS_STR)
    NCDF_MINUTES=UINT(NCDF_MINUTES_STR)
    
    ACQUI_DATE = JULDAY(NCDF_MONTH,NCDF_DAY,NCDF_YEAR,NCDF_HOURS,NCDF_MINUTES,0)
    
    IF KEYWORD_SET(VERBOSE) THEN BEGIN
      PRINT, '[' + STRTRIM(STRING(IDX_FILE+1),1) + '/' + STRTRIM(STRING(NB_FILES),1) + '] > ' + FCT_NAME + ' ' + CUR_NCFILE + ' :: ' + CUR_NCDF_DATE
    ENDIF

    ;----------------------
    ; READ INPUT INGESTION FILE
    
    STATUS = NETCDFREAD_INGEST_OUTPUT( NCDF_FILENAME, NCDF_INGEST_STRUCT=NCDF_INGEST_STRUCT, VERBOSE=VERBOSE)
    IF STATUS NE STATUS_OK THEN BEGIN
      IF KEYWORD_SET(VERBOSE) THEN BEGIN
        PRINT, FCT_NAME + ': ERROR DURING ', FILE_BASENAME(NCDF_FILENAME),' FILE READING >> FILE SKIPPED'
      ENDIF
      GOTO, NEXT_IFILES
    ENDIF  
        
    IF NB_DIRECTIONS NE NCDF_INGEST_STRUCT.DIMENSIONS.VIEWDIR_NUMBER THEN BEGIN
      IF KEYWORD_SET(VERBOSE) THEN BEGIN
        PRINT, FCT_NAME + ': NUMBER OF VIEWING DIRECTIONS IN NCDF FILE (', NCDF_INGEST_STRUCT.DIMENSIONS.VIEWDIR_NUMBER, $
                              ') DOES NOT MATCH TO THE NUMBER OF SENSOR VIEWING DIRECTION (', NB_DIRECTIONS, ') >> FILE SKIPPED'
      ENDIF
      GOTO, NEXT_IFILES
    ENDIF
          
    ;----------------------
    ; APPLY CLOUD SCREENING RATIO CRITERIA (ONE DIRECTION SENSOR)
    
    IF NB_DIRECTIONS EQ 1 AND NCDF_INGEST_STRUCT.GLOBAL_ATT.AUTO_CS_2_MEAN GT 0.54 THEN BEGIN
      PRINT,FCT_NAME + ': AUTO_CS_2_MEAN GREATER THAN 54% (', STRTRIM(STRING(NCDF_INGEST_STRUCT.GLOBAL_ATT.AUTO_CS_2_MEAN*100),2), '%) : FILE SKIPPED'
      GOTO, NEXT_IFILES
    ENDIF
                             
    ;----------------------
    ; COMPUTE MAXIMAL COUNT PIXEL CLEAR ACROSS DIRECTION FOR AN ESTIMATION OF VALID CALIBRATION PIXELS
    
    COUNT_CS_CLEAR_PIX_MAX = 0
    FOR NUM_DIR=0, NB_DIRECTIONS-1 DO BEGIN
      INDX_CS_MASK_CLEAR = WHERE(NCDF_INGEST_STRUCT.VARIABLES.AUTO_CS_2_MASK(*,NUM_DIR) EQ 0, COUNT_CS_CLEAR_PIX)
      COUNT_CS_CLEAR_PIX_MAX = MAX( [ COUNT_CS_CLEAR_PIX_MAX, COUNT_CS_CLEAR_PIX ] )
    ENDFOR
    
    IF COUNT_CS_CLEAR_PIX_MAX LT MIN_PIXEL_NB_CALIB_PROCESS THEN BEGIN
      IF KEYWORD_SET(VERBOSE) THEN BEGIN
        PRINT, ' NB_CLEAR_PIX = ' + STRTRIM(STRING(COUNT_CS_CLEAR_PIX_MAX),1) + ' < MIN_PIXEL_NB_CALIB_PROCESS : FILE SKIPPED '
      ENDIF 
      GOTO, NEXT_IFILES
    ENDIF 
    
    ;----------------------
    ; GET NCDF STRUCTURE FOR CALIBRATION OUTPUT
    
    CALIB_PIXEL_NUMBER = COUNT_CS_CLEAR_PIX_MAX
    
    NCDF_CALIB_STRUCT = GET_NCDF_CALIB_STRUCT(CALIB_PIXEL_NUMBER, NCDF_INGEST_STRUCT.DIMENSIONS.ROI_PIXEL_NUMBER, NB_DIRECTIONS, NB_BANDS_SENSOR_PROCESS, VERBOSE=VERBOSE)
    NCDF_CALIB_STRUCT.GLOBAL_ATT.CALIBRATION_METHOD = METHOD
    NCDF_CALIB_STRUCT.VARIABLES.REFL_BAND_IDS = IDX_BANDS_SENSOR_PROCESS
    
    ;----------------------
    ; COPY COMMON INFOS FROM INGESTION NCDF TO CALIBRATION NCDF
    STATUS = COPY_INGESTION_TO_CALIBRATION_NCDF_STRUCTURE(NCDF_INGEST_STRUCT=NCDF_INGEST_STRUCT, NCDF_CALIB_STRUCT=NCDF_CALIB_STRUCT, VERBOSE=VERBOSE)
    IF STATUS NE STATUS_OK THEN RETURN, STATUS
    
    ;----------------------
    ; LOOP OVER VIEWING DIRECTION

    AT_LEAST_ONE_DIR = 0
    
    FOR NUM_DIR=0, NB_DIRECTIONS-1 DO BEGIN
                  
      IF NUM_DIR+1 LT 10 THEN DIR_ID = 'DIR0' + STRTRIM(STRING(NUM_DIR+1),2) $
                         ELSE DIR_ID = 'DIR' + STRTRIM(STRING(NUM_DIR+1),2)
                          
      IF KEYWORD_SET(VERBOSE) THEN BEGIN
        PRINT, FCT_NAME + ': ----- PROCESS DIRECTION [' + DIR_ID + '/' + STRTRIM(STRING(NB_DIRECTIONS),1) + ']'
      ENDIF
      
      IF NCDF_INGEST_STRUCT.VARIABLES.ROI_STATUS[NUM_DIR] EQ 0 THEN BEGIN
        IF KEYWORD_SET(VERBOSE) THEN BEGIN
          PRINT, FCT_NAME + ': ROI STATUS WITH 0 VALUE >> DIRECTION SKIPPED'
        ENDIF
        GOTO, NEXT_DIR
      ENDIF
     
      ;----------------------
      ; APPLY CLOUD SCREENING RATIO CRITERIA (MULTI DIRECTION SENSOR)
      
      IF NB_DIRECTIONS NE 1 AND NCDF_INGEST_STRUCT.GLOBAL_ATT.AUTO_CS_2_MEAN GT 0.50 THEN BEGIN
      
        VALID_PIXEL = WHERE(NCDF_INGEST_STRUCT.VARIABLES.AUTO_CS_2_VALID_INDEX[*, NUM_DIR] NE MISSING_VALUE_LONG, NB_VALID_PIX)
        IF NB_VALID_PIX EQ 0 THEN BEGIN
          PRINT, FCT_NAME + 'ERROR: NO CLOUD SCREENING VALID PIXEL'
          RETURN, STATUS_ERROR
        ENDIF
        
        CLOUD_PIXEL = WHERE(NCDF_INGEST_STRUCT.VARIABLES.AUTO_CS_2_MASK[VALID_PIXEL, NUM_DIR] EQ 1, NB_CLOUD_PIX)
        IF NB_CLOUD_PIX NE 0 THEN BEGIN
          CLOUD_PERCENTAGE = DOUBLE(NB_CLOUD_PIX) / DOUBLE(NB_VALID_PIX)
          IF CLOUD_PERCENTAGE GT 0.50 THEN BEGIN
            PRINT,FCT_NAME + ': CLOUD PERCENTAGE GREATER THAN 50% (', STRTRIM(STRING(CLOUD_PERCENTAGE*100),2), '%) : DIRECTION SKIPPED'
            GOTO, NEXT_DIR
          ENDIF
        ENDIF
        
      ENDIF
                             
      ;----------------------
      ; CHECK COUNT_CS_CLEAR_PIX 
      
      ; CLOUD SCREENING RESULT 1=CLOUD 0=CLEAR
      CLOUD_MASK = NCDF_INGEST_STRUCT.VARIABLES.AUTO_CS_2_MASK(*,NUM_DIR)

      ; IDENTIFY AND SELECT CLEAR PIXELS ACCORDING CLOUD SCREENING MASK
      INDX_CS_MASK_CLEAR = WHERE(CLOUD_MASK EQ 0, COUNT_CS_CLEAR_PIX)
      
      IF COUNT_CS_CLEAR_PIX LT MIN_PIXEL_NB_CALIB_PROCESS THEN BEGIN
        IF KEYWORD_SET(VERBOSE) THEN BEGIN
          PRINT, ' NB_CLEAR_PIX = ' + STRTRIM(STRING(COUNT_CS_CLEAR_PIX),1) + ' < MIN_PIXEL_NB_CALIB_PROCESS : DIRECTION SKIPPED'
        ENDIF 
        GOTO, NEXT_DIR
      ENDIF 
    
      NB_PIX = COUNT_CS_CLEAR_PIX
    
      ;----------------------
      ; GET VARIABLES FROM NCDF DATA STRUCTURE
      
      LAT = NCDF_INGEST_STRUCT.VARIABLES.LAT(*,NUM_DIR)    ; LATITUDE
      LON = NCDF_INGEST_STRUCT.VARIABLES.LON(*,NUM_DIR)    ; LONGITUDE
      
      THETA_S = NCDF_INGEST_STRUCT.VARIABLES.SZA(*,NUM_DIR) ; SUN ZENITH ANGLE
      PHI_S   = NCDF_INGEST_STRUCT.VARIABLES.SAA(*,NUM_DIR) ; SUN AZIMUTH ANGLE
      THETA_V = NCDF_INGEST_STRUCT.VARIABLES.VZA(*,NUM_DIR) ; VIEWING ZENITH ANGLE
      PHI_V   = NCDF_INGEST_STRUCT.VARIABLES.VAA(*,NUM_DIR) ; VIEWING AZIMUTH ANGLE
      
      ; GET METEO AUX_DATA 
      WIND_SPEED = NCDF_INGEST_STRUCT.VARIABLES.ERA_WIND_SPEED(*,NUM_DIR)
      WIND_DIRECTION = NCDF_INGEST_STRUCT.VARIABLES.ERA_WIND_DIR(*,NUM_DIR)
      WATERVAPOUR = NCDF_INGEST_STRUCT.VARIABLES.ERA_WATERVAPOUR(*,NUM_DIR)
      OZONE = NCDF_INGEST_STRUCT.VARIABLES.ERA_OZONE(*,NUM_DIR)
      CHLORO = NCDF_INGEST_STRUCT.VARIABLES.ESA_CHLOROPHYLL(*,NUM_DIR)
      ;PRESSURE = NCDF_INGEST_STRUCT.VARIABLES.ERA_PRESSURE(*,NUM_DIR)
         
      ;----------------------
      ; LIMIT INPUT DATA TO CS CLEAR PIXELS
      
      LAT_CS_CLEAR = LAT(INDX_CS_MASK_CLEAR)
      LON_CS_CLEAR = LON(INDX_CS_MASK_CLEAR)
      
      IF KEYWORD_SET(VERBOSE) THEN BEGIN
        PRINT, ' NB_CLEAR_PIX = ' + STRTRIM(STRING(COUNT_CS_CLEAR_PIX),1)
        PRINT, ' SITE: ' + SITE_NAME + ' / NORTH: ' + STRTRIM(STRING(MAX(LAT_CS_CLEAR)),1) $
                    + '째 / SOUTH: ' + STRTRIM(STRING(MIN(LAT_CS_CLEAR)),1) $
                    + '째 / EAST: ' + STRTRIM(STRING(MAX(LON_CS_CLEAR)),1) $
                    + '째 / WEST: ' + STRTRIM(STRING(MIN(LON_CS_CLEAR)),1) + '째'
      ENDIF

      ;-------------------
			; NIR BOTTOM LIMIT (NIR RTOA > 0.045) AND WIND SPEED LIMIT (WS < 5 m/s)		

      RTOA_NIR_OBS = NCDF_INGEST_STRUCT.VARIABLES.REFL_BAND[*,NUM_DIR, NIR_BAND_IDX]
		  INDX_NAN = WHERE(RTOA_NIR_OBS EQ MISSING_VALUE_FLT, COUNT_MISSING_VALUE, COMPLEMENT=IDX_VALID)
		  IF COUNT_MISSING_VALUE GT 0 THEN RTOA_NIR_OBS(INDX_NAN)=!VALUES.F_NAN          
			
			INDX_NIR_WS_VLD = WHERE(    RTOA_NIR_OBS(INDX_CS_MASK_CLEAR) LT MIN_NIR_RAY_CALIBRATION $
															AND WIND_SPEED(INDX_CS_MASK_CLEAR) LT MAX_WS_RAY_CALIBRATION $
															AND CHLORO(INDX_CS_MASK_CLEAR) LT 0.1 $
															AND THETA_V(INDX_CS_MASK_CLEAR) LT 60, COUNT_NIR_WS_VALID)  
			
			IF COUNT_NIR_WS_VALID LT MIN_PIXEL_NB_CALIB_PROCESS THEN BEGIN
			  IF KEYWORD_SET(VERBOSE) THEN BEGIN       
				  PRINT, ' NB_PIX VALID (WIND SPEED + NIR RTOA CONDITIONS VALUES) = ' + STRTRIM(STRING(COUNT_NIR_WS_VALID),1) + ' < ' + STRTRIM(STRING(MIN_PIXEL_NB_CALIB_PROCESS),1) + ' : DIRECTION SKIPPED FROM RAYLEIGH CALIBRATION'
			  ENDIF
				GOTO, NEXT_DIR
			ENDIF

      ;----------------------
      ; LIMIT INPUT DATA TO CLOUD, WIND SPEED AND NIR CRITERIA (VALID PIXELS)
      
      ; BUILD PIXEL INDEX INPUT TO CLOUD, WIND SPEED AND NIR CRITERIA
      INDX_IN_2_NIRWS_VLD = INDX_CS_MASK_CLEAR(INDX_NIR_WS_VLD)

      THETA_S_VLD = THETA_S(INDX_IN_2_NIRWS_VLD)
      PHI_S_VLD   = PHI_S(INDX_IN_2_NIRWS_VLD)
      THETA_V_VLD = THETA_V(INDX_IN_2_NIRWS_VLD)
      PHI_V_VLD   = PHI_V(INDX_IN_2_NIRWS_VLD)
      WATERVAPOUR_VLD = WATERVAPOUR(INDX_IN_2_NIRWS_VLD)
      OZONE_VLD = OZONE(INDX_IN_2_NIRWS_VLD)

      DPHI_VLD = ABS(PHI_S_VLD - PHI_V_VLD)
      INDX_DPHI_INV=WHERE(DPHI_VLD GT 180, COUNT_DPHI_INV)
      IF COUNT_DPHI_INV GT 0 THEN DPHI_VLD(INDX_DPHI_INV) = 360 - DPHI_VLD(INDX_DPHI_INV)

      ;----------------------
			; SEARCH OF AEROSOL TAU55 WITH NIR BAND
			
			NIR_SMAC_COEFFS = SMAC_FILE_STRUCT.SMAC_COEFFS(*,NIR_BAND_IDX)
			TG_NIR = GET_SMAC_GT_VALUES(NIR_SMAC_COEFFS, THETA_S = THETA_S_VLD, THETA_V = THETA_V_VLD, $
				PRESSURE = PRESSURE_CSTE, OZONE = OZONE_VLD, WATERVAPOUR = WATERVAPOUR_VLD, /RAYLEIGH)

			RTOA_NIR = RTOA_NIR_OBS(INDX_IN_2_NIRWS_VLD) 
			RTOA_TG_RATIO_NIR = RTOA_NIR / TG_NIR

			; TAU IS EVALUATED WITH INVERTED MODEL TAU_INV[INDX_TS,INDX_TV,INDX_DPHI,INDX_WV,INDX_RO]
      TAU_ESTIM = INTERP5D(RAYLEIGH_LUT_NIR_STRUCT.REFL_TOA, $
                           THETA_S_VLD, THETA_V_VLD, DPHI_VLD, WATERVAPOUR_VLD, RTOA_TG_RATIO_NIR, $
                           TSI_NIR, TVI_NIR, DPI_NIR, WVI_NIR, TAI_NIR, /INVERSE_Z)
      
			INDX_TAU_VLD = WHERE(TAU_ESTIM LT MAX_TAU_RAY_CALIBRATION AND TAU_ESTIM GT 0.0, COUNT_TAU_VLD_RANGE)

			IF COUNT_TAU_VLD_RANGE LT MIN_PIXEL_NB_CALIB_PROCESS THEN BEGIN
				IF KEYWORD_SET(VERBOSE) THEN BEGIN
					PRINT, ' COUNT_TAU_VLD_RANGE = ' + STRTRIM(STRING(COUNT_TAU_VLD_RANGE),1) + ' < ' + STRTRIM(STRING(MIN_PIXEL_NB_CALIB_PROCESS),1) +' : DIRECTION SKIPPED FOR RAYLEIGH CALIBRATION'
				ENDIF
					GOTO, NEXT_DIR
			ENDIF

      IF DEBUG_MODE EQ 1 THEN BEGIN
        PRINT, ' DEBUG MODE - COUNT_TAU_VLD_RANGE = ', COUNT_TAU_VLD_RANGE
        PRINT, ' DEBUG MODE - MIN/MAX/MEAN = ', MIN(TAU_ESTIM(INDX_TAU_VLD)), '/', MAX(TAU_ESTIM(INDX_TAU_VLD)), '/', MEAN(TAU_ESTIM(INDX_TAU_VLD))
      ENDIF
      
      ;----------------------
      ; LIMIT INPUT DATA TO CLOUD, WIND SPEED, NIR AND TAU CRITERIA (VALID PIXELS)

			TAU_ESTIM_VLD = TAU_ESTIM(INDX_TAU_VLD)
			TG_NIR_VLD = TG_NIR(INDX_TAU_VLD)

			; BUILD PIXEL INDEX INPUT TO TAU RANGE VALID
			INDX_IN_2_NIRWSTAU_VLD = INDX_CS_MASK_CLEAR(INDX_NIR_WS_VLD(INDX_TAU_VLD))

			LAT_VLD = LAT(INDX_IN_2_NIRWSTAU_VLD)
			LON_VLD = LON(INDX_IN_2_NIRWSTAU_VLD)
			THETA_S_VLD = THETA_S(INDX_IN_2_NIRWSTAU_VLD)
			PHI_S_VLD   = PHI_S(INDX_IN_2_NIRWSTAU_VLD)
			THETA_V_VLD = THETA_V(INDX_IN_2_NIRWSTAU_VLD)
			PHI_V_VLD   = PHI_V(INDX_IN_2_NIRWSTAU_VLD)
			WATERVAPOUR_VLD = WATERVAPOUR(INDX_IN_2_NIRWSTAU_VLD) 
			OZONE_VLD       = OZONE(INDX_IN_2_NIRWSTAU_VLD)
			CHLORO_VLD      = CHLORO(INDX_IN_2_NIRWSTAU_VLD)

			DPHI_VLD = ABS(PHI_S_VLD - PHI_V_VLD)
			INDX_DPHI_INV=WHERE(DPHI_VLD GT 180, COUNT_DPHI_INV)
			IF COUNT_DPHI_INV GT 0 THEN DPHI_VLD(INDX_DPHI_INV) = 360 - DPHI_VLD(INDX_DPHI_INV)

      ;-------------------
      ; COMPLETE NCDF CALIBRATION STRUCTURE
      
      NB_PIX = N_ELEMENTS(INDX_IN_2_NIRWSTAU_VLD)
      NCDF_CALIB_STRUCT.VARIABLES.CALIB_PIXEL_NUMBER(NUM_DIR) = NB_PIX
      NCDF_CALIB_STRUCT.VARIABLES.CALIB_VALID_INDEX(0:NB_PIX-1,NUM_DIR) = INDX_IN_2_NIRWSTAU_VLD
      
      NCDF_CALIB_STRUCT.VARIABLES.AEROSOL_OT_ESTIM(0:NB_PIX-1,NUM_DIR)   = TAU_ESTIM_VLD

      ;-------------------
      ; LOOP ON SENSOR BANDS TO PROCESS
      
      FOR NUM_BAND=0, NB_BANDS_SENSOR_PROCESS-1 DO BEGIN
  
				IDX_NUM_BAND = IDX_BANDS_SENSOR_PROCESS[NUM_BAND]
				
				IF IDX_NUM_BAND+1 LT 10 THEN BAND_ID = '0' + STRTRIM(STRING(IDX_NUM_BAND+1),2) $
														    ELSE BAND_ID = STRTRIM(STRING(IDX_NUM_BAND+1),2)

				WAVELENGTH = STRTRIM(STRING(SENSOR_CONFIG.BAND_WAVELENGTH[IDX_NUM_BAND]),2)

				IF KEYWORD_SET(VERBOSE) THEN PRINT, SENSOR + ' :: ID : ' + STRTRIM(STRING(SENSOR_CONFIG.BAND_ID[IDX_NUM_BAND]),1) + $
																						', LABEL_STD : ' + SENSOR_CONFIG.BAND_LABEL_STD[IDX_NUM_BAND] + $
																						', REF_LABEL : ' + SENSOR_CONFIG.BAND_REF_LABEL[IDX_NUM_BAND] + $
																						', WAVELENGTH : ' + WAVELENGTH

        ;-------------------
				; CHECK IF LUT AVAILABLE FOR CURRENT BAND
				IDX_LUT = WHERE(RAYLEIGH_LUT_FILE_STRUCT.IDX_VALID_LUT_FILE EQ IDX_NUM_BAND, COUNT)
				IF COUNT NE 1 THEN BEGIN
					PRINT, FCT_NAME + ': WARNING, NO LUTS AVAILABLE FOR BAND ', BAND_ID, ' (WAVELENGTH=', WAVELENGTH, ') >> BAND SKIPPED'
					GOTO, NEXT_BAND
				ENDIF

        ;-------------------
        ; CHECK IF CURRENT BAND IS NIR BAND
				IF IDX_NUM_BAND EQ NIR_BAND_IDX THEN BEGIN
         
         	IF DEBUG_MODE EQ 1 THEN BEGIN
         	
						RTOA_TG_RATIO_NIR_VLD = RTOA_TG_RATIO_NIR(INDX_TAU_VLD)
						NIR_ESTIM = INTERP5D(LUT_NIR, $
																 THETA_S_VLD, THETA_V_VLD, DPHI_VLD, WATERVAPOUR_VLD, TAU_ESTIM_VLD, $
																 TSI_NIR, TVI_NIR, DPI_NIR, WVI_NIR, TAI_NIR)
						AK_NIR_ESTIM = RTOA_TG_RATIO_NIR_VLD / DOUBLE(NIR_ESTIM);
         	
         	ENDIF ELSE GOTO, NEXT_BAND
         
        ENDIF
         
        IF SMAC_FILE_STRUCT.SMAC_FILE_EXIST(IDX_NUM_BAND) EQ 0 THEN GOTO, NEXT_BAND
         
        RTOA_OBS = NCDF_INGEST_STRUCT.VARIABLES.REFL_BAND[*,NUM_DIR, IDX_NUM_BAND]
        RTOA_OBS = RTOA_OBS(INDX_IN_2_NIRWSTAU_VLD)

        INDX_NAN = WHERE(RTOA_OBS EQ MISSING_VALUE_FLT, COUNT_MISSING_VALUE, NCOMPLEMENT=COUNT_VALID, COMPLEMENT=IDX_VALID)
        IF COUNT_MISSING_VALUE GT 0 THEN RTOA_OBS(INDX_NAN)=!VALUES.F_NAN 
        IF COUNT_VALID EQ 0 THEN BEGIN
          PRINT, FCT_NAME + ': WARNING, NO VALID VALUE FOR BAND ', SENSOR_CONFIG.BAND_REF_LABEL[IDX_NUM_BAND], ', RESULTS SET AS MISSING VALUE FOR THIS BAND'
          GOTO, NEXT_BAND
        ENDIF 

				TG = GET_SMAC_GT_VALUES(SMAC_FILE_STRUCT.SMAC_COEFFS(*,IDX_NUM_BAND), THETA_S = THETA_S_VLD, THETA_V = THETA_V_VLD, $
					PRESSURE = PRESSURE_CSTE, OZONE = OZONE_VLD, WATERVAPOUR = WATERVAPOUR_VLD, /RAYLEIGH)

				RTOA_TG_RATIO = RTOA_OBS / TG

        RTOA_TG_RATIO_ESTIM = INTERP6D(RAYLEIGH_LUT_STRUCT.REFL_TOA(*,IDX_LUT), $
                             THETA_S_VLD, THETA_V_VLD, DPHI_VLD, WATERVAPOUR_VLD, TAU_ESTIM_VLD, CHLORO_VLD, $
                             TSI, TVI, DPI, WVI, TAI, CLI)

				REF_TO_SIM_RATIO = RTOA_TG_RATIO / DOUBLE(RTOA_TG_RATIO_ESTIM);

				RTOA_OBS_VLD = RTOA_OBS(IDX_VALID)
				TG_VLD = TG(IDX_VALID)
				RTOA_TG_RATIO_VLD = RTOA_TG_RATIO(IDX_VALID)
				RTOA_TG_RATIO_ESTIM_VLD = RTOA_TG_RATIO_ESTIM(IDX_VALID)
				REF_TO_SIM_RATIO_VLD = REF_TO_SIM_RATIO(IDX_VALID)

        IF DEBUG_MODE EQ 1 THEN BEGIN
					PRINT, ' ------ BAND ID: ', NCDF_CALIB_STRUCT.VARIABLES.REFL_BAND_IDS[NUM_BAND], SENSOR_CONFIG.BAND_REF_LABEL[IDX_NUM_BAND]
          PRINT, ' DEBUG MODE - SMAC_COEFFS = ', SMAC_FILE_STRUCT.SMAC_COEFFS(*,IDX_NUM_BAND)
          PRINT, ' DEBUG MODE - MIN/MAX/MEAN(RAYLEIGH_LUT_STRUCT.REFL_TOA) = ', MIN(RAYLEIGH_LUT_STRUCT.REFL_TOA(*,IDX_LUT)), '/', MAX(RAYLEIGH_LUT_STRUCT.REFL_TOA(*,IDX_LUT)), '/', MEAN(RAYLEIGH_LUT_STRUCT.REFL_TOA(*,IDX_LUT))
          PRINT, ' DEBUG MODE - MIN/MAX/MEAN(RTOA_OBS) = ', MIN(RTOA_OBS_VLD), '/', MAX(RTOA_OBS_VLD), '/', MEAN(RTOA_OBS_VLD)
          PRINT, ' DEBUG MODE - MIN/MAX/MEAN(TG) = ', MIN(TG_VLD), '/', MAX(TG_VLD), '/', MEAN(TG_VLD)
          PRINT, ' DEBUG MODE - MIN/MAX/MEAN(RTOA_TG_RATIO_ESTIM) = ', MIN(RTOA_TG_RATIO_ESTIM_VLD), '/', MAX(RTOA_TG_RATIO_ESTIM_VLD), '/', MEAN(RTOA_TG_RATIO_ESTIM_VLD)
					PRINT, ' DEBUG MODE - MIN/MAX/MEAN(REF_TO_SIM_RATIO) = ', MIN(REF_TO_SIM_RATIO_VLD), '/', MAX(REF_TO_SIM_RATIO_VLD), MEAN(REF_TO_SIM_RATIO_VLD)
					PRINT, ' ------ '
        ENDIF

        IF NB_DIRECTIONS GT 1 THEN BEGIN
          OUT_FIG_FILENAME = OUT_FILEPATH + NCDF_YEAR_STR + DL + OUT_FILENAME_BASE + '_' + NCDF_YEAR_STR + NCDF_MONTH_STR + NCDF_DAY_STR $
                                        + '_' + NCDF_HOURS_STR + NCDF_MINUTES_STR $
                                        + '_' + DIR_ID $
                                        + '_' + SENSOR_CONFIG.BAND_REF_LABEL[IDX_NUM_BAND] $
                                        + '_' + WAVELENGTH $
                                        + '.jpg'
        ENDIF ELSE BEGIN
          OUT_FIG_FILENAME = OUT_FILEPATH + NCDF_YEAR_STR + DL + OUT_FILENAME_BASE + '_' + NCDF_YEAR_STR + NCDF_MONTH_STR + NCDF_DAY_STR $
                                        + '_' + NCDF_HOURS_STR + NCDF_MINUTES_STR $
                                        + '_' + SENSOR_CONFIG.BAND_REF_LABEL[IDX_NUM_BAND] $
                                        + '_' + WAVELENGTH $
                                        + '.jpg'
        ENDELSE                                

				RES = GET_SENSOR_TO_SIMULATION_PRODUCT_PLOTS(OUT_FIG_FILENAME, RTOA_TG_RATIO_VLD, RTOA_TG_RATIO_ESTIM_VLD, REF_TO_SIM_RATIO_VLD)

        ;-------------------
				; COMPLETE NCDF CALIBRATION STRUCTURE
				
				NB_PIX = NCDF_CALIB_STRUCT.VARIABLES.CALIB_PIXEL_NUMBER(NUM_DIR)
				NCDF_CALIB_STRUCT.VARIABLES.BAND_GAZ_TRANS(0:NB_PIX-1,NUM_DIR,NUM_BAND)        = TG
				NCDF_CALIB_STRUCT.VARIABLES.BAND_RHO_SIM(0:NB_PIX-1,NUM_DIR,NUM_BAND)          = RTOA_TG_RATIO_ESTIM
				;  NCDF_CALIB_STRUCT.VARIABLES.BAND_RHO_SIM_UNCERT(0:NB_PIX-1,NUM_DIR,NUM_BAND)   = BAND_RHO_SIM_UNCERT
				NCDF_CALIB_STRUCT.VARIABLES.BAND_REF_TO_SIM_RATIO(0:NB_PIX-1,NUM_DIR,NUM_BAND) = REF_TO_SIM_RATIO
        NCDF_CALIB_STRUCT.VARIABLES.BAND_VALID_INDEX(0:COUNT_VALID-1,NUM_DIR,NUM_BAND) = IDX_VALID

				NEXT_BAND:
					
			ENDFOR  ; END LOOP ON BANDS
			
      AT_LEAST_ONE_DIR = 1

      NEXT_DIR:
      
    ENDFOR ; END LOOP ON VIEWING DIRECTIONS

    ; CHECK IF AT LEAST ONE DIRECTION HAS BEEN PROCESSED 
    IF AT_LEAST_ONE_DIR EQ 1 THEN BEGIN
      
      ;----------------------
      ; WRITE CALIBRATION OUTPUT
      
      STATUS = NETCDFWRITE_CALIB_OUTPUT(PROCESS_DATE, NCDF_CALIB_STRUCT, NCDF_FILENAME=NCDF_FILENAME, VERBOSE=VERBOSE)
      IF STATUS NE STATUS_OK THEN BEGIN
        IF KEYWORD_SET(VERBOSE) THEN PRINT, FCT_NAME + ': ERROR DURING OUTPUT CALIBRATION WRITING >> RETURNING'    
        RETURN, STATUS_ERROR
      ENDIF
      
    ENDIF ELSE IF KEYWORD_SET(VERBOSE) THEN PRINT, FCT_NAME + ': NO DIRECTION PROCESSED >> OUTPUT CALIBRATION NOT WRITTEN' 

		NEXT_IFILES:

	ENDFOR ;  END LOOP ON FILES

	NO_IFILES:
        
  PRINT, FCT_NAME + ': ***** PROCESS COMPLETED SUCCESSFULLY *****'
  RETURN, STATUS_OK

  END_PROCESS:
  IF (STATUS NE STATUS_OK) AND (KEYWORD_SET(VERBOSE)) THEN PRINT, FCT_NAME + ': ERROR DURING PROCESSING'
  RETURN, STATUS_ERROR
  
END