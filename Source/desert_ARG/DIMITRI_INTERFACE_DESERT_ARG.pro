;**************************************************************************************
;**************************************************************************************
;*
;* NAME:
;*      DIMITRI_INTERFACE_DESERT_ARG
;* 
;* PURPOSE:
;*      SIMULATING A TOA SERIES FROM A GIVEN SENSOR AS GIVEN BY
;*      DIMITRI FOR NON CLAUDY OBSERVATIONS FOLLOWING M. BOUVET 2011
;* 
;* CALLING SEQUENCE:
;*      RES = DIMITRI_INTERFACE_DESERT_ARG(OUTPUT_FOLDER, SITE, SENSOR, PROC_VER, YEAR, PHOTON_NB, CPU_NB)
;* 
;* INPUTS:
;*      OUTPUT_FOLDER    - THE FULL PATH OF THE OUTPUT FOLDER
;*      SITE             - THE VALIDATION SITE NAME E.G. 'LIBYA4'
;*      SENSOR           - THE NAME OF THE SENSOR E.G. 'PARASOL'
;*      PROC_VER         - THE PROCESSING VERSION OF THE SENSOR
;*      YEAR             - THE YEAR E.G. 2003 OR 'ALL'
;*	    PHOTON_NB        - THE NUMBER OF PHOTONS USED FOR THE SIMULATION (DEFALT VALUE IS 1500)
;*	    CPU_NB           - THE NUMBER OF PARALLEL JOBS/CPUS (DEFALT VALUE IS 1)
;*
;* KEYWORDS:
;*      CONSOLIDATE      - ALLOWS SUBSTITUTING THE L1 AUX O3 AND WV DATA BY ERA-INTERIM CORRESPONDING DATA
;*      DISPLAY_PLOT     - ALLOW DISPLAYING RESULTS ON THE SCREEN
;*      VERBOSE          - PROCESSING STATUS OUTPUTS
;*
;* OUTPUTS:
;*      STATUS          - 1: NO ERRORS REPORTED, (-1) OR 0: ERRORS DURING SIMULATION 
;*
;* COMMON BLOCKS:
;*      NON
;*
;* MODIFICATION HISTORY:
;*        21 SEP 2014 - M BOUVET - FIRST DEVELOPEMENT OF THE METHODOLOGY
;*        15 JAN 2015 - B ALHAMMOUD - FIRST IMPLEMENTATION TO DIMITRI-V3.1.1
;*        19 MAR 2015 - NCG / MAGELLIUM - UPDATED WITH NCDF INPUT/OUTPUT INTERFACES 
;*                                  AND LOOPS ON PRODUCTS/VIEWING DIRECTIONS (DIMITRI V4)
;*        13 APR 2015 - NCG / MAGELLIUM - REMOVE OF THE CONSOLIDATED KEYWORD (USE OF VALUE 
;*                                  FROM INGESTION FILE INSTEAD OF ERA INTERIM FILES)
;*
;* VALIDATION HISTORY:
;*        21 JAN 2015 - B ALHAMMOUD - LINUX 64-BIT MACHINE IDL 8.2, NOMINAL COMPILATION AND OPERATION.
;*                                  TESTED FOR PARASOL OVER LIBYA4
;*        30 MAR 2015 - NCG / MAGELLIUM      - WINDOWS 64BIT MACHINE IDL 8.0: COMPILATION AND OPERATION SUCCESSFUL (DIMITRI V4.0) 
;*
;**************************************************************************************
;**************************************************************************************

FUNCTION DIMITRI_INTERFACE_DESERT_ARG, SITE,  SENSOR, PROC_VER, YEAR, PHOTON_NB, CPU_NB, VERBOSE=VERBOSE


  DEBUG_MODE = 0      ; SET TO 1 IF WANT TO DEBUG THIS PROCEDURE
  
  METHOD = 'DESERT_ARG'

  STATUS_OK = GET_DIMITRI_LOCATION('STATUS_OK')
  STATUS_ERROR = GET_DIMITRI_LOCATION('STATUS_ERROR')
  STATUS_NODATA = GET_DIMITRI_LOCATION('STATUS_NODATA')

  INPUT_FOLDER  = GET_DIMITRI_LOCATION('INGESTION_OUTPUT')
  OUTPUT_FOLDER = GET_DIMITRI_LOCATION('OUTPUT')
  MISSING_VALUE_FLT = FLOAT(GET_DIMITRI_LOCATION('NCDF_MISSING_VALUE'))
  MISSING_VALUE_LONG = LONG(GET_DIMITRI_LOCATION('NCDF_MISSING_VALUE'))

;-----------------------------------------
; DEFINE CURRENT FUNCTION NAME
  ; AND SOME NUMERICAL CONSTANTS

  FCT_NAME  = 'DIMITRI_INTERFACE_DESERT_ARG'
  REF_O3           = 300.0 ; DU
  REF_WV           = 15 ; kg/m2

;-----------------------------------------
; DEFINE INPUT/OUTPUT FILES AND DIRECTORIES

  IF KEYWORD_SET(VERBOSE) THEN PRINT,FCT_NAME+': DEFINING INPUT/OUTPUT FILES'
  DL  = GET_DIMITRI_LOCATION('DL')
  SITE_FILE  = GET_DIMITRI_LOCATION('SITE_DATA')
  DB_FILE    = GET_DIMITRI_LOCATION('DATABASE')
  MAIN_DIRC  = GET_DIMITRI_LOCATION('DIMITRI')

;-----------------------------------------
; CHECK DIMITRI DATABASE EXISTS

  TEMP = FILE_INFO(DB_FILE)
  IF TEMP.EXISTS EQ 0 THEN BEGIN
    PRINT, FCT_NAME+': ERROR, DIMITRI DATABASE FILE DOES NOT EXIST'
    STOP
  ENDIF

;---------------------------
; IF KEYWORD_SET(VERBOSE) THEN PRINT,FCT_NAME+': LOOKING FOR BEST AEROSOL TYPE AND TOA THAT WERE OBTAINED DURING THE BRDF INVERSION BASED ON MERIS MEASUREMENT IN BAND 412'

RESTORE,  GET_DIMITRI_LOCATION('PICS_BRDF_DATA')+'template_aero_data.sav', VERBOSE=VERBOSE
BEST_AEROSOL=READ_ASCII( GET_DIMITRI_LOCATION('PICS_BRDF_DATA')+SITE+'_aero_data.txt', TEMPLATE=TEMPLATE_AERO_DATA)
AERO_TYPE=BEST_AEROSOL.FIELD1
AOT_550=BEST_AEROSOL.FIELD2

; COMPUTE THE AOT SCALING FACTOR WHICH IS AOT_550 / AOT_550_HESS_MODEL
IF AERO_TYPE EQ 'continental_average' THEN AOT_550_HESS_MODEL=0.107539; VALUES FOR THE CONTINENTAL_AVERAGE
IF AERO_TYPE EQ 'desert' THEN AOT_550_HESS_MODEL=0.246745; VALUE FOR THE DESERT
AOT_SCALING_FACTOR = AOT_550/AOT_550_HESS_MODEL
          
; DEFINE THE NUMBER OF PARALLEL JOBS/CPUS
MAX_CPU=!CPU.HW_NCPU
IF (CPU_NB NE 0 ) AND ( CPU_NB LT MAX_CPU) THEN BEGIN
   MAX_CPU=CPU_NB
ENDIF

; DEFINE THE NUMBER OF PHOTON PER SIMULATION
;BAH PHOTON_NB=1500


	;----------------------------------------
	; READ THE DIMITRI DATABASE

	IF KEYWORD_SET(VERBOSE) THEN PRINT,FCT_NAME+': READING DIMITRI DATABASE'
  DB_TEMPLATE = GET_DIMITRI_TEMPLATE(1,/TEMPLATE)
  DB_DATA     = READ_ASCII(DB_FILE,TEMPLATE=DB_TEMPLATE)

	;----------------------------------------
	; SORT OUT THE DATA THAT ARE REQUESTED FROM THE DATABASE

	;; SELECT DATA FOR WHICH THE SENSOR IS AS REQUESTED
	FLAG_REQUESTED=FLOAT(DB_DATA.SENSOR EQ SENSOR)

	;; SELECT DATA FOR WHICH THE PROCESSING VERSION IS AS REQUESTED
	FLAG_REQUESTED=FLAG_REQUESTED*FLOAT(DB_DATA.PROCESSING_VERSION EQ PROC_VER)

	;; SELECT DATA FOR WHICH THE SITE IS AS REQUESTED
	FLAG_REQUESTED=FLAG_REQUESTED*FLOAT(DB_DATA.SITE_NAME EQ SITE)

	;; SELECT DATA FOR WHICH AUTOMATIC CLOUD SCREENING AND MANUAL CLOUD SCREENING GIVE NO CLOUD AT ALL
	FLAG_REQUESTED=FLAG_REQUESTED*FLOAT(((DB_DATA.AUTO_CS_1_MEAN EQ 0) AND (DB_DATA.MANUAL_CS NE 1)) OR (DB_DATA.MANUAL_CS EQ 0))

	;; SELECT DATA FOR WHICH THE YEAR IS AS REQUESTED
	CYEAR = STRTRIM(YEAR,2)
	IF CYEAR EQ 'ALL' THEN BEGIN
		PRINT, 'SELECTION IS DONE OVER '+CYEAR+' AVAILABLE YEARS'  ; IN FACT WE SKIP THE YEAR SELECTION HERE, AUTOMATICALY WE TAKE ALL THE DATES
	ENDIF ELSE BEGIN
		FLAG_REQUESTED=FLAG_REQUESTED*FLOAT(DB_DATA.YEAR EQ YEAR)
	ENDELSE

	;; SELECT DATA FOR WHICH THE ROI IS FULLY COVERED
	FLAG_REQUESTED=FLAG_REQUESTED*FLOAT(DB_DATA.ROI_STATUS EQ 1)

	;; GET THE INDEX OF THE ACQUISITION REQUESTED IN THE DATABASE
	IDX_FILES=WHERE(FLAG_REQUESTED, NB_FILES)

  IF NB_FILES EQ 0 THEN BEGIN
    PRINT, FCT_NAME+': WARNING, NO SENSOR DATA FOUND WITHIN CLOUD CONDITION (0% CLOUD REQUIRED), RETURN'
    RETURN, STATUS_NODATA
  ENDIF


  ;----------------------
  ; GET INGESTION OUTPUT FILENAME FROM DATABASE
  
  SEARCH_FOLDER = INPUT_FOLDER + DL + 'Site_' + SITE + DL + SENSOR + DL + 'Proc_' + PROC_VER + DL
  I_FILES = SEARCH_FOLDER + DL + STRTRIM(STRING(DB_DATA.YEAR[IDX_FILES]),2) + DL + DB_DATA.L1_INGESTED_FILENAME[IDX_FILES]
  FILE_RESULT = FILE_SEARCH(I_FILES, COUNT=NB_FILES_SEARCH)
  
  IF NB_FILES_SEARCH NE NB_FILES THEN BEGIN
    IF KEYWORD_SET(VERBOSE) THEN PRINT, FCT_NAME + ': THE NUMBER OF INGESTION PRODUCTS ON DISK (', NB_FILES_SEARCH, $
                                                    ') DOES NOT MATCH THE NUMBER OF INGESTED PRODUCT IN THE DATABASE (', NB_FILES, ')'
    RETURN, STATUS_ERROR
  ENDIF


  ;-------------------
  ; COMPUTE SENSOR BAND WAVELENGTH TO PROCESS 
  
  CUR_SENSOR_BAND_INFOS = GET_SENSOR_BAND_INFO(SENSOR)
  BAND_WAVELENGTH = CUR_SENSOR_BAND_INFOS.BAND_WAVELENGTH
  N_BANDS  = CUR_SENSOR_BAND_INFOS.NB_BAND

  NB_DIRECTIONS = SENSOR_DIRECTION_INFO(SENSOR)
  NB_DIRECTIONS = NB_DIRECTIONS[0]

  SENSOR_CONFIG = GET_SENSOR_BAND_CONFIG(SENSOR) ; GET USED CHANNELS / STD LABELS / SMAC FILENAME / LUT FILENAME

  ;-------------------
  ; GET RSR AND RPV MODEL AND COMPUTE SENSOR BAND WAVELENGTH TO PROCESS 
  
	;BAH THE RPV-TEMPLATE IS THE ONE PROVIDD BY M.B. (SRC) 
	; WE ONLY PROCEEED IF THE WAVELENGTH_MIN AND WAVELENGTH_MAX ARE WITHIN THE RANGE OF THE RPV SPECTRAL MODEL DEFINITION
	RESTORE, GET_DIMITRI_LOCATION('PICS_BRDF_DATA')+'template_to_read_RPV_model_files_in_IDL.sav', VERBOSE=VERBOSE
	RPV_MODEL = READ_ASCII(GET_DIMITRI_LOCATION('PICS_BRDF_DATA')+SITE+'_interpolated_RPV_model.txt', TEMPLATE=TEMPLATE_RPV)
	WAVELENGTH_RPV_MIN=MIN(RPV_MODEL.FIELD1)
	WAVELENGTH_RPV_MAX=MAX(RPV_MODEL.FIELD1)

	;BAH THIS TEMPLATE IS THE ONE PROVIDED BY MB (SRC) 
	;READ THE TEMPLATE FOR THE SPECTRAL RESPONSE ASCII FILE (RSR ARE FROM DIMITRI)
	RSR_TEMPLATE  = GET_DIMITRI_RSR_TEMPLATE()

	WAVELENGTH_MIN = FLTARR(N_BANDS)
	WAVELENGTH_MAX = FLTARR(N_BANDS)
	
	; START LOOPING ON EACH BAND
	FOR SPECTRAL_BAND=0, N_BANDS-1 DO BEGIN
	
		; DEFINE NAME OF THE SPECTRAL RESPONSE FILE
		FILTER_FILENAME=GET_DIMITRI_LOCATION('RSR')+SENSOR+DL+'RSR_'+SENSOR+'_BAND_'+STRTRIM(SPECTRAL_BAND, 2)+'.txt'

		; READ THE SPECTRAL RESPONSE
		SPECTRAL_RESPONSE=READ_ASCII(FILTER_FILENAME, TEMPLATE=RSR_TEMPLATE)

		; ASSIGN MIN AND MAX WAVELENGHT OF SPECTRAL REPONSE TO THE VARIABLE USED TO DEFINE THE INTERVAL OF THE SIMULATION
		WAVELENGTH_MIN[SPECTRAL_BAND] = MIN(SPECTRAL_RESPONSE.WAVELENGTH)
		WAVELENGTH_MAX[SPECTRAL_BAND] = MAX(SPECTRAL_RESPONSE.WAVELENGTH)
	
	ENDFOR

	IDX_VALID_BANDS = WHERE( (WAVELENGTH_MIN GT WAVELENGTH_RPV_MIN) AND (WAVELENGTH_MAX LT WAVELENGTH_RPV_MAX) , NB_VALID_BANDS)
	
	IF NB_VALID_BANDS EQ 0 THEN BEGIN
    IF KEYWORD_SET(VERBOSE) THEN PRINT, FCT_NAME + ': SPECTRAL BAND DEFINED OUTSIDE RPV SPECTRAL MODEL DOMAIN...'
    RETURN, STATUS_NODATA
  ENDIF

  ;----------------------
	; READ THE EXTRATERRESTRIAL SOLAR IRRADIANCE

	SOLAR_SPECTRUM=READ_ASCII(GET_DIMITRI_LOCATION('SOLAR_SPECTRUM'), DATA_START=1) ; in mW.m-2.nm-1
	SPECTRAL_RESOLUTION=0.1 ; IN NM                

  ;----------------------
  ; SET OUTPUT CALIB FOLDER
  
  CALDAT, SYSTIME(/UTC,/JULIAN),TMM,TDD,TYY,THR,TMN,TSS

  TYY = STRTRIM(STRING(TYY),2)
  TMM = TMM LT 10 ? '0'+STRTRIM(STRING(TMM),2) : STRTRIM(STRING(TMM),2)
  TDD = TDD LT 10 ? '0'+STRTRIM(STRING(TDD),2) : STRTRIM(STRING(TDD),2)
  THR = THR LT 10 ? '0'+STRTRIM(STRING(THR),2) : STRTRIM(STRING(THR),2)
  TMN = TMN LT 10 ? '0'+STRTRIM(STRING(TMN),2) : STRTRIM(STRING(TMN),2)
  TSS = TSS LT 10 ? '0'+STRTRIM(STRING(TSS,FORMAT='(I)'),2) : STRTRIM(STRING(TSS,FORMAT='(I)'),2)

  PROCESS_DATE = TYY+TMM+TDD+'-'+THR+TMN

  OUT_FILEPATH = OUTPUT_FOLDER + DL + METHOD + '_' + PROCESS_DATE + DL + 'Site_'+ SITE + DL + SENSOR + DL + 'Proc_' + PROC_VER + DL
  OUT_FILENAME_BASE =  SITE + '_' + SENSOR + '_' + PROC_VER + '_' + METHOD 

  ;----------------------
  ; INITIALISE DESERT PROCESS STRUCTURE
  
  DESERT_STRUCT = { $
  			VALID     		: INTARR(NB_FILES*NB_DIRECTIONS), $
  			IDX_FILE  		: LONARR(NB_FILES*NB_DIRECTIONS), $
  			VIEWDIR 			: LONARR(NB_FILES*NB_DIRECTIONS), $
  			DECIMAL_YEAR  : FLTARR(NB_FILES*NB_DIRECTIONS), $
  			VZA   				: FLTARR(NB_FILES*NB_DIRECTIONS), $
  			VAA 					: FLTARR(NB_FILES*NB_DIRECTIONS), $
  			SZA 					: FLTARR(NB_FILES*NB_DIRECTIONS), $
  			SAA 					: FLTARR(NB_FILES*NB_DIRECTIONS), $
  			RTOA 					: FLTARR(NB_VALID_BANDS, NB_FILES*NB_DIRECTIONS), $
  			OZONE 				: FLTARR(NB_FILES*NB_DIRECTIONS), $
  			WV    				: FLTARR(NB_FILES*NB_DIRECTIONS), $
  			NCDF_OUTPUT 	: STRARR(NB_FILES*NB_DIRECTIONS), $
        SIMUL_FILTERED_SENSOR_L1B_REF     : FLTARR(NB_VALID_BANDS, NB_FILES*NB_DIRECTIONS), $
        SIMUL_FILTERED_SENSOR_L1B_REF_STD : FLTARR(NB_VALID_BANDS, NB_FILES*NB_DIRECTIONS) $
  			}
	
	DESERT_STRUCT.VALID(*) = 0
	DESERT_STRUCT.SIMUL_FILTERED_SENSOR_L1B_REF(*)     = MISSING_VALUE_FLT
	DESERT_STRUCT.SIMUL_FILTERED_SENSOR_L1B_REF_STD(*) = MISSING_VALUE_FLT
	
  ;----------------------
  ; LOOP OVER NCDF FILE IN PROCESSING DATASET TO FILL DESERT PROCESS STRUCTURE

  FOR IDX_FILE=0, NB_FILES-1 DO BEGIN

    NCDF_FILENAME = FILE_RESULT[IDX_FILE]
    NCDF_INFOS = FILE_INFO(NCDF_FILENAME)
    
    IF NCDF_INFOS.EXISTS EQ 0 OR STRLEN(NCDF_FILENAME) EQ 0 THEN BEGIN
      IF KEYWORD_SET(VERBOSE) THEN PRINT,FCT_NAME + ': FILE ',NCDF_FILENAME,' IS MISSING, PLEASE CHECK YOUR INGESTION PROGRESS'
      GOTO, INIT_NEXT_IFILES
    ENDIF

    CUR_NCFILE = FILE_BASENAME(NCDF_FILENAME)

    ;----------------------
    ; GET ACQUISITION DATE FROM NCDF FILE
    
    CUR_NCDF_DATE = STRTRIM(GET_NCDF_GLOBAL_ATT(NCDF_FILENAME, 'ACQUISITION_DATE'))
    NCDF_YEAR_STR=STRMID(CUR_NCDF_DATE,0,4)
    NCDF_MONTH_STR=STRMID(CUR_NCDF_DATE,5,2)
    NCDF_DAY_STR=STRMID(CUR_NCDF_DATE,8,2)
    NCDF_HOURS_STR=STRMID(CUR_NCDF_DATE,11,2)
    NCDF_MINUTES_STR=STRMID(CUR_NCDF_DATE,14,2)
    
    NCDF_YEAR=UINT(NCDF_YEAR_STR)
    NCDF_MONTH=UINT(NCDF_MONTH_STR)
    NCDF_DAY=UINT(NCDF_DAY_STR)
    NCDF_HOURS=UINT(NCDF_HOURS_STR)
    NCDF_MINUTES=UINT(NCDF_MINUTES_STR)
    
    ACQUI_DATE = JULDAY(NCDF_MONTH,NCDF_DAY,NCDF_YEAR,NCDF_HOURS,NCDF_MINUTES,0)
    
    IF KEYWORD_SET(VERBOSE) THEN BEGIN
      PRINT, '[' + STRTRIM(STRING(IDX_FILE+1),1) + '/' + STRTRIM(STRING(NB_FILES),1) + '] > ' + FCT_NAME + ' ' + CUR_NCFILE + ' :: ' + CUR_NCDF_DATE
    ENDIF

    ; COMPUTE DECIMAL YEAR
    IF FLOAT(NCDF_YEAR) MOD 4 EQ 0 THEN DIY = DOUBLE(366.0) ELSE DIY = DOUBLE(365.0)
    TTIME = DOUBLE( (NCDF_HOURS/(DIY*24.))+(NCDF_MINUTES/(DIY*60.*24.)) )
    DAY_OF_YEAR = DOUBLE(JULDAY(NCDF_MONTH,NCDF_DAY,NCDF_YEAR)-JULDAY(1,0,NCDF_YEAR))
    
    DECIMAL_YEAR  = DOUBLE(NCDF_YEAR)+ DAY_OF_YEAR/DIY + TTIME

    ;----------------------
    ; READ INPUT INGESTION FILE
    
    STATUS = NETCDFREAD_INGEST_OUTPUT( NCDF_FILENAME, NCDF_INGEST_STRUCT=NCDF_INGEST_STRUCT, VERBOSE=VERBOSE)
    IF STATUS NE STATUS_OK THEN BEGIN
      IF KEYWORD_SET(VERBOSE) THEN BEGIN
        PRINT, FCT_NAME + ': ERROR DURING ', FILE_BASENAME(NCDF_FILENAME),' FILE READING >> FILE SKIPPED'
      ENDIF
      GOTO, INIT_NEXT_IFILES
    ENDIF  

    ;----------------------
    ; LOOP OVER VIEWING DIRECTION
    
    AT_LEAST_ONE_DIR = 0

    FOR NUM_DIR=0, NB_DIRECTIONS-1 DO BEGIN

			IDX_STRUCT = IDX_FILE*NB_DIRECTIONS+NUM_DIR
			
			IDX_CLEAR = WHERE(NCDF_INGEST_STRUCT.VARIABLES.AUTO_CS_1_MASK[*,NUM_DIR] EQ 0, COUNT)

      IF NCDF_INGEST_STRUCT.VARIABLES.ROI_STATUS[NUM_DIR] EQ 0 OR COUNT EQ 0 THEN BEGIN
        IF KEYWORD_SET(VERBOSE) THEN PRINT, FCT_NAME + ': ROI STATUS WITH 0 VALUE OR NO CLEAR PIXEL >> DIRECTION SKIPPED'
        GOTO, INIT_NEXT_DIR
      ENDIF

			DESERT_STRUCT.VALID[IDX_STRUCT]        = 1
			DESERT_STRUCT.IDX_FILE[IDX_STRUCT]     = IDX_FILE
			DESERT_STRUCT.VIEWDIR[IDX_STRUCT]      = NUM_DIR
			DESERT_STRUCT.DECIMAL_YEAR[IDX_STRUCT] = DECIMAL_YEAR
			DESERT_STRUCT.VZA[IDX_STRUCT] = MEAN(NCDF_INGEST_STRUCT.VARIABLES.VZA[IDX_CLEAR,NUM_DIR])
			DESERT_STRUCT.VAA[IDX_STRUCT] = MEAN(NCDF_INGEST_STRUCT.VARIABLES.VAA[IDX_CLEAR,NUM_DIR])
			DESERT_STRUCT.SZA[IDX_STRUCT] = MEAN(NCDF_INGEST_STRUCT.VARIABLES.SZA[IDX_CLEAR,NUM_DIR])
			DESERT_STRUCT.SAA[IDX_STRUCT] = MEAN(NCDF_INGEST_STRUCT.VARIABLES.SAA[IDX_CLEAR,NUM_DIR])

			; LOOP ON VALID BANDS
			FOR BAND=0, NB_VALID_BANDS-1 DO BEGIN
				RTOA = NCDF_INGEST_STRUCT.VARIABLES.REFL_BAND[IDX_CLEAR, NUM_DIR, IDX_VALID_BANDS[BAND]]
;        NB_PIXEL_ROI = NCDF_INGEST_STRUCT.VARIABLES.ROI_PIXEL_NUMBER[NUM_DIR]
;        RTOA = NCDF_INGEST_STRUCT.VARIABLES.REFL_BAND[0:NB_PIXEL_ROI-1, NUM_DIR, IDX_VALID_BANDS[BAND]]
				IDX = WHERE(RTOA NE MISSING_VALUE_FLT, COUNT)
				IF COUNT NE 0 THEN DESERT_STRUCT.RTOA[BAND, IDX_STRUCT] = MEAN(RTOA(IDX)) $ 
											ELSE DESERT_STRUCT.RTOA[BAND, IDX_STRUCT] = MISSING_VALUE_FLT
			ENDFOR
			
			OZONE = NCDF_INGEST_STRUCT.VARIABLES.ERA_OZONE[IDX_CLEAR,NUM_DIR]
      ID = WHERE(OZONE EQ MISSING_VALUE_FLT)
      IF ID[0] NE -1 THEN OZONE[ID]= REF_O3 / 1000.0      
      WATERVAPOUR = NCDF_INGEST_STRUCT.VARIABLES.ERA_WATERVAPOUR[IDX_CLEAR,NUM_DIR]
      ID = WHERE(WATERVAPOUR EQ MISSING_VALUE_FLT)
      IF ID[0] NE -1 THEN WATERVAPOUR[ID]= REF_WV / 10.0
			
  		DESERT_STRUCT.OZONE[IDX_STRUCT] = MEAN(OZONE)*1000.0
			DESERT_STRUCT.WV[IDX_STRUCT]    = MEAN(WATERVAPOUR)*10.0
    
    	AT_LEAST_ONE_DIR = 1
    	
			INIT_NEXT_DIR:

		ENDFOR ; END LOOP ON VIEWING DIRECTION
		
		IF AT_LEAST_ONE_DIR EQ 1 THEN BEGIN
		
			;----------------------
			; GET NCDF STRUCTURE FOR CALIBRATION OUTPUT

			CALIB_PIXEL_NUMBER = 1 ; USE MEAN VALUE TO BE ONLINE WITH ARGANS FOR THE MOMENT...

			NCDF_CALIB_STRUCT = GET_NCDF_CALIB_STRUCT(CALIB_PIXEL_NUMBER, NCDF_INGEST_STRUCT.DIMENSIONS.ROI_PIXEL_NUMBER, NB_DIRECTIONS, NB_VALID_BANDS, VERBOSE=VERBOSE)
			NCDF_CALIB_STRUCT.GLOBAL_ATT.CALIBRATION_METHOD = METHOD
			NCDF_CALIB_STRUCT.VARIABLES.REFL_BAND_IDS = IDX_VALID_BANDS

			;----------------------
			; COPY COMMON INFOS FROM INGESTION NCDF TO CALIBRATION NCDF
			STATUS = COPY_INGESTION_TO_CALIBRATION_NCDF_STRUCTURE(NCDF_INGEST_STRUCT=NCDF_INGEST_STRUCT, NCDF_CALIB_STRUCT=NCDF_CALIB_STRUCT, VERBOSE=VERBOSE)
			IF STATUS NE STATUS_OK THEN RETURN, STATUS
		
      ;----------------------
      ; WRITE CALIBRATION OUTPUT
      
      STATUS = NETCDFWRITE_CALIB_OUTPUT(PROCESS_DATE, NCDF_CALIB_STRUCT, NCDF_FILENAME=NCDF_FILENAME, VERBOSE=VERBOSE)
      IF STATUS NE STATUS_OK THEN BEGIN
        IF KEYWORD_SET(VERBOSE) THEN PRINT, FCT_NAME + ': ERROR DURING OUTPUT CALIBRATION WRITING >> RETURNING'    
        RETURN, STATUS_ERROR
      ENDIF
      
			DESERT_STRUCT.NCDF_OUTPUT[IDX_FILE*NB_DIRECTIONS:(IDX_FILE+1)*NB_DIRECTIONS-1] = NCDF_FILENAME      

		ENDIF
		
		INIT_NEXT_IFILES:

  ENDFOR ; END LOOP ON FILES
   
;  ; FOR VALIDATION PURPOSE ONLY !!!!!!  
;  DESERT_STRUCT.OZONE[*] = 0.291855
;  DESERT_STRUCT.WV[*] = 0.655710
;    
  
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; SIMULATION OF THE REMOTE SENSING DATA
; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 
IF KEYWORD_SET(VERBOSE) THEN PRINT, FCT_NAME + ': START LOOPING ON SPECTRAL BANDS'

; START LOOPING ON EACH BAND
FOR SPECTRAL_BAND=0, NB_VALID_BANDS-1 DO BEGIN

  IF KEYWORD_SET(VERBOSE) THEN BEGIN
    PRINT, ' ----- [' + STRTRIM(STRING(SPECTRAL_BAND+1),1) + '/' + STRTRIM(STRING(NB_VALID_BANDS),1) + '] VALID BANDS'
  ENDIF
  
  ;SELECT ONLY THE DATA WHERE THE REFLECTANCE IS VALID AND THE SZA AND VZA ARE WITHIN  THE DEFINITION RANGE OF THE RETRIEVED BRDF MODEL 
  ;  MERIS_SZA_MAX=60.
  ;  MERIS_VZA_MAX=38.
  ;  IDX_VALID=WHERE((GOOD_INDEX EQ 1) AND (SENSOR_L1B_REF[16+SPECTRAL_BAND,*] GT 0) AND (SENSOR_L1B_REF[16+SPECTRAL_BAND,*] LT 5) AND (SENSOR_L1B_REF[1,*] LT MERIS_VZA_MAX) AND (SENSOR_L1B_REF[3,*] LT MERIS_SZA_MAX))
  
  ;SELECT ONLY THE DATA WHERE THE REFLECTANCE IS VALID 
  IDX_VALID=WHERE((DESERT_STRUCT.VALID EQ 1) AND (DESERT_STRUCT.RTOA[SPECTRAL_BAND,*] GT 0) AND (DESERT_STRUCT.RTOA[SPECTRAL_BAND,*] LT 5), NB_VALID, NCOMPLEMENT=NB_INVALID, COMPLEMENT=IDX_INVALID )
  
  ; UPDATE VALID FLAG IN DESERT STRUCTURE
  IF NB_INVALID NE 0 THEN DESERT_STRUCT.VALID[IDX_INVALID] = 0

  ;SELECT ONLY THE DATA WHERE THE OBSERVATIONAL ANGLES ARE CLOSE TO ONE OF THOSE USED TO INVERT THE BRDF MODEL
;  IF NB_VALID GT 1 THEN BEGIN ;;; !!!!! MODIF NCG !!!!!
  IF NB_VALID GE 1 THEN BEGIN 
  
    MAX_ANGULAR_DISTANCE = 50. ; 5 DEGREE IS THE MAX ANGULAR DISTANCE TO ONE OF THE MERIS OBSERVATIONS USED TO GENERATE THE BRDF MODEL
    MATCHING_GEOMETRIES = VALID_RPV_BRDF_GEOMETRY(DESERT_STRUCT.VZA[IDX_VALID], DESERT_STRUCT.VAA[IDX_VALID], DESERT_STRUCT.SZA[IDX_VALID], DESERT_STRUCT.SAA[IDX_VALID], MAX_ANGULAR_DISTANCE, SITE, /VERBOSE)
    
    IDX = WHERE(MATCHING_GEOMETRIES EQ 1, NB_VALID, NCOMPLEMENT=NB_INVALID, COMPLEMENT=IDX_INVALID)
    IF NB_VALID EQ 0 THEN BEGIN
      PRINT, 'ERROR !!!!!!!!! NO MATCHING_GEOMETRIES !!!!!!!!!'
      RETURN, STATUS_ERROR
    ENDIF
    
    ; UPDATE VALID FLAG IN DESERT STRUCTURE
    IF NB_INVALID NE 0 THEN DESERT_STRUCT.VALID[IDX_VALID[IDX_INVALID]] = 0

    ;IDX_VALID=IDX_VALID[WHERE(MATCHING_GEOMETRIES NE 0)]
    IDX_VALID = IDX_VALID[IDX] ; WE CHOSE ONLY THE IDENTICAL CONFIGURATIONS
    
    ; DECLARE A VECTOR THAT CONTAINS -1 FOR A RECIPROCAL GEOMETRY MATCH AND 1 FOR AN IDENTICAL GEOMETRY MATCH
    ; 
    ; GEOMETRICAL_CONFIG=MATCHING_GEOMETRIES[WHERE(MATCHING_GEOMETRIES NE 0)]
    GEOMETRICAL_CONFIG=MATCHING_GEOMETRIES[IDX] ; WE CHOSE ONLY THE IDENTICAL CONFIGURATIONS
    
  ENDIF
  
  ; IF WE HAVE VALID ACQUISITION THEN WE START TRYING TO MODEL THEM
;  IF NB_VALID GT 1 THEN BEGIN ;;; !!!!! MODIF NCG !!!!!
  IF NB_VALID GE 1 THEN BEGIN 
  
      ;FILTERED_SENSOR_L1B_REF=SENSOR_L1B_REF[*,IDX_VALID]
      
      ;COMPUTE THE NUMBER OF ACQUISITIONS
      ;N_ACQUISITIONS=N_ELEMENTS(FILTERED_SENSOR_L1B_REF[0,*])
      N_ACQUISITIONS = NB_VALID
      
      ;DEFINE THE SIMULATED SENSOR AND A VECTOR THAT CONTAINS THE STANDARD DEVIATION FROM THE MC COMPUTATION
;      SIMUL_FILTERED_SENSOR_L1B_REF = FILTERED_SENSOR_L1B_REF
;      SIMUL_FILTERED_SENSOR_L1B_REF_STD = FLTARR(N_ACQUISITIONS)
      
      ; READ THE SPECTRAL RESPONSE
      FILTER_FILENAME=GET_DIMITRI_LOCATION('RSR')+SENSOR+DL+'RSR_'+SENSOR+'_BAND_'+STRTRIM(SPECTRAL_BAND, 2)+'.txt'
      SPECTRAL_RESPONSE=READ_ASCII(FILTER_FILENAME, TEMPLATE=RSR_TEMPLATE)

          ; INITIALISATION OF THE CONVOLUTION OF THE SPECTRAL RESPONSE AND THE SIMULATE SIGNAL
          ; WE SAMPLE THE SIGNAL AND THE SPECTRAL RESPONSE AND A REGULAR INTERVAL SPECTRAL GRID AT 0.1 NM
          WAVELENGTH_GRID=INDGEN(CEIL((WAVELENGTH_MAX[SPECTRAL_BAND]-WAVELENGTH_MIN[SPECTRAL_BAND])/SPECTRAL_RESOLUTION))*SPECTRAL_RESOLUTION+WAVELENGTH_MIN[SPECTRAL_BAND]
          RESAMPLED_SPECTRAL_RESPONSE=INTERPOL(SPECTRAL_RESPONSE.RESPONSE, SPECTRAL_RESPONSE.WAVELENGTH, WAVELENGTH_GRID)
          RESAMPLED_SOLAR_IRRADIANCE=INTERPOL(SOLAR_SPECTRUM.FIELD1[1,*], SOLAR_SPECTRUM.FIELD1[0,*],WAVELENGTH_GRID)
                
          PRINT, '-----------------------------------'
          PRINT, ' --SPECTRAL_BAND = ', SPECTRAL_BAND
          PRINT, ' -------SPECTRAL_RESPONSE.RESPONSE   = ', SPECTRAL_RESPONSE.RESPONSE
          PRINT, ' -------SPECTRAL_RESPONSE.WAVELENGTH = ', SPECTRAL_RESPONSE.WAVELENGTH
          PRINT, ' -------WAVELENGTH_GRID NB/MIN/MAX/MEAN/STDDEV               = ', N_ELEMENTS(WAVELENGTH_GRID), MIN(WAVELENGTH_GRID), MAX(WAVELENGTH_GRID), MEAN(WAVELENGTH_GRID), STDDEV(WAVELENGTH_GRID)
          PRINT, ' -------RESAMPLED_SPECTRAL_RESPONSE NB/MIN/MAX/MEAN/STDDEV   = ', N_ELEMENTS(RESAMPLED_SPECTRAL_RESPONSE), MIN(RESAMPLED_SPECTRAL_RESPONSE), MAX(RESAMPLED_SPECTRAL_RESPONSE), MEAN(RESAMPLED_SPECTRAL_RESPONSE), STDDEV(RESAMPLED_SPECTRAL_RESPONSE)
          PRINT, ' -------RESAMPLED_SOLAR_IRRADIANCE NB/MIN/MAX/MEAN/STDDEV    = ', N_ELEMENTS(RESAMPLED_SOLAR_IRRADIANCE), MIN(RESAMPLED_SOLAR_IRRADIANCE), MAX(RESAMPLED_SOLAR_IRRADIANCE), MEAN(RESAMPLED_SOLAR_IRRADIANCE), STDDEV(RESAMPLED_SOLAR_IRRADIANCE)
          PRINT, '-----------------------------------'

          ; DEFINE A VECTOR THAT CONTAINS THE STATE OF THE CPU (RUNNING=1, AVAILABLE=0)
          STATE_CPU=FLTARR(MAX_CPU)
          DONE_CPU=FLTARR(MAX_CPU)
          ACQUISITION_NB_PROCESSED_BY_CPU=FLTARR(MAX_CPU)
          
          ; DEFINE A ARRAY WHERE THE FILES BEING GENERATED BY MYSTIC ARE STORED
          FILES_BEING_GENERATED=STRARR(MAX_CPU)+'NULL'
        
          PRINT, 'SIMULATING DATA FROM BAND ', SPECTRAL_BAND
                   
          ; REMOVE ALL PREVIOUS SIMULATION OUTPUTS
          MC_BASENAME='MC_SIMULATION_CPU_'
          SIMULATION_OUTPUT_FILES=FILE_SEARCH(MAIN_DIRC+DL+'Temp_sim_files'+DL+MC_BASENAME+'*')
          IF N_ELEMENTS(SIMULATION_OUTPUT_FILES) GT 1 THEN FOR I_FILE=0, N_ELEMENTS(SIMULATION_OUTPUT_FILES)-1 DO SPAWN, 'rm '+SIMULATION_OUTPUT_FILES[I_FILE]        
          
          ; INTIALIZE THE COUNTER FOR THE NUMBER OF ACQUISTIONS TO BE SIMULATED
          I_ACQUISITION=0
          
          ; DEFINE TIME STAMPS USED TO MONITOR PERFORMANCE
          SYS_TIMER_1=SYSTIME(/SECONDS)
          DELTA_TIME=0

          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
          ; START LOOPING ON THE OBSERVATIONS AND SIMULATE THEM
          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
          IF KEYWORD_SET(VERBOSE) THEN PRINT, FCT_NAME + ': START LOOPING ON ACQUISITIONS'
          
          WHILE I_ACQUISITION LT N_ACQUISITIONS  DO BEGIN
          
            I_ACQU_STRUCT = IDX_VALID[I_ACQUISITION]
            
            IF KEYWORD_SET(VERBOSE) THEN BEGIN
;              PRINT, ' ----- [' + STRTRIM(STRING(I_ACQUISITION+1),1) + '/' + STRTRIM(STRING(N_ACQUISITIONS),1) + '] ACQUISITIONS  (I_ACQU_STRUCT = ',I_ACQU_STRUCT,')'
            ENDIF
            
            ; IF THERE ARE CPU AVAILABLE WE LAUNCH A SIMULATION ON THE NEXT OBSERVATION
            IF TOTAL(STATE_CPU) LT MAX_CPU THEN BEGIN
            
               ; DISPLAY THE TIME BETWEEN TWO SIMULATIONS
 ;             IF ((((I_ACQUISITION*100./N_ACQUISITIONS) MOD 1)) EQ 0) THEN  
              PRINT, 'DONE ', STRTRIM(I_ACQUISITION*100./N_ACQUISITIONS,2), ' % OF THE JOB. LAST SIMULATION STARTED  '+ STRTRIM(DELTA_TIME,2)+' SECONDS AGO'
              PRINT, 'DONE ', STRTRIM(I_ACQUISITION*100./N_ACQUISITIONS,2), ' % OF THE JOB. LAST SIMULATION STARTED  '+ STRTRIM(DELTA_TIME,2)+' SECONDS AGO'
              PRINT, 'NB CPUS BUSY: ', TOTAL(STATE_CPU)
              
               ; AVAILABLE CPU
               AVAIL_CPU_INDEX=WHERE(STATE_CPU EQ 0)
           
              ;BEFORE STARTING, WE MAKE SURE THE OZONE AND WATER VAPOUR ARE AVAILABLE IN THE FILE OTHERWIZE WE FILL UP WITH DUMMY VALUES
              IF DESERT_STRUCT.OZONE[I_ACQU_STRUCT] EQ -999 THEN OZONE=300 ELSE OZONE=DESERT_STRUCT.OZONE[I_ACQU_STRUCT]
          
              ; GET THE WATER VAPOUR VALUE
              IF DESERT_STRUCT.WV[I_ACQU_STRUCT] EQ -999 THEN WV=20 ELSE WV=DESERT_STRUCT.WV[I_ACQU_STRUCT]
          
              ; RUN MYSTIC WITH ALL INPUTS
              IF KEYWORD_SET(VERBOSE) THEN PRINT,FCT_NAME+': RUN MYSTIC MODEL'
              INPUT_FILE = MAIN_DIRC+DL+'Temp_sim_files'+DL+MC_BASENAME+STRTRIM(AVAIL_CPU_INDEX[0], 2)+'.INPUT'
              WRITE_MYSTIC_RPV_INPUT, INPUT_FILE, MC_BASENAME+STRTRIM(AVAIL_CPU_INDEX[0], 2), PHOTON_NB, $
                WAVELENGTH_MIN[SPECTRAL_BAND], WAVELENGTH_MAX[SPECTRAL_BAND], $ 
                DESERT_STRUCT.SZA[I_ACQU_STRUCT], DESERT_STRUCT.SAA[I_ACQU_STRUCT], $
                DESERT_STRUCT.VZA[I_ACQU_STRUCT], DESERT_STRUCT.VAA[I_ACQU_STRUCT]-180., $
                0, 0, 0, 0, OZONE, WV, AOT_SCALING_FACTOR, AERO_TYPE, $ 
                RPV_FILE = GET_DIMITRI_LOCATION('PICS_BRDF_DATA')+SITE+'_interpolated_RPV_model.txt'

;              CASE STRUPCASE(!VERSION.OS_FAMILY) OF
;                'WINDOWS': SPAWN, 'uvspec < '+INPUT_FILE, /NOWAIT, /LOG_OUTPUT
;                'UNIX':    SPAWN, 'uvspec < '+INPUT_FILE+' >/dev/null  &', /sh
;              ENDCASE
              
              SPAWN, 'uvspec < '+INPUT_FILE+' >/dev/null  &', /sh
              
              ; UPDATE THE LIST OF FILES BEING PROCESSED AND CPU STATE
              STATE_CPU[AVAIL_CPU_INDEX[0]]=1
              
              ; ASSIGN TO THE CPU THE ACQUISTION NUMBER
              ACQUISITION_NB_PROCESSED_BY_CPU[AVAIL_CPU_INDEX[0]]=I_ACQUISITION
              
              ; STORE FILENAME OF FILE BEING PROCESSED
              FILES_BEING_GENERATED[AVAIL_CPU_INDEX[0]]=MC_BASENAME+STRTRIM(AVAIL_CPU_INDEX[0], 2)+'.rad.spc'
          
              I_ACQUISITION=I_ACQUISITION+1
           ENDIF 
                                
            ; FIND OUT WHICH THREADS ARE DONE
            FOR I_CPU=0, MAX_CPU-1 DO IF FILE_SEARCH(FILES_BEING_GENERATED[I_CPU]) NE  '' THEN DONE_CPU[I_CPU]=1
            
            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
            ; READ OUTPUT FOR ALL THREADS THAT ARE FINISHED
            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
            FOR I_CPU=0, MAX_CPU-1 DO BEGIN
              IF DONE_CPU[I_CPU] EQ 1 THEN BEGIN
              
                I_ACQU_STRUCT = IDX_VALID[ ACQUISITION_NB_PROCESSED_BY_CPU[I_CPU] ]
                
                ; COMPUTE AND DISPLAY THE TIME BETWEEN TWO SIMULATIONS
                DELTA_TIME=SYSTIME(/SECONDS)-SYS_TIMER_1
                SYS_TIMER_1=SYSTIME(/SECONDS)
                
                ; READ THE SIMULATINO RESULT
                RHO_TOA=READ_MYSTIC_OUTPUT(FILES_BEING_GENERATED[I_CPU])
                
                ; READ THE STANDARD DEVIATION ASSOCIATED TO THE SIMULATION
                RHO_TOA_STD=READ_MYSTIC_OUTPUT(STRMID(FILES_BEING_GENERATED[I_CPU], 0, STRPOS(FILES_BEING_GENERATED[I_CPU], '.rad.spc'))+'.rad.std.spc')
                               
                ; CONVOLUTION OF THE SPECTRAL RESPONSE AND THE SIMULATE SIGNAL
                ; WE SAMPLE THE SIGNAL AND THE SPECTRAL RESPONSE AND A REGULAR INTERVAL SPECTRAL GRID AT 0.1 NM                
                RESAMPLED_RHO_TOA=INTERPOL(RHO_TOA[1,*], RHO_TOA[0,*],WAVELENGTH_GRID)

                ; CONVOLUTION OF THE SPECTRAL RESPONSE AND THE SIMULATE SIGNAL
                DESERT_STRUCT.SIMUL_FILTERED_SENSOR_L1B_REF[SPECTRAL_BAND, I_ACQU_STRUCT] = TOTAL(RESAMPLED_RHO_TOA*RESAMPLED_SOLAR_IRRADIANCE*RESAMPLED_SPECTRAL_RESPONSE)/TOTAL(RESAMPLED_SOLAR_IRRADIANCE*RESAMPLED_SPECTRAL_RESPONSE)
    
                ; COMPUTE THE MEAN STANDARD DEVIATION OVER ALL 1 NM MONOCHROMATIC COMPUTATIONS 
                DESERT_STRUCT.SIMUL_FILTERED_SENSOR_L1B_REF_STD[SPECTRAL_BAND, I_ACQU_STRUCT]=MEAN(RHO_TOA_STD[1,*])/SQRT(N_ELEMENTS(RHO_TOA_STD[1,*]))
                
                IF DEBUG_MODE EQ 1 THEN BEGIN
                  PRINT, ' DEBUG_MODE - I_ACQU_STRUCT  = ', I_ACQU_STRUCT
                  PRINT, ' DEBUG_MODE - SPECTRAL_BAND  = ', SPECTRAL_BAND
                  PRINT, ' DEBUG_MODE - RTOA_OBS       = ',  DESERT_STRUCT.RTOA[SPECTRAL_BAND, I_ACQU_STRUCT]
                  PRINT, ' DEBUG_MODE - BAND_RHO_SIM        = ',  DESERT_STRUCT.SIMUL_FILTERED_SENSOR_L1B_REF[SPECTRAL_BAND, I_ACQU_STRUCT]
                  PRINT, ' DEBUG_MODE - BAND_RHO_SIM_UNCERT = ',  DESERT_STRUCT.SIMUL_FILTERED_SENSOR_L1B_REF_STD[SPECTRAL_BAND, I_ACQU_STRUCT]
                  REF_TO_SIM_RATIO = DESERT_STRUCT.RTOA[SPECTRAL_BAND, I_ACQU_STRUCT] / DESERT_STRUCT.SIMUL_FILTERED_SENSOR_L1B_REF[SPECTRAL_BAND, I_ACQU_STRUCT]
                  PRINT, ' DEBUG_MODE - REF_TO_SIM_RATIO    = ', REF_TO_SIM_RATIO
                  PRINT, '-----------------------------------'
                  PRINT, ' -------RHO_TOA (SIM) NB/MIN/MAX/MEAN/STDDEV       = ', N_ELEMENTS(RHO_TOA), MIN(RHO_TOA), MAX(RHO_TOA), MEAN(RHO_TOA), STDDEV(RHO_TOA)
                  PRINT, ' -------RHO_TOA_STD (SIM) NB/MIN/MAX/MEAN/STDDEV   = ', N_ELEMENTS(RHO_TOA_STD), MIN(RHO_TOA_STD), MAX(RHO_TOA_STD), MEAN(RHO_TOA_STD), STDDEV(RHO_TOA_STD)
                  PRINT, ' -------RESAMPLED_RHO_TOA NB/MIN/MAX/MEAN/STDDEV   = ', N_ELEMENTS(RESAMPLED_RHO_TOA), MIN(RESAMPLED_RHO_TOA), MAX(RESAMPLED_RHO_TOA), MEAN(RESAMPLED_RHO_TOA), STDDEV(RESAMPLED_RHO_TOA)
                  PRINT, '-----------------------------------'
                ENDIF
                ;REMOVE THE SIMULATION OUTPUT
                SPAWN, ['rm',FILES_BEING_GENERATED[I_CPU]], /NOSHELL
    
                FILES_BEING_GENERATED[I_CPU]='DONE'
                STATE_CPU[I_CPU]=0
                DONE_CPU[I_CPU]=0
              ENDIF
            ENDFOR
          
          ENDWHILE

          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
          ; READ THE LAST SIMULATIONS THAT WERE GENERATED:
          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
          FOR I_CPU=0, MAX_CPU-1 DO BEGIN
            ; DO WE HAVE THE OUTPUT READY? IF YES, THEN SET STATE_CPU TO 0
            IF STATE_CPU[I_CPU] EQ 1 THEN BEGIN
              WHILE STATE_CPU[I_CPU] NE 0 DO  STATE_CPU[I_CPU]=FILE_SEARCH(FILES_BEING_GENERATED[I_CPU]) EQ ''
            
              I_ACQU_STRUCT = IDX_VALID[ ACQUISITION_NB_PROCESSED_BY_CPU[I_CPU] ]

              ; READ THE OUTPUT
              WAIT, .01 ; JUST TO MAKE SURE THE FILE IS WRITTEN TO THE END
              RHO_TOA=READ_MYSTIC_OUTPUT(FILES_BEING_GENERATED[I_CPU])
              
              ; READ THE STANDARD DEVIATION ASSOCIATED TO THE SIMULATION
              RHO_TOA_STD=READ_MYSTIC_OUTPUT(STRMID(FILES_BEING_GENERATED[I_CPU], 0, STRPOS(FILES_BEING_GENERATED[I_CPU], '.rad.spc'))+'.rad.std.spc')
                        
              ; CONVOLUTION OF THE SPECTRAL RESPONSE AND THE SIMULATE SIGNAL
              ; WE SAMPLE THE SIGNAL AND THE SPECTRAL RESPONSE AND A REGULAR INTERVAL SPECTRAL GRID AT 0.1 NM                
              RESAMPLED_RHO_TOA=INTERPOL(RHO_TOA[1,*], RHO_TOA[0,*],WAVELENGTH_GRID)
                
              ; CONVOLUTION OF THE SPECTRAL RESPONSE AND THE SIMULATE SIGNAL
              DESERT_STRUCT.SIMUL_FILTERED_SENSOR_L1B_REF[SPECTRAL_BAND, I_ACQU_STRUCT]=TOTAL(RESAMPLED_RHO_TOA*RESAMPLED_SOLAR_IRRADIANCE*RESAMPLED_SPECTRAL_RESPONSE)/TOTAL(RESAMPLED_SOLAR_IRRADIANCE*RESAMPLED_SPECTRAL_RESPONSE)
                     
              ; COMPUTE THE MEAN STANDARD DEVIATION OVER ALL 1 NM MONOCHROMATIC COMPUTATIONS 
              DESERT_STRUCT.SIMUL_FILTERED_SENSOR_L1B_REF_STD[SPECTRAL_BAND, I_ACQU_STRUCT]=MEAN(RHO_TOA_STD[1,*])/SQRT(N_ELEMENTS(RHO_TOA_STD[1,*]))
              
              IF DEBUG_MODE EQ 1 THEN BEGIN
                PRINT, ' DEBUG_MODE - I_ACQU_STRUCT  = ', I_ACQU_STRUCT
                PRINT, ' DEBUG_MODE - SPECTRAL_BAND  = ', SPECTRAL_BAND
                PRINT, ' DEBUG_MODE - RTOA_OBS       = ',  DESERT_STRUCT.RTOA[SPECTRAL_BAND, I_ACQU_STRUCT]
                PRINT, ' DEBUG_MODE - BAND_RHO_SIM        = ',  DESERT_STRUCT.SIMUL_FILTERED_SENSOR_L1B_REF[SPECTRAL_BAND, I_ACQU_STRUCT]
                PRINT, ' DEBUG_MODE - BAND_RHO_SIM_UNCERT = ',  DESERT_STRUCT.SIMUL_FILTERED_SENSOR_L1B_REF_STD[SPECTRAL_BAND, I_ACQU_STRUCT]
                REF_TO_SIM_RATIO = DESERT_STRUCT.RTOA[SPECTRAL_BAND, I_ACQU_STRUCT] / DESERT_STRUCT.SIMUL_FILTERED_SENSOR_L1B_REF[SPECTRAL_BAND, I_ACQU_STRUCT]
                PRINT, ' DEBUG_MODE - REF_TO_SIM_RATIO    = ', REF_TO_SIM_RATIO
                PRINT, '-----------------------------------'
                PRINT, ' -------RHO_TOA (SIM) NB/MIN/MAX/MEAN/STDDEV       = ', N_ELEMENTS(RHO_TOA), MIN(RHO_TOA), MAX(RHO_TOA), MEAN(RHO_TOA), STDDEV(RHO_TOA)
                PRINT, ' -------RHO_TOA_STD (SIM) NB/MIN/MAX/MEAN/STDDEV   = ', N_ELEMENTS(RHO_TOA_STD), MIN(RHO_TOA_STD), MAX(RHO_TOA_STD), MEAN(RHO_TOA_STD), STDDEV(RHO_TOA_STD)
                PRINT, ' -------RESAMPLED_RHO_TOA NB/MIN/MAX/MEAN/STDDEV   = ', N_ELEMENTS(RESAMPLED_RHO_TOA), MIN(RESAMPLED_RHO_TOA), MAX(RESAMPLED_RHO_TOA), MEAN(RESAMPLED_RHO_TOA), STDDEV(RESAMPLED_RHO_TOA)
                PRINT, '-----------------------------------'
              ENDIF
              
              ;REMOVE THE SIMULATION OUTPUT
              SPAWN, ['rm',FILES_BEING_GENERATED[I_CPU]], /NOSHELL
              
              FILES_BEING_GENERATED[I_CPU]='DONE'
           ENDIF 
            
          ENDFOR
        
  ENDIF ELSE PRINT,'THERE ARE NO ACQUISITIONS TO SIMULATE...'      
  
ENDFOR   ; END LOOP ON BANDS

  ;----------------------
  ; LOOP OVER NCDF FILE IN PROCESSING DATASET TO FILL OUTPUT NCDF FILES

  FOR IDX_FILE=0, NB_FILES-1 DO BEGIN

    IDX_VALID = WHERE( DESERT_STRUCT.IDX_FILE EQ IDX_FILE AND DESERT_STRUCT.VALID EQ 1, NB_VALID)
    IF NB_VALID NE 0 THEN BEGIN
    
      ;---------------------
      ; READ CALIB OUTPUT FILE
      
      YEAR = STRTRIM(STRING(FIX(DESERT_STRUCT.DECIMAL_YEAR[IDX_VALID[0]])),2)
      NCDF_FILENAME = OUT_FILEPATH + YEAR + DL + DESERT_STRUCT.NCDF_OUTPUT[IDX_VALID[0]]
      STATUS = NETCDFREAD_CALIB_OUTPUT(NCDF_FILENAME, NCDF_CALIB_STRUCT=NCDF_CALIB_STRUCT, VERBOSE=VERBOSE)
      IF STATUS NE STATUS_OK THEN BEGIN
        PRINT, FCT_NAME + ': ERROR DURING NCDF FILE READING (', NCDF_FILENAME, ')'
        RETURN, STATUS
      ENDIF
      
      IF DEBUG_MODE EQ 1 THEN BEGIN
        PRINT, '-----------------------------------'     
        PRINT, '------- NCDF  ---------------------'     
        PRINT, '-----------------------------------'    
        PRINT, ' DEBUG_MODE - FILENAME = ', DESERT_STRUCT.NCDF_OUTPUT[IDX_VALID[0]]
        PRINT, ' DEBUG_MODE - IDX_FILE = ', IDX_FILE
        PRINT, ' DEBUG_MODE - IDX_VALID[0] = ', IDX_VALID[0] 
      ENDIF

      ;----------------------
      ; LOOP OVER VALID FIELDS
      
      FOR NUM_VALID=0, NB_VALID-1 DO BEGIN
  
        IDX_STRUCT = IDX_VALID[NUM_VALID]
        
        NUM_DIR = DESERT_STRUCT.VIEWDIR[IDX_STRUCT]
        REF_TO_SIM_RATIO = DESERT_STRUCT.RTOA[*,IDX_STRUCT] / DESERT_STRUCT.SIMUL_FILTERED_SENSOR_L1B_REF[*,IDX_STRUCT]
    
        ;-------------------
        ; UPDATE NCDF CALIBRATION STRUCTURE
        
        NCDF_CALIB_STRUCT.VARIABLES.CALIB_PIXEL_NUMBER[NUM_DIR]        = 1
        NCDF_CALIB_STRUCT.VARIABLES.BAND_RHO_SIM(0,NUM_DIR,*)          = DESERT_STRUCT.SIMUL_FILTERED_SENSOR_L1B_REF[*,IDX_STRUCT]
        NCDF_CALIB_STRUCT.VARIABLES.BAND_RHO_SIM_UNCERT(0,NUM_DIR,*)   = DESERT_STRUCT.SIMUL_FILTERED_SENSOR_L1B_REF_STD[*,IDX_STRUCT]
        NCDF_CALIB_STRUCT.VARIABLES.BAND_REF_TO_SIM_RATIO(0,NUM_DIR,*) = REF_TO_SIM_RATIO
        NCDF_CALIB_STRUCT.VARIABLES.BAND_VALID_INDEX(0,NUM_DIR,*)      = 0
        
        IF DEBUG_MODE EQ 1 THEN BEGIN
          PRINT, '-----------------------------------'     
          PRINT, ' DEBUG_MODE - NUM_DIR  = ', NUM_DIR
          PRINT, ' DEBUG_MODE - RTOA                = ',  DESERT_STRUCT.RTOA[*,IDX_STRUCT]
          PRINT, ' DEBUG_MODE - BAND_RHO_SIM        = ',  DESERT_STRUCT.SIMUL_FILTERED_SENSOR_L1B_REF[*,IDX_STRUCT]
          PRINT, ' DEBUG_MODE - BAND_RHO_SIM_UNCERT = ',  DESERT_STRUCT.SIMUL_FILTERED_SENSOR_L1B_REF_STD[*,IDX_STRUCT]
          PRINT, ' DEBUG_MODE - REF_TO_SIM_RATIO    = ', REF_TO_SIM_RATIO  
          PRINT, '-----------------------------------'     
        ENDIF
                     
      ENDFOR
              
;      IF DEBUG_MODE EQ 1 THEN BEGIN
;        PRINT, '-----------------------------------'
;        FOR SPECTRAL_BAND=0, NB_VALID_BANDS-1 DO BEGIN
;          
;          PRINT, '--------BAND = ', SPECTRAL_BAND ,'------------'
;          PRINT, ' DEBUG_MODE - FILENAME = ', DESERT_STRUCT.NCDF_OUTPUT[IDX_FILE]
;          PRINT, ' DEBUG_MODE - IDX_FILE = ', IDX_FILE
;          PRINT, ' DEBUG_MODE - !!!!! ALL DIRECTIONS (MEAN) !!!!!
;          PRINT, ' DEBUG_MODE - DIRECTIONS          = ', DESERT_STRUCT.VIEWDIR[IDX_VALID]
;          PRINT, ' DEBUG_MODE - BAND_RHO_SIM        = ',  MEAN(DESERT_STRUCT.SIMUL_FILTERED_SENSOR_L1B_REF[SPECTRAL_BAND,IDX_VALID])
;          PRINT, ' DEBUG_MODE - BAND_RHO_SIM_UNCERT = ',  MEAN(DESERT_STRUCT.SIMUL_FILTERED_SENSOR_L1B_REF_STD[SPECTRAL_BAND,IDX_VALID])
;          PRINT, ' DEBUG_MODE - REF_TO_SIM_RATIO    = ', MEAN(DESERT_STRUCT.RTOA[SPECTRAL_BAND,IDX_VALID] / DESERT_STRUCT.SIMUL_FILTERED_SENSOR_L1B_REF[SPECTRAL_BAND,IDX_VALID])
;          PRINT, '-----------------------------------'
;        ENDFOR
;      ENDIF

      ;----------------------
      ; UPDATE CALIBRATION OUTPUT
      
      FILE_DELETE, NCDF_FILENAME, /QUIET

      STATUS = NETCDFWRITE_CALIB_OUTPUT(PROCESS_DATE, NCDF_CALIB_STRUCT, NCDF_FILENAME=NCDF_FILENAME, VERBOSE=VERBOSE)
      IF STATUS NE STATUS_OK THEN BEGIN
        IF KEYWORD_SET(VERBOSE) THEN PRINT, FCT_NAME + ': ERROR DURING OUTPUT CALIBRATION WRITING >> RETURNING'
        RETURN, STATUS_ERROR
      ENDIF

    ENDIF

  ENDFOR ; END LOOP ON FILES


IF KEYWORD_SET(VERBOSE) THEN PRINT, FCT_NAME+': SUCCESSFULL'

RETURN, STATUS_OK

END

