;**************************************************************************************
;**************************************************************************************
;*
;* NAME:
;*      CLOUD_MODULE_MERIS_OCEAN       
;* 
;* PURPOSE:
;*      THIS FUNCTION PERFORMS THE CLOUDSCREENING ALGORITHM DEVELOPED FOR THE MERIS SENSOR 
;*      OVER OCEAN SITE. THE ALGORITHM PERFORMS 2 CLOUD SCREENING PASSES ON PIXELS FLAGGED AS 
;*      "BRIGHT" BY THE OPERATIONAL MERIS BRIGHT PIXEL FLAG ALGORITHM. tHIS ALGORITHM 
;*      HAS BEEN MODIFIED TO WORK USING FIXED THRESHOLDS.
;* 
;* CALLING SEQUENCE:
;*      RES = CLOUD_MODULE_MERIS_OCEAN(SITE_TYPE,GCARBON_REF,CS_ANG)    
;* 
;* INPUTS:
;*      SITE_NAME  - A STRING OF THE DIMITRI VALIDATION SITE NAME '
;*      GCARBON_REF- A FLOAT ARRAY CONTAINING THE TOA REFLECTANCE AT 443,705,750 AND 
;*                   865NM [NB_PIXELS,RHO_BANDS]
;*      CS_ANG     - A 4 ELEMENT ARRAY CONTAINING THE SZA, SAA, VZA AND VAA VALUES 
;*
;* KEYWORDS:
;*      VERBOSE    - PROCESSING STATUS OUTPUTS
;*
;* OUTPUTS:
;*      CLASS_PIXELS - AN INTEGER ARRAY OF SIXE NUMBER OF PIXELS, 0 MEANS CLEAR PIXEL, 
;*                     1 MEANS CLOUDY
;*
;* COMMON BLOCKS:
;*      NONE
;*
;* MODIFICATION HISTORY:
;*      18 NOV 2014 - NCG / MAGELLIUM   - DIMITRI-MAG V3.0
;*
;* VALIDATION HISTORY:
;*      20 JAN 2015 - NCG / MAGELLIUM      - WINDOWS 64BIT MACHINE IDL 8.0: COMPILATION AND OPERATION SUCCESSFUL 
;*      30 MAR 2015 - NCG / MAGELLIUM      - WINDOWS 64BIT MACHINE IDL 8.0: COMPILATION AND OPERATION SUCCESSFUL (DIMITRI V4.0) 
;*
;**************************************************************************************
;**************************************************************************************

FUNCTION CLOUD_MODULE_MERIS_OCEAN, GCARBON_REF_ALL, CS_ANG, SUNGLINT_STATUS=SUNGLINT_STATUS, CS_CLASSIF_MATRIX=CS_CLASSIF_MATRIX, VERBOSE=VERBOSE

  IF KEYWORD_SET(VERBOSE) THEN PRINT,'CLOUD_MODULE_MERIS_OCEAN: STARTING CLOUD SCREENING'

  STATUS_OK = GET_DIMITRI_LOCATION('STATUS_OK')
  STATUS_ERROR = GET_DIMITRI_LOCATION('STATUS_ERROR')

  MISSING_VALUE_LONG   = LONG(GET_DIMITRI_LOCATION('NCDF_MISSING_VALUE'))
  MISSING_VALUE_INT    = FIX(GET_DIMITRI_LOCATION('NCDF_MISSING_VALUE'))
  MISSING_VALUE_FLOAT    = FLOAT(GET_DIMITRI_LOCATION('NCDF_MISSING_VALUE'))
;-------------------------
; RESTORE BRIGHT LUT INFORMATION

  IF KEYWORD_SET(VERBOSE) THEN PRINT,'CLOUD_MODULE_MERIS_OCEAN: RESTORING BRIGHT LUT INFORMATION'
  TEMP_LUT = GET_DIMITRI_LOCATION('BRIGHT_LUT')
  RESTORE,TEMP_LUT

;-------------------------
; DEFINE SNOW AND CLOUD THRESHOLDS

  IF KEYWORD_SET(VERBOSE) THEN PRINT,'CLOUD_MODULE_MERIS_OCEAN: DEFINING THRESHOLDS AND PARAMETERS'
  SNOW_THRESH   = 1.0
  CLOUD_THRESH  = 0.8

; comment BBT : rajouter test pression avecx
  B3 = 1  ; VIS
  B4 = 5  ; NIR
  
  B1 = 0  ; bright
  B2 = 2  ; rededge
  B5 = 3  ; O2
  B6 = 4  ;02
  
 ;----------------------------
  ; ADDED BBT
  ; On s assure que tous les canaux sont valides
  ; on ne conserve que les pixels non perturb√©s dans les canaux choisis
  
   NB_PIXELS_ALL     = N_ELEMENTS(GCARBON_REF_ALL[*,0])
   NBVALID           = INTARR(NB_PIXELS_ALL)
   
   CS_CLASSIF_MATRIX= MAKE_ARRAY(NB_PIXELS_ALL,2,/LONG,VALUE=MISSING_VALUE_LONG)
   
  IDX_VALID  = WHERE ( GCARBON_REF_ALL[*,B1] NE MISSING_VALUE_FLOAT AND $
                       GCARBON_REF_ALL[*,B2] NE MISSING_VALUE_FLOAT AND $ 
                       GCARBON_REF_ALL[*,B3] NE MISSING_VALUE_FLOAT AND $
                       GCARBON_REF_ALL[*,B4] NE MISSING_VALUE_FLOAT, NB_PIXELS)
                       
  IF NB_PIXELS EQ 0 THEN BEGIN
    PRINT,'CLOUD_MODULE_MERIS_OCEAN: ERROR, NO VALID PIXELS !!!'
   RETURN, STATUS_ERROR
  ENDIF
 
   CS_CLASSIF_MATRIX[IDX_VALID,0] = IDX_VALID
 
 ;
 ; VALID PIXELS
 ;
 
; cree tableau GCARBON_REF

  TEMP_DIMS     = SIZE(GCARBON_REF_ALL,/DIMENSIONS)
  NBCAN=TEMP_DIMS[1]
  GCARBON_REF   = FLTARR(NB_PIXELS,NBCAN)
  
  TOTAL_PIXEL_CLASSIFICATION= MAKE_ARRAY(NB_PIXELS,/LONG,VALUE=MISSING_VALUE_LONG)
   
  GCARBON_REF = GCARBON_REF_ALL(IDX_VALID,*)
 
  COL_IND= GCARBON_REF_ALL(*,6)
  LIG_IND= GCARBON_REF_ALL(*,7)
  
  THETAS=CS_ANG(IDX_VALID,0)
  PHIS  =CS_ANG(IDX_VALID,1)
  THETAV=CS_ANG(IDX_VALID,2)
  PHIV  =CS_ANG(IDX_VALID,3)
  
;-------------------------
; DEFINE PARAMETERS FOR CLOUD SCREENING

;  TEMP_DIMS     = SIZE(GCARBON_REF,/DIMENSIONS)
;  NB_PIXELS     = TEMP_DIMS[0]
  BRIGHT_PIXELS = INTARR(NB_PIXELS)
  CLASS_PIXELS  = INTARR(NB_PIXELS)

 PX_CLEAR = 0
 PX_CLOUD = 1

;  ICLEAR  = 0
;  ICLOUD  = 1
  ISNOW   = 2
  IBRIGHT = 3
  
  ;----------------------------
; DEFINE ARRAY TO HOLD PIXEL CLASSIFICATION

  ;PIXEL_CLASSIFICATION = INTARR(NB_PIXELS)
  BADVAL=0
  NBTEST=5 ; 4 tests + Bright
  
  PIXEL_CLASSIFICATION= MAKE_ARRAY(NBTEST,NB_PIXELS,/INTEGER,VALUE=MISSING_VALUE_INT)
  TOTAL_PIXEL_CLASSIFICATION = MAKE_ARRAY(NB_PIXELS,/INTEGER,VALUE=MISSING_VALUE_INT)
  
 ; BRIGHT PIXEL over OCEAN TEST
  TOA_GEO = MAKE_ARRAY(NB_PIXELS,4,/FLOAT,VALUE=MISSING_VALUE_FLOAT)
  TOA_GEO[*,0] = THETAS
  TOA_GEO[*,1] = THETAV
  TOA_GEO[*,2] = PHIS
  TOA_GEO[*,3] = PHIV
  FOR GCI=0L,NB_PIXELS-1 DO BRIGHT_PIXELS[GCI] = DIMITRI_CLOUD_SCREENING_BRIGHT_RHO(GCARBON_REF[GCI,B1],TOA_GEO[GCI,*],BRIGHT_RHO)
 ;-------------------------
; IF NO BRIGHT PIXELS THEN RETURN ALL PIXELS AS CLEAR

  BRIGHTF = WHERE(BRIGHT_PIXELS EQ 1,BRIGTH_COUNT,COMPLEMENT=NOBRIGHTF, NCOMPLEMENT=NBRIGTH_COUNT)
  
  ;-------------------------
; IF OCEANIC SITE THEN BRIGHT PIXELS ARE CLOUD

  IF KEYWORD_SET(VERBOSE) THEN PRINT,'CLOUD_MODULE_MERIS_OCEAN: OCEANIC EXCEPTION, BRIGHT PIXELS ARE CLOUD'
  ;CLASS_PIXELS[BRIGHTF] = PX_CLOUD
  IF BRIGTH_COUNT  NE 0 THEN PIXEL_CLASSIFICATION[4,BRIGHTF]   = PX_CLOUD
  IF NBRIGTH_COUNT NE 0 THEN PIXEL_CLASSIFICATION[4,NOBRIGHTF] = PX_CLEAR
   
  P1F1_THRESHOLD_SUNGLINT=MAKE_ARRAY(NB_PIXELS,/FLOAT,VALUE=MISSING_VALUE_FLOAT)
;----------------------------
; DEFINE THRESHOLDS
  P1F1_THRESHOLD = 0.045
  ;
  P1F5_THRESHOLD = 0.85
  
  IF SUNGLINT_STATUS EQ 1 OR SUNGLINT_STATUS EQ 2 THEN BEGIN
  
    COSTHETAR=SIN(THETAS*!DTOR)*SIN(THETAV*!DTOR) * COS((PHIS-PHIV+180)*!DTOR) + COS(THETAS*!DTOR)*COS(THETAV*!DTOR);
    IMG_THETAR=ACOS(COSTHETAR)*!RADEG
    
   ID1 = WHERE( IMG_THETAR LT 10,P1F1_COUNT,COMPLEMENT=NIDX_BIT20, NCOMPLEMENT=NP1F1_COUNT)
   IF P1F1_COUNT  NE 0 THEN P1F1_THRESHOLD_SUNGLINT(ID1)=INTERPOL([0.4,0.19],[0,10],IMG_THETAR(ID1))  
   ID2 = WHERE( IMG_THETAR GE 10 AND IMG_THETAR LT 20,P1F1_COUNT,COMPLEMENT=NIDX_BIT20, NCOMPLEMENT=NP1F1_COUNT)
   IF P1F1_COUNT  NE 0 THEN P1F1_THRESHOLD_SUNGLINT(ID2)=INTERPOL([0.19,0.085],[10,20],IMG_THETAR(ID2))
   ID3 = WHERE( IMG_THETAR GE 20 AND IMG_THETAR LT 36,P1F1_COUNT,COMPLEMENT=NIDX_BIT20, NCOMPLEMENT=NP1F1_COUNT)
   IF P1F1_COUNT  NE 0 THEN P1F1_THRESHOLD_SUNGLINT(ID3)=INTERPOL([0.085,0.045],[20,36],IMG_THETAR(ID3))
   ID4 = WHERE( IMG_THETAR GE 36 ,P1F1_COUNT,COMPLEMENT=NIDX_BIT20, NCOMPLEMENT=NP1F1_COUNT)
   IF P1F1_COUNT  NE 0 THEN P1F1_THRESHOLD_SUNGLINT(ID4)=0.045
 
    P1F5_THRESHOLD = 1.05  ; 1.025  ; 0.95 publi modis
  ENDIF
    
;
; GROUP III
;

;----------------------------
; PASS1, FILTER 1: BRIGHTNESS THRESHOLD - BAND 4 COMPARED TO 0.045
; BBT: MODIS BIT 20
  IF SUNGLINT_STATUS EQ 1 OR SUNGLINT_STATUS EQ 2 THEN BEGIN

  PIXEL_CLASSIFICATION[0,*]  = GCARBON_REF[*,B4] GT P1F1_THRESHOLD_SUNGLINT

  ENDIF ELSE BEGIN

  IDX_BIT20 = WHERE( GCARBON_REF[*,B4] GT P1F1_THRESHOLD,P1F1_COUNT,COMPLEMENT=NIDX_BIT20, NCOMPLEMENT=NP1F1_COUNT)
  
  IF P1F1_COUNT  NE 0 THEN PIXEL_CLASSIFICATION[0,IDX_BIT20]  = PX_CLOUD
  IF NP1F1_COUNT NE 0 THEN PIXEL_CLASSIFICATION[0,NIDX_BIT20] = PX_CLEAR
  
    ENDELSE

  IF KEYWORD_SET(VERBOSE) THEN PRINT,'CLOUD_MODULE_MERIS_OCEAN: P1_F1 NUMBER = ',P1F1_COUNT

;----------------------------
; PASS1, FILTER 5: B4/3 RATIO - B4/B3 COMPARED TO 1
; BBT: MODIS BIT 21
  
  IDX_BIT21 = WHERE(GCARBON_REF[*,B4]/GCARBON_REF[*,B3] GT P1F5_THRESHOLD,P1F5_COUNT,COMPLEMENT=NIDX_BIT21, NCOMPLEMENT=NP1F5_COUNT)
  
   IF P1F5_COUNT   NE 0 THEN   PIXEL_CLASSIFICATION[1,IDX_BIT21]  = PX_CLOUD
   IF NP1F5_COUNT  NE 0 THEN   PIXEL_CLASSIFICATION[1,NIDX_BIT21] = PX_CLEAR
  
  IF KEYWORD_SET(VERBOSE) THEN PRINT,'CLOUD_MODULE_MERIS_OCEAN: P1_F5 NUMBER = ',P1F5_COUNT

; TEST CV pixel 3x3
; TO DO
; ca veut dire recuperer les lat/lon
 ;
 
 ;on reconstruit l'extrait
   NBCOL=MAX(COL_IND)-MIN(COL_IND)+1
   NBLIG=MAX(LIG_IND)-MIN(LIG_IND)+1
   
   COLO=FIX(COL_IND-MIN(COL_IND))
   LIG=FIX(LIG_IND-MIN(LIG_IND))
    
   ARRAY_SPATIALCOH = MAKE_ARRAY(NBCOL,NBLIG,/FLOAT,VALUE=0)
  ; Fill the array with B4
    FOR J = 0L,  NB_PIXELS-1 DO BEGIN
      ARRAY_SPATIALCOH[COLO[IDX_VALID[J]], LIG[IDX_VALID[J]]]=GCARBON_REF_ALL[IDX_VALID[J],B4]
        ;print,J,COLO[IDX_VALID[J]], LIG[IDX_VALID[J]],IDX_VALID[J],LCCA_REF_ALL[IDX_VALID[J],B4]
    ENDFOR 

; Check that there are at least 3x3 pixels
    DIM_SPACOH = SIZE(ARRAY_SPATIALCOH)
    IF (DIM_SPACOH[0] LE 1 OR  DIM_SPACOH[1] LE 2 OR  DIM_SPACOH[2] LE 2 ) THEN RETURN, STATUS_OK
     
  ; Apply a SZ x SZ window
    SZ=3   
    SPATIALCOH=CLOUD_LOCALSTD(ARRAY_SPATIALCOH,SZ)
    SIGMA_ARRAY=REFORM(SPATIALCOH[1,*,*])
    AVG_ARRAY  =REFORM(SPATIALCOH[0,*,*])
    
    IF SUNGLINT_STATUS EQ 1 OR SUNGLINT_STATUS EQ 2 THEN BEGIN
      THRESHOLD_SIGMA=0.015
      THRESHOLD_AVG=0.015
    ENDIF ELSE BEGIN
      THRESHOLD_SIGMA=0.01
      THRESHOLD_AVG=0.01   
    ENDELSE
    
    SPATIALCOH_MASK = SIGMA_ARRAY GE THRESHOLD_SIGMA OR abs(ARRAY_SPATIALCOH-AVG_ARRAY) GT THRESHOLD_AVG 
          
      FOR IPIX=0L,NB_PIXELS-1 DO BEGIN     
          TOTAL_PIXEL_CLASSIFICATION[IPIX]=(1-PIXEL_CLASSIFICATION[0,IPIX])*(1-PIXEL_CLASSIFICATION[1,IPIX])                
      ENDFOR
      
      ARRAY_OTHERS_MASK = MAKE_ARRAY(NBCOL, NBLIG,/FLOAT,VALUE=0)
        FOR IPIX=0L,NB_PIXELS-1 DO BEGIN           
        ARRAY_OTHERS_MASK[COLO[IDX_VALID[IPIX]], LIG[IDX_VALID[IPIX]]]=TOTAL_PIXEL_CLASSIFICATION[[IPIX]]
        ENDFOR    
          
        NEW_MASK= MAKE_ARRAY(NBCOL, NBLIG,/FLOAT,VALUE=0)       
        NEW_MASK=ARRAY_OTHERS_MASK*(1.0-FLOAT(SPATIALCOH_MASK))
          ; Apply dilatation mask 
          ;S=[1,1]
          S= REPLICATE(1, 3, 3)  
          NEW_MASK_DILATE=DILATE(1-NEW_MASK,S)    
            ;C = DILATE(ERODE(B, S), S)  
; on remet sous forme de vecteur 
; On reconstruit tout le masque 
  FOR IPIX=0L,NB_PIXELS-1 DO BEGIN
    PIXEL_CLASSIFICATION[2,IPIX]=SPATIALCOH_MASK[COLO[IDX_VALID[IPIX]], LIG[IDX_VALID[IPIX]]]
    PIXEL_CLASSIFICATION[3,IPIX]=NEW_MASK_DILATE[COLO[IDX_VALID[IPIX]], LIG[IDX_VALID[IPIX]]]
  ENDFOR

 ; Mettre des statistiques
 ;
 
 ;TODO
  
 RES = WHERE(PIXEL_CLASSIFICATION[4,*] EQ MISSING_VALUE_INT, COUNT)
    IF COUNT GT 0 THEN BEGIN
      PRINT,'CLOUD_MODULE_MERIS_OCEAN: ERROR, SOME PIXELS NOT CLASSIFIED!!!', ' NUM PIX = ',COUNT
      RETURN, STATUS_ERROR
    ENDIF
 ;

  FOR IPIX=0L,NB_PIXELS-1 DO BEGIN     
    TOTAL_PIXEL_CLASSIFICATION[IPIX]=(1-PIXEL_CLASSIFICATION[3,IPIX])                                                     
    ENDFOR
  
; On inverse les codes 
; cloud =1
; clear =0 
 
   ID_CLOUD = WHERE(TOTAL_PIXEL_CLASSIFICATION EQ 0,CLD_COUNT,COMPLEMENT=ID_CLEAR, NCOMPLEMENT=NCLD_COUNT)
   IF CLD_COUNT   NE 0 THEN TOTAL_PIXEL_CLASSIFICATION[ID_CLOUD]  = 1
   IF NCLD_COUNT  NE 0 THEN TOTAL_PIXEL_CLASSIFICATION[ID_CLEAR]  = 0
 
 ; RES = WHERE(TOTAL_PIXEL_CLASSIFICATION EQ BADVAL, COUNT)
;    IF COUNT GT 0 THEN BEGIN
;    PRINT,'CLOUD_MODULE_MERIS_OCEAN: ERROR, SOME PIXELS NOT CLASSIFIED!!!', ' NUM PIX = ',COUNT
 ;   RETURN, STATUS_ERROR
 ; ENDIF
    
   ;ADDED BBT

     CS_CLASSIF_MATRIX[IDX_VALID,1]=TOTAL_PIXEL_CLASSIFICATION
    
   RETURN, STATUS_OK

END