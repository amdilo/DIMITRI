<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Thu Jul  4 16:01:32 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>cmsave.pro (Documentation for /home/marrabld/projects/DIMITRI_2.0/Source/)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="cmsave.pro (Documentation for /home/marrabld/projects/DIMITRI_2.0/Source/)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;   CMSAVE</span>
<span class="comments">;</span>
<span class="comments">; AUTHOR:</span>
<span class="comments">;   Craig B. Markwardt, NASA/GSFC Code 662, Greenbelt, MD 20770</span>
<span class="comments">;   craigm@lheamail.gsfc.nasa.gov</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;   Save IDL variables to a file.  (IDL v5 and greater)</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE: (various)</span>
<span class="comments">;   CMSAVE, var1, var2, ..., FILENAME=filename [, NAMES=names]</span>
<span class="comments">;   CMSAVE, DATA=pointers, NAMES=names, FILENAME=filename</span>
<span class="comments">;   CMSAVE, DATA=handles, NAMES=names,  FILENAME=filename</span>
<span class="comments">;   CMSAVE, DATA=structure,             FILENAME=filename</span>
<span class="comments">;   </span>
<span class="comments">; DESCRIPTION: </span>
<span class="comments">;</span>
<span class="comments">;   CMSAVE is a replacement for the built-in IDL procedure SAVE, with</span>
<span class="comments">;   more flexibility and increased capabilities.</span>
<span class="comments">;</span>
<span class="comments">;   CMSAVE produces output files that are compatible with the standard</span>
<span class="comments">;   save format of IDL versions 4 and 5 (and perhaps greater).</span>
<span class="comments">;   Variables may be restored by using either the built-in procedure</span>
<span class="comments">;   RESTORE, or CMRESTORE.  The CMSV utility library must be installed</span>
<span class="comments">;   in your IDL path to use CMSAVE and CMRESTORE.</span>
<span class="comments">;</span>
<span class="comments">;   The primary advantages to CMSAVE are the ability to append</span>
<span class="comments">;   additional variables to an existing SAVE file, and several</span>
<span class="comments">;   flexible ways to pass the data and variable names to be saved.</span>
<span class="comments">;   CMSAVE also attempts to run on all IDL versions.</span>
<span class="comments">;</span>
<span class="comments">;   To append variables to an existing file, simply specify the APPEND</span>
<span class="comments">;   keyword, and the filename of an existing writable SAVE file.</span>
<span class="comments">;   Variables will be appended to the end of the file.  It is possible</span>
<span class="comments">;   to append a variable with the same name as an existing variable in</span>
<span class="comments">;   a file.  Both data values are stored in the file.  However the</span>
<span class="comments">;   results upon restore are undefined.  There is also a limitation</span>
<span class="comments">;   that only one series of heap values -- pointed-to data -- may be</span>
<span class="comments">;   saved in a file.</span>
<span class="comments">;</span>
<span class="comments">;   By the normal convention of the built-in SAVE command, both the</span>
<span class="comments">;   data and variable names to be saved are passed as parameters on</span>
<span class="comments">;   the command line.  Each parameter must be a named variable; both</span>
<span class="comments">;   the name and value are saved.</span>
<span class="comments">;</span>
<span class="comments">;   This convention may be used in invoking CMSAVE as well.  However,</span>
<span class="comments">;   in addition to passing the data by positional parameter, the user</span>
<span class="comments">;   can pass the data using the DATA keyword.  If the DATA keyword is</span>
<span class="comments">;   used, then an array of pointers or handles may be passed, or a</span>
<span class="comments">;   structure of values may be passed.  (see below)  If both are</span>
<span class="comments">;   passed, then the positional parameters take precedence.</span>
<span class="comments">;</span>
<span class="comments">;   It is also possible to explicitly rename the saved variables: the</span>
<span class="comments">;   saved name does not need to be the name of the named variable.</span>
<span class="comments">;   Use the NAMES keyword to override the default name.  By default</span>
<span class="comments">;   the name is drawn from any named variables, or from the structure</span>
<span class="comments">;   tag names if the DATA keyword is used with a structure.  The NAMES</span>
<span class="comments">;   keyword takes precedence over these values.  NOTE: Values passed</span>
<span class="comments">;   by pointer or handle are not named by default, and so will not be</span>
<span class="comments">;   saved unless the NAMES keyword is used.</span>
<span class="comments">;</span>
<span class="comments">; ==================================================================</span>
<span class="comments">;   Research Systems, Inc. has issued a separate license intended</span>
<span class="comments">;   to resolve any potential conflict between this software and the</span>
<span class="comments">;   IDL End User License Agreement. The text of that license</span>
<span class="comments">;   can be found in the file LICENSE.RSI, included with this</span>
<span class="comments">;   software library.</span>
<span class="comments">; ==================================================================</span>
<span class="comments">;</span>
<span class="comments">; COMPATIBILITY:</span>
<span class="comments">;</span>
<span class="comments">;   -- File Format --</span>
<span class="comments">;   Files written by CMSAVE should be readable with all known versions</span>
<span class="comments">;   of IDL at the time of this writing (version 4 - version 5.4).  It</span>
<span class="comments">;   is expected that this compatibility will persist.</span>
<span class="comments">;</span>
<span class="comments">;   CMSAVE cannot write objects, compressed files, or data sets larger</span>
<span class="comments">;   than 2 gigabytes.</span>
<span class="comments">;</span>
<span class="comments">;   Data types available in newer versions of IDL, such as pointers</span>
<span class="comments">;   and long integers, will not be readable in older versions of IDL</span>
<span class="comments">;   which do not have those data types.</span>
<span class="comments">;</span>
<span class="comments">;   -- Calling Interface --</span>
<span class="comments">;</span>
<span class="comments">;   For the most part, all capabilities of CMSAVE are available to the</span>
<span class="comments">;   user.  However, it should be noted that passing variables by</span>
<span class="comments">;   positional parameter is not available under IDL 4, unless NAMES is</span>
<span class="comments">;   used to name the variables explicitly.</span>
<span class="comments">;</span>
<span class="comments">;   This procedure is part of the CMSVLIB SAVE library for IDL by</span>
<span class="comments">;   Craig Markwardt.  You must have the full CMSVLIB core package</span>
<span class="comments">;   installed in order for this procedure to function properly.</span>
<span class="comments">;</span>
<span class="comments">; INPUTS:</span>
<span class="comments">;</span>
<span class="comments">;   VAR{i} - The variables to be saved.  By default the save name is</span>
<span class="comments">;            taken from the named variables that are passed.  These</span>
<span class="comments">;            default names can be overridden by using the NAMES</span>
<span class="comments">;            keyword.</span>
<span class="comments">;</span>
<span class="comments">;            Variables can also be specified by passing an array of</span>
<span class="comments">;            handles or pointers in the DATA keyword.</span>
<span class="comments">;</span>
<span class="comments">;            If no variables are passed as positional parameters or</span>
<span class="comments">;            using DATA, then CMSAVE will assume that *all* variables</span>
<span class="comments">;            at the caller's level should be saved (this is similar</span>
<span class="comments">;            behavior to the built-in SAVE routine).  Note that system</span>
<span class="comments">;            variables cannot be saved with CMSAVE.</span>
<span class="comments">;</span>
<span class="comments">; KEYWORDS:</span>
<span class="comments">;</span>
<span class="comments">;   ALL - for compatibility with the built-in SAVE routine.  Ignored.</span>
<span class="comments">;         Note that CMSAVE cannot save system variables.</span>
<span class="comments">;</span>
<span class="comments">;   FILENAME - the name of the output file.</span>
<span class="comments">;              Default: 'cmsave.sav'</span>
<span class="comments">;</span>
<span class="comments">;   DATA - A list of data elements to be saved to the output file.</span>
<span class="comments">;          The data elements can be one of the following.  The means</span>
<span class="comments">;          of extracting the data, and the method of naming each</span>
<span class="comments">;          variable, are also indicated.</span>
<span class="comments">;</span>
<span class="comments">;            * An array of pointers to the variables</span>
<span class="comments">;                    Data: pointed-to value     Name: from NAMES keyword</span>
<span class="comments">;            * An array of handles to the variables</span>
<span class="comments">;                    Data: pointed-to value     Name: from NAMES keyword</span>
<span class="comments">;            * A 1-element structure containing data to be saved.</span>
<span class="comments">;                    Data: tag value            Name: tag name</span>
<span class="comments">;</span>
<span class="comments">;          Data values are saved one by one, using the appropriate</span>
<span class="comments">;          name.  Note that any variables passed as positional</span>
<span class="comments">;          parameters will cause the DATA keyword to be ignored.</span>
<span class="comments">;</span>
<span class="comments">;          The calling routine is responsible for deallocating any</span>
<span class="comments">;          pointer or handle resources.</span>
<span class="comments">;</span>
<span class="comments">;   COMPATIBILITY - a string, which describes the format to be used in</span>
<span class="comments">;          the output file.  Possible values are:</span>
<span class="comments">;</span>
<span class="comments">;                  'IDL4' - format of IDL version 4;</span>
<span class="comments">;                  'IDL5' - format of IDL versions 5.0-5.3;</span>
<span class="comments">;                  'IDL6' - not supported yet, for versions 5.4-above;</span>
<span class="comments">;                  'RIVAL1' - same as 'IDL5', plus a directory entry is</span>
<span class="comments">;                            written to the file.</span>
<span class="comments">;           Note that files written in IDL5 format may still be</span>
<span class="comments">;           readable by IDL v.4.</span>
<span class="comments">;           Default: 'IDL5'</span>
<span class="comments">;</span>
<span class="comments">;   NAMES - a string array, giving the names for each variable.  </span>
<span class="comments">;</span>
<span class="comments">;           If the data are passed by positional parameters, the names</span>
<span class="comments">;           are assigned according to the position of the parameter in</span>
<span class="comments">;           the procedure call.  This can be especially useful to</span>
<span class="comments">;           rename local variables, and to give names to expressions.</span>
<span class="comments">;</span>
<span class="comments">;           If the data are passed by an array of pointers or handles,</span>
<span class="comments">;           then the names are assigned according to the position of</span>
<span class="comments">;           the data in the array.  In this case there is no other way</span>
<span class="comments">;           to supply the variable name.  NAMES is required.</span>
<span class="comments">;</span>
<span class="comments">;           If the data are passed in a structure, then the names are</span>
<span class="comments">;           assigned according to the position of the data in the</span>
<span class="comments">;           structure.  The NAMES keyword values override the tag</span>
<span class="comments">;           names.</span>
<span class="comments">;</span>
<span class="comments">;   APPEND - if set, then the specified variables are appended to an</span>
<span class="comments">;            existing file.  </span>
<span class="comments">;</span>
<span class="comments">;            Repeated variables will not cause an error, however they</span>
<span class="comments">;            may not be restored properly using the built-in RESTORE</span>
<span class="comments">;            procedure.  It may also not be permitted to append</span>
<span class="comments">;            variables that contain heap pointers, to a save file</span>
<span class="comments">;            which already contains heap data.</span>
<span class="comments">;</span>
<span class="comments">;   STATUS - upon return, an integer indicating the status of the</span>
<span class="comments">;            operation.  A value of 1 indicates success, while 0</span>
<span class="comments">;            indicates failure.  A failure condition does not</span>
<span class="comments">;            necessarily indicate that an individual variable could</span>
<span class="comments">;            not be written; use the VARSTATUS keyword to detect such</span>
<span class="comments">;            situations.</span>
<span class="comments">;</span>
<span class="comments">;   VARSTATUS - upon return, an integer array indicating the status of</span>
<span class="comments">;               the save operation for each variable.  A value of 1 at</span>
<span class="comments">;               position i in the array indicates success for the ith</span>
<span class="comments">;               variable, while a value of 0 indicates failure.</span>
<span class="comments">;</span>
<span class="comments">;   ERRMSG - upon return, a string indicating the status of the</span>
<span class="comments">;            operation.  The empty string indicates success, while a</span>
<span class="comments">;            non-empty string indicates failure and describes the</span>
<span class="comments">;            error condition.</span>
<span class="comments">;</span>
<span class="comments">;   QUIET - if set, then the error message is returned to the calling</span>
<span class="comments">;           routine.  By default an error condition causes execution</span>
<span class="comments">;           to stop and the message to be printed on the console.</span>
<span class="comments">;</span>
<span class="comments">;   VERBOSE - if set, then a short message is printed for each</span>
<span class="comments">;             variable.</span>
<span class="comments">;</span>
<span class="comments">;   XDR - for compatibility with the built-in SAVE routine.  Ignored.</span>
<span class="comments">;</span>
<span class="comments">; EXAMPLE:</span>
<span class="comments">;</span>
<span class="comments">;   CMSAVE, VAR1, VAR2, FILENAME='test.sav'</span>
<span class="comments">;   CMSAVE, VAR1, VAR2, FILENAME='test.sav', NAMES=['A','B']</span>
<span class="comments">;</span>
<span class="comments">;     Save the data in VAR1 and VAR2 to the file test.sav.  In the</span>
<span class="comments">;     first case the saved variable names will be VAR1 and VAR2.  In</span>
<span class="comments">;     the second case the saved variable names will be A and B.</span>
<span class="comments">;</span>
<span class="comments">;   POINTERS = [ptr_new(VAR1), ptr_new(VAR2)]</span>
<span class="comments">;   CMSAVE, DATA=POINTERS, NAMES=['A','B'], FILENAME='test.sav'</span>
<span class="comments">;</span>
<span class="comments">;     Save the data in VAR1 and VAR2 to the file test.sav.  The saved</span>
<span class="comments">;     variable names will be A and B.  Data are passed by pointer.</span>
<span class="comments">;</span>
<span class="comments">;   STRUCTURE = {A: VAR1, B: VAR2}</span>
<span class="comments">;   CMSAVE, DATA=STRUCTURE, FILENAME='test.sav'</span>
<span class="comments">;</span>
<span class="comments">;     Save the data in VAR1 and VAR2 to the file test.sav.  The saved</span>
<span class="comments">;     variable names will be A and B.  Data are passed by structure.</span>
<span class="comments">;</span>
<span class="comments">; SEE ALSO:</span>
<span class="comments">;</span>
<span class="comments">;   CMRESTORE, SAVE, RESTORE, CMSVLIB</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">;   Written, 14 May 2000</span>
<span class="comments">;   Documented, 22 Sep 2000</span>
<span class="comments">;   Made "more" compatible with SAVE; additional documentation, 11 Jan</span>
<span class="comments">;     2001, CM</span>
<span class="comments">;   Make version checks with correct precision, 19 Jul 2001, CM</span>
<span class="comments">;   Added notification about RSI License, 13 May 2002, CM</span>
<span class="comments">;</span>
<span class="comments">; $Id: cmsave.pro,v 1.16 2009/11/22 23:26:19 craigm Exp $</span>
<span class="comments">;</span>
<span class="comments">;-</span>
<span class="comments">; Copyright (C) 2000-2001, Craig Markwardt</span>
<span class="comments">; This software is provided as is without any warranty whatsoever.</span>
<span class="comments">; Permission to use, copy, modify, and distribute modified or</span>
<span class="comments">; unmodified copies is granted, provided this copyright and disclaimer</span>
<span class="comments">; are included unchanged.</span>
<span class="comments">;-</span>
<a id="cmsave_handle_value:source"></a>function cmsave_handle_value, handle, no_copy=nocop  <span class="comments">;; Utility function</span>
  handle_value, handle, value, no_copy=keyword_set(nocop)
  return, value
end

<span class="comments">;; Undocumented</span>
<span class="comments">;; MTIMES</span>
<span class="comments">;; PASS_METHOD</span>
<span class="comments">;; NOCATCH</span>

<a id="cmsave:source"></a>pro cmsave,   p0,  p1,  p2,  p3,  p4,  p5,  p6,  p7,  p8,  p9, $
             p10, p11, p12, p13, p14, p15, p16, p17, p18, p19, $
             p20, p21, p22, p23, p24, p25, p26, p27, p28, p29, $
             filename=filename0, verbose=verbose, xdr=xdr, $
             compatible=compat0, append=append, all=all, $
             status=status, varstatus=colstatus, mtimes=mtimes, $
             names=names, data=data, pass_method=method, $
             errmsg=errmsg, quiet=quiet, nocatch=nocatch, useunit=useunit, $
             version=revision

  forward_function routine_names, ptr_valid, handle_info

  status = 0
  errmsg = ''
  colstatus = 0 & dummy = temporary(colstatus)  <span class="comments">;; Void out the status</span>

  cmsvlib_version = '&lt;unknown>'
  catch, catcherr
  if catcherr EQ 0 then lib = cmsvlib(/query, version=cmsvlib_version) else lib = 0
  catch, /cancel
  if lib EQ 0 then $
    message, 'ERROR: The CMSVLIB library must be in your IDL path.'

  revision = '$Revision: 1.16 $'
  <span class="comments">;; Extract the version number</span>
  revision = stregex(revision,'\$'+'Revision: *([0-9.]+) *'+'\$',/extract,/sub)
  revision = revision(1)

  if keyword_set(verbose) then begin
     message, /info, 'CMSAVE version '+revision, traceback=0
     message, /info, 'CMSV Library version '+cmsvlib_version(0), traceback=0
  endif

  if NOT keyword_set(nocatch) then on_error, 2

  n_par = n_params()
  ver   = double(!version.release)
  kall  = 0                        <span class="comments">;; NOTE: Ignoring ALL keywod!!</span>
  if n_elements(filename0) EQ 0 then filename0 = 'cmsave.sav'
  filename = strtrim(filename0(0),2)

  if n_elements(compat0) EQ 0 then compat0 = 'IDL5'
  compat = strupcase(strtrim(compat0(0),2))
  lev = routine_names(/level)
  szd = size(data)
  ndata = n_elements(data)
  nnames = n_elements(names)
  
  <span class="comments">;; By default, if no arguments are specified (and no data) then, then</span>
  <span class="comments">;; all of the data in the caller is saved.</span>
  if n_par EQ 0 AND ndata EQ 0 then kall = 1
  if n_par EQ 0 AND kall EQ 0 AND nnames EQ 0 AND ndata EQ 0 then begin
      NO_VARS:
      status = 1
      errmsg = 'WARNING: no variables were specified; '+filename+' not created'
      if NOT keyword_set(quiet) then message, errmsg, /info
      return
  endif

  if kall then begin
      <span class="comments">;; Extract variables from calling procedure</span>
      vlev = lev - 1
      vnames = routine_names(variables=vlev)
      fnames = 'routine_names("'+vnames+'",fetch=vlev)'
      nvar = n_elements(vnames)
      atype = 'FETCH'

  endif else if n_par EQ 0 AND nnames GT 0 then begin
      <span class="comments">;; Extract named variables from the calling procedure</span>
      vlev = lev - 1
      vnames = strtrim(names,2)
      fnames = 'routine_names("'+vnames+'",fetch=vlev)'
      nvar = nnames
      atype = 'FETCH'
      
  endif else if n_par GT 0 then begin
      <span class="comments">;; Extract variables from positional parameters</span>
      vlev = lev
      lev1 = strtrim(lev-1,2)
      nvar = n_par
      fnames = 'p'+strtrim(indgen(nvar),2)
      vnames = strarr(nvar)
      if ver GE 5D then $
        for i = 0L, nvar-1 do $
        dummy = execute('vnames(i) = (routine_names('+fnames(i)+ $
                        ',arg_name='+lev1+'))(0)')
      atype = 'FETCH'

  endif else begin
      <span class="comments">;; Extract variables from DATA</span>
      vlev = lev
      tp = szd(szd(0)+1)
      if tp EQ 10 then begin               <span class="comments">;; POINTER TYPE</span>
          nvar = ndata
          fnames = strarr(nvar) & vnames = fnames
          wh = where(ptr_valid(data) EQ 1, ct)
          if ct GT 0 then fnames(wh) = '*(data['+strtrim(wh,2)+'])'
          atype = 'POINTER'
      endif else if tp EQ 3 then begin     <span class="comments">;; HANDLE TYPE</span>
          nvar = ndata
          fnames = strarr(nvar) & vnames = fnames
          wh = where(handle_info(data) EQ 1, ct)
          if ct GT 0 then $
            fnames(wh) = 'cmsave_handle_value(data('+strtrim(wh,2)+'))'
          atype = 'HANDLE'
      endif else if tp EQ 8 then begin
          nvar = n_tags(data(0))
          stsize = tagsize(data(0), n_tags=nvar, tag_names=vnames)
          fnames = 'data(0).'+vnames
          atype = 'STRUCT'
      endif else begin
          errmsg = 'ERROR: keyword DATA must be a pointer array or structure'
          status = 0
          return
      endelse
  endelse

  if nvar LE 0 then goto, NO_VARS
  colstatus = lonarr(nvar)

  <span class="comments">;; User-renamed variables</span>
  if n_elements(names) GT 0 then begin
      sz = size(names)
      if sz(sz(0)+1) NE 7 then begin
          errmsg = 'ERROR: NAMES must be a string array'
          status = 0
          return
      endif
      vnames(0) = strtrim(strupcase(names(*)),2)
  endif

  <span class="comments">;; Check for variables with missing names.  By default don't do</span>
  <span class="comments">;; anything, unless all the variables do not have names, or if we</span>
  <span class="comments">;; are using IDL 4, which cannot accept parameters from the command</span>
  <span class="comments">;; line.</span>
  wh = where(vnames EQ '', ct)
  if ct EQ nvar then begin
      errmsg = ('ERROR: no variables have names (are you using IDL 4 or' + $
                ' forget the NAMES keyword?)')
      status = 0
      return
  endif
  if ver LT 5D AND ct GT 0 then begin
      if keyword_set(verbose) then $
        message, ('WARNING: in IDL 4 you cannot pass variables by argument '+ $
                  'to CMSAVE.'), /info, traceback=0
  endif

  <span class="comments">;; Collect a summary of pointers</span>
  if ver GE 5D then begin
      cmsv_ptrsum, null, /null
      pheap = null
      pind  = 0L
      
      catcherr = 0
      catch, catcherr
      if catcherr NE 0 then goto, DONE_PTR
      for i = 0L, nvar-1 do begin
          pheap1 = null
          if fnames(i) EQ '' OR $
            execute('cmsv_ptrsum, '+fnames(i)+', pheap1') EQ 0 then $
            goto, DONE_PTR
          if n_elements(pheap1) GT 1 then begin
              pheap = [pheap, pheap1]
              pheap = pheap(uniq(pheap, sort(pheap)))
          endif
          DONE_PTR:
      endfor
      catch, /cancel
  endif else pheap = 0L

  nheap = n_elements(pheap) - 1
  if nheap GT 0 AND compat EQ 'IDL4' then begin
      errmsg = 'ERROR: cannot store pointer data in IDL4 version file'
      status = 0
      return
  endif

  <span class="comments">;; Open output file</span>
  if keyword_set(append) then access='RW' else access='W'
  cmsv_open, unit, filename, off0, access=access, /get_lun, status=status, $
    errmsg=errmsg, compat=compat
  if status EQ 0 then begin
      if keyword_set(quiet) EQ 0 then message, errmsg, traceback=0
      return
  endif
  pp = 0L

  has_heap = 0
  nauxvars = 0L
  if keyword_set(append) then begin
      <span class="comments">;; Scan through input file until we reach the end-of-file block</span>
      bn = ''
      while status EQ 1 AND bn NE 'END_MARKER' do begin
          point_lun, unit, off0
          block = 0 & dummy = temporary(block)
          cmsv_rrec, block, pp, unit=unit, next_block=pnext, /init, $
            block_type=bt, block_name=bn, status=status, errmsg=errmsg, $
            promote64=promote64
          if status EQ 0 then goto, CLEANUP
          if bn EQ 'HEAP_INDEX' then has_heap = 1
          if bn EQ 'VARIABLE' AND status EQ 1 then begin
              cmsv_rvtype, block, pp, vn, sz1, unit=unit, status=st1, $
                template=tp1, errmsg=err1
              if strmid(vn,0,12) EQ '_CMSAVE_DIR_' then $
                nauxvars = nauxvars + 1
          endif
          if status EQ 1 AND bn NE 'END_MARKER' then off0 = pnext
      endwhile

      if bn NE 'END_MARKER' then goto, CLEANUP
      point_lun, unit, off0
      
  endif else begin
      <span class="comments">;; Create the file and append the start record blocks</span>
      if keyword_set(verbose) then $
        message, 'Portable (XDR) SAVE/RESTORE file.', /info

      <span class="comments">;; both timestamp and version information</span>
      cmsv_wrec, block, pp, block_name='TIMESTAMP', offset=off0, $
        status=status, errmsg=errmsg
      if (status NE 0) AND (compat NE 'IDL4') then $
        cmsv_wrec, block, pp, block_name='VERSION', offset=off0, $
        status=status, errmsg=errmsg, compat=compat
      if (status EQ 0) OR (pp EQ 0) then goto, CLEANUP

      writeu, unit, block(0:pp-1)
      off0 = off0 + pp
  endelse

  if nheap GT 0 AND keyword_set(append) AND has_heap AND $
    strmid(compat,0,3) EQ 'IDL' then begin
      errmsg = 'ERROR: cannot APPEND data containing POINTER type'
      goto, CLEANUP
  endif

  pp = 0L
  block = 0 & dummy = temporary(block)

  if nheap GT 0 then begin
      pind = lindgen(nheap) + 1
      pheap = pheap(1:nheap)
      cmsv_wrec, block, pp, pind, block_name='HEAP_INDEX', offset=off0, $
        status=status, errmsg=errmsg, unit=unit1
      if status NE 1 then goto, CLEANUP
  endif 
  if pp GT 0 then writeu, unit, block(0:pp-1)
  off0 = off0 + pp

  if keyword_set(useunit) then $
    unit1 = unit

  pp = 0L
  block = 0 & dummy = temporary(block)
  init = 1 & err1 = '' & saved = 0
  erri = strarr(nvar+nheap)

  catcherr = 0 & caught = 0
  if NOT keyword_set(nocatch) then catch, catcherr
  if catcherr NE 0 then begin
      caught = caught + 1
      goto, DONE_VAR
  endif

  for i = 0L, nheap+nvar-1 do begin
      saved = 0
      nelem = 0
      j = i - nheap

      if j LT 0 then begin
          <span class="comments">;; Extract heap value</span>
          bn = 'HEAP_DATA'
          vname = long(pind(i))
          dummy = execute('sz = size(*pheap(i))')
          if sz(sz(0)+1) EQ 0 then goto, DONE_VAR
          dummy = execute('var = *pheap(i)')

      endif else begin
          <span class="comments">;; Extract variable value</span>
          bn = 'VARIABLE'
          fname = fnames(j)
          vname = vnames(j)
          
          sz = 0 & var = 0 & dummy = temporary(var)
          if fname EQ '' then begin
              NO_NAME:
              err1 = 'WARNING: un-named expression(s) not written'
              goto, DONE_VAR
          endif

          if execute('sz = size('+fname+')') EQ 0 then goto, DONE_VAR
          if sz(sz(0)+1) EQ 0 OR sz(sz(0)+2) EQ 0 then goto, DONE_VAR
          if execute('var = '+fname) EQ 0         then goto, DONE_VAR

          <span class="comments">;; For data taken from the structure then we may need to</span>
          <span class="comments">;; pull out a more accurate array type.</span>
          if atype EQ 'STRUCT' then sz = stsize(*,j)
          sz = sz(0:sz(0)+2)
          
          nelem = n_elements(var)
          if nelem EQ 0  then goto, DONE_VAR
          if vname EQ '' then goto, DONE_VAR
      endelse

      <span class="comments">;; Stupid dimensions can be reformed just by assignment.  This</span>
      <span class="comments">;; will catch and reform the variable.</span>
      if (sz(0) GT 0) AND (n_elements(size(var)) NE n_elements(sz)) then $
        var = reform([var], sz(1:sz(0)), /overwrite)
      sz = size(var)
 
      <span class="comments">;; Write data to a block in memory</span>
      off1 = pp
      cmsv_wrec, block, pp, var, vname, block_name=bn, offset=off0, $
        ptr_index=pind, ptr_data=pheap, init=init, unit=unit1, $
        status=status, errmsg=errmsg
      init = 0
      if status EQ 0 then goto, CLEANUP
      saved = 1

      DONE_VAR:
      <span class="comments">;; A tricky business, this error catching...</span>
      if caught GT 1 then begin
          errmsg = 'ERROR: an internal error occurred'
          goto, CLEANUP
      endif
      if caught GT 0 then begin
          err1 = errmsg
      endif

      <span class="comments">;; If we have accumulated enough data, write to file</span>
      if (pp GT 32768L) OR ((i EQ nheap+nvar-1) AND pp GT 0) then begin
          writeu, unit, block(0:pp-1)
          block = 0 & dummy = temporary(block)
          init = 1
          off0 = off0 + pp
          pp = 0L
      endif
      if keyword_set(useunit) AND pp EQ 0 then $
        point_lun, -unit, off0

      <span class="comments">;; Print some diagnostic messages</span>
      if j GE 0 then begin
          colstatus(j) = saved
          if keyword_set(verbose) AND saved then $
            erri(i) = 'Saved variable: '+vname+'.'
          if saved EQ 0 then begin
              if err1 NE '' then $
                erri(i) = err1 $
              else if nelem EQ 0 then $
                erri(i) = 'Undefined item not saved: '+vnames(j)+'.' $
              else begin
                  erri(i) = ('Expression must be named variable: &lt;'+$
                             helpform('', var, /short)+'>')
                  if ver LT 5D then $
                    erri(i) = erri(i) + ' - use NAMES keyword under IDL4'
              endelse
          endif
      endif else begin
          if keyword_set(verbose) AND saved then $
            erri(i) = ('Saved heap value: &lt;'+ $
                       helpform('', var, /short)+'>')
      endelse

      caught = 0
  endfor
  catch, /cancel
  wh = where(erri NE '', ct)
  if ct GT 0 then begin
      if NOT keyword_set(quiet) then for i = 0L, ct-1 do $
        message, erri(wh(i)), /info
      fmt = '('+strtrim(ct,2)+'(A,:))'
      if ct GT 1 then erri(wh(1:*)) = erri(wh(1:*)) + ';'
      errmsg = string(erri(wh), format=fmt)
  endif

  if pp GT 0 then writeu, unit, (temporary(block))(0:pp-1)
  off0 = off0 + pp

  pp = 0L & off1 = 0L
  <span class="comments">;; Write a set of auxiliary directory information</span>
  whgood = where(colstatus NE 0, ngoodvars)
  if ngoodvars GT 0 AND strmid(compat,0,5) EQ 'RIVAL' then begin
      <span class="comments">;; Construct a unique name for the auxiliary directory</span>
      nauxvars = nauxvars + 1
      fname = filename
      i = (rstrpos(fname,'/') > rstrpos(fname,'\') > rstrpos(fname,':') > $
           rstrpos(fname,';') > 0L)
      fname = byte(strmid(fname, i, strlen(fname)))
      i = strpos(fname, '.')
      if i GT 0 then fname = strupcase(strmid(fname, 0, i))
      bb = byte(fname)
      wh = where(bb LT (byte('A'))(0) OR bb GT (byte('Z'))(0), ct)
      if ct GT 0 then bb(wh) = 32b
      fname = strcompress(string(bb), /remove_all)
      if strlen(fname) EQ 0 then fname = 'FILE'
      
      <span class="comments">;; Whew, we got a name!  Now create the data for the directory</span>
      auxvname = string(fname,nauxvars, $
                        format='("_CMSAVE_DIR_",A0,"_",I2.2)')
      auxvdata = replicate({variable:'', mtime:systime(1)}, ngoodvars)
      auxvdata.variable = vnames(whgood)
      if n_elements(mtimes) GT 0 then $
        auxvdata.mtime(0) = double(mtimes(whgood(0:n_elements(mtimes)-1)))
      auxsz = size(auxvdata)

      <span class="comments">;; Write out directory data</span>
      cmsv_wrec, block, pp, auxvdata, auxvname, block_name='VARIABLE', $
        offset=off0, status=status, errmsg=errmsg, unit=unit1
  endif
  <span class="comments">;; Write end marker</span>
  cmsv_wrec, block, pp, block_name='END_MARKER', status=status, offset=off0
  if status EQ 1 AND pp GT 0 then writeu, unit, block(0:pp-1)
  free_lun, unit
  return

  <span class="comments">;; </span>
  <span class="comments">;; Error handling routine, outside the normal call flow</span>
  CLEANUP:
  catch, /cancel
  free_lun, unit
  status = 0
  if errmsg NE '' AND NOT keyword_set(quiet) then message, errmsg, /info

  return
end
</code>
    </div>
  </body>
</html>