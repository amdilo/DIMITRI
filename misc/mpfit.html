<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Thu Jul  4 16:01:48 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>mpfit.pro (Documentation for /home/marrabld/projects/DIMITRI_2.0/Source/)</title>

    

    <script type="text/javascript" src="../idldoc-resources/js/jquery.js"></script>
    <script type="text/javascript" src="../idldoc-resources/js/copybutton.js"></script>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="mpfit.pro (Documentation for /home/marrabld/projects/DIMITRI_2.0/Source/)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">

    <div class="header">
      <h1>Documentation for /home/marrabld/projects/DIMITRI_2.0/Source/</h1>
      <h2>Generated by IDLdoc</h2>
    </div>
    
    
    <table class="navbar smaller" summary="Navigation header" cellspacing="0">
      <tr>
        <td >
          <a href="../overview.html">Overview</a>
        </td>
    
        <td >
          Directory
        </td>
    
        <td class="selected">File</td>
    
        
        <td >
          <a href="mpfit-code.html" title="Chromocoded source">Source</a> <a href="mpfit.pro" title=".pro file"><img src="../idldoc-resources/attach.png" alt="[attach.png]" align="top"/></a>
        </td>
        
    
        <td >Etc</td>
    
        <td >
        	<a href="../categories.html">Categories</a>
        </td>
    
        <td >
        	<a href="../search.html">Search</a>
        </td>
    
        
        <td >
          <a href="../idldoc-index.html">Index</a>
        </td>
        
    
        
        <td >
          <a href="../idldoc-warnings.html">Warnings</a>
        </td>
        
    
        <td >
          <a href="../idldoc-help.html">Help</a>
        </td>
    
        <td class="flexible">
          Developer documentation
        </td>
      </tr>
    </table>
    
    
    
    <p class="localnavbar smallest"><a href="" target="_top">single page</a> | <a href="../index.html" target="_top">use frames</a> &nbsp;&nbsp;&nbsp; summary &nbsp;&nbsp;&nbsp; class &nbsp;&nbsp;&nbsp; fields &nbsp;&nbsp;&nbsp; <a href="#routine-details">routine details</a> &nbsp;&nbsp;&nbsp; <a href="#attributes">file attributes</a></p>
    
    
    
    
    
    
    
    
    

    <div class="content">
      <h2 class="directory">misc/</h2>
      <h1 class="basename">mpfit.pro<span class="file-attributes"></span></h1>
      

      
      
      
      <br/>

      
      <div id="file_comments">
        <div class="small "><p> NAME:
   MPFIT
</p>

<p> AUTHOR:
   Craig B. Markwardt, NASA/GSFC Code 662, Greenbelt, MD 20770
   craigm@lheamail.gsfc.nasa.gov
   UPDATED VERSIONs can be found on my WEB PAGE:
      http://cow.physics.wisc.edu/~craigm/idl/idl.html
</p>

<p> PURPOSE:
   Perform Levenberg-Marquardt least-squares minimization (MINPACK-1)
</p>

<p> MAJOR TOPICS:
   Curve and Surface Fitting
</p>

<p> CALLING SEQUENCE:
   parms = MPFIT(MYFUNCT, start_parms, FUNCTARGS=fcnargs, NFEV=nfev,
                 MAXITER=maxiter, ERRMSG=errmsg, NPRINT=nprint, QUIET=quiet,
                 FTOL=ftol, XTOL=xtol, GTOL=gtol, NITER=niter,
                 STATUS=status, ITERPROC=iterproc, ITERARGS=iterargs,
                 COVAR=covar, PERROR=perror, BESTNORM=bestnorm,
                 PARINFO=parinfo)
</p>

<p> DESCRIPTION:
</p>

<p>  MPFIT uses the Levenberg-Marquardt technique to solve the
  least-squares problem.  In its typical use, MPFIT will be used to
  fit a user-supplied function (the "model") to user-supplied data
  points (the "data") by adjusting a set of parameters.  MPFIT is
  based upon MINPACK-1 (LMDIF.F) by More' and collaborators.
</p>

<p>  For example, a researcher may think that a set of observed data
  points is best modelled with a Gaussian curve.  A Gaussian curve is
  parameterized by its mean, standard deviation and normalization.
  MPFIT will, within certain constraints, find the set of parameters
  which best fits the data.  The fit is "best" in the least-squares
  sense; that is, the sum of the weighted squared differences between
  the model and data is minimized.
</p>

<p>  The Levenberg-Marquardt technique is a particular strategy for
  iteratively searching for the best fit.  This particular
  implementation is drawn from MINPACK-1 (see NETLIB), and seems to
  be more robust than routines provided with IDL.  This version
  allows upper and lower bounding constraints to be placed on each
  parameter, or the parameter can be held fixed.
</p>

<p>  The IDL user-supplied function should return an array of weighted
  deviations between model and data.  In a typical scientific problem
  the residuals should be weighted so that each deviate has a
  gaussian sigma of 1.0.  If X represents values of the independent
  variable, Y represents a measurement for each value of X, and ERR
  represents the error in the measurements, then the deviates could
  be calculated as follows:
</p>

<p>    DEVIATES = (Y - F(X)) / ERR
</p>

<p>  where F is the function representing the model.  You are
  recommended to use the convenience functions MPFITFUN and
  MPFITEXPR, which are driver functions that calculate the deviates
  for you.  If ERR are the 1-sigma uncertainties in Y, then
</p>

<p>    TOTAL( DEVIATES^2 )
</p>

<p>  will be the total chi-squared value.  MPFIT will minimize the
  chi-square value.  The values of X, Y and ERR are passed through
  MPFIT to the user-supplied function via the FUNCTARGS keyword.
</p>

<p>  Simple constraints can be placed on parameter values by using the
  PARINFO keyword to MPFIT.  See below for a description of this
  keyword.
</p>

<p>  MPFIT does not perform more general optimization tasks.  See TNMIN
  instead.  MPFIT is customized, based on MINPACK-1, to the
  least-squares minimization problem.
</p>

<p> USER FUNCTION
</p>

<p>  The user must define a function which returns the appropriate
  values as specified above.  The function should return the weighted
  deviations between the model and the data.  For applications which
  use finite-difference derivatives -- the default -- the user
  function should be declared in the following way:
</p>

<p>    FUNCTION MYFUNCT, p, X=x, Y=y, ERR=err
     ; Parameter values are passed in "p"
     model = F(x, p)
     return, (y-model)/err
    END
</p>

<p>  See below for applications with explicit derivatives.
</p>

<p>  The keyword parameters X, Y, and ERR in the example above are
  suggestive but not required.  Any parameters can be passed to
  MYFUNCT by using the FUNCTARGS keyword to MPFIT.  Use MPFITFUN and
  MPFITEXPR if you need ideas on how to do that.  The function *must*
  accept a parameter list, P.
</p>

<p>  In general there are no restrictions on the number of dimensions in
  X, Y or ERR.  However the deviates *must* be returned in a
  one-dimensional array, and must have the same type (float or
  double) as the input arrays.
</p>

<p>  See below for error reporting mechanisms.
</p>

<p> CHECKING STATUS AND HANNDLING ERRORS
</p>

<p>  Upon return, MPFIT will report the status of the fitting operation
  in the STATUS and ERRMSG keywords.  The STATUS keyword will contain
  a numerical code which indicates the success or failure status.
  Generally speaking, any value 1 or greater indicates success, while
  a value of 0 or less indicates a possible failure.  The ERRMSG
  keyword will contain a text string which should describe the error
  condition more fully.
</p>

<p>  By default, MPFIT will trap fatal errors and report them to the
  caller gracefully.  However, during the debugging process, it is
  often useful to halt execution where the error occurred.  When you
  set the NOCATCH keyword, MPFIT will not do any special error
  trapping, and execution will stop where ever the error occurred.
</p>

<p>  MPFIT does not explicitly change the !ERROR_STATE variable
  (although it may be changed implicitly if MPFIT calls MESSAGE).  It
  is the caller's responsibility to call MESSAGE, /RESET to ensure
  that the error state is initialized before calling MPFIT.
</p>

<p>  User functions may also indicate non-fatal error conditions using
  the ERROR_CODE common block variable, as described below under the
  MPFIT_ERROR common block definition (by setting ERROR_CODE to a
  number between -15 and -1).  When the user function sets an error
  condition via ERROR_CODE, MPFIT will gracefully exit immediately
  and report this condition to the caller.  The ERROR_CODE is
  returned in the STATUS keyword in that case.
</p>

<p> EXPLICIT DERIVATIVES
</p>

<p>  In the search for the best-fit solution, MPFIT by default
  calculates derivatives numerically via a finite difference
  approximation.  The user-supplied function need not calculate the
  derivatives explicitly.  However, the user function *may* calculate
  the derivatives if desired, but only if the model function is
  declared with an additional position parameter, DP, as described
  below.  If the user function does not accept this additional
  parameter, MPFIT will report an error.  As a practical matter, it
  is often sufficient and even faster to allow MPFIT to calculate the
  derivatives numerically, but this option is available for users who
  wish more control over the fitting process.
</p>

<p>  There are two ways to enable explicit derivatives.  First, the user
  can set the keyword AUTODERIVATIVE=0, which is a global switch for
  all parameters.  In this case, MPFIT will request explicit
  derivatives for every free parameter.
</p>

<p>  Second, the user may request explicit derivatives for specifically
  selected parameters using the PARINFO.MPSIDE=3 (see "CONSTRAINING
  PARAMETER VALUES WITH THE PARINFO KEYWORD" below).  In this
  strategy, the user picks and chooses which parameter derivatives
  are computed explicitly versus numerically.  When PARINFO[i].MPSIDE
  EQ 3, then the ith parameter derivative is computed explicitly.
</p>

<p>  The keyword setting AUTODERIVATIVE=0 always globally overrides the
  individual values of PARINFO.MPSIDE.  Setting AUTODERIVATIVE=0 is
  equivalent to resetting PARINFO.MPSIDE=3 for all parameters.
</p>

<p>  However, be aware that even if the user requests explicit
  derivatives for some or all parameters, MPFIT will not always
  request explicit derivatives on ever user function call.
</p>

<p> EXPLICIT DERIVATIVES - CALLING INTERFACE
</p>

<p>  When AUTODERIVATIVE=0, the user function is responsible for
  calculating the derivatives of the *residuals* with respect to each
  parameter.  The user function should be declared as follows:
</p>

<p>    ;
    ; MYFUNCT - example user function
    ;   P - input parameter values (N-element array)
    ;   DP - upon input, an N-vector indicating which parameters
    ;          to compute derivatives for;
    ;        upon output, the user function must return
    ;          an ARRAY(M,N) of derivatives in this keyword
    ;   (keywords) - any other keywords specified by FUNCTARGS
    ; RETURNS - residual values
    ;
    FUNCTION MYFUNCT, p, dp, X=x, Y=y, ERR=err
     model = F(x, p)         ;; Model function
     resid = (y - model)/err ;; Residual calculation (for example)
</p>

<p>     if n_params() GT 1 then begin
       ; Create derivative and compute derivative array
       requested = dp   ; Save original value of DP
       dp = make_array(n_elements(x), n_elements(p), value=x[0]*0)
</p>

<p>       ; Compute derivative if requested by caller
       for i = 0, n_elements(p)-1 do if requested(i) NE 0 then $
         dp(*,i) = FGRAD(x, p, i) / err
     endif
</p>

<p>     return, resid
    END
</p>

<p>  where FGRAD(x, p, i) is a model function which computes the
  derivative of the model F(x,p) with respect to parameter P(i) at X.
</p>

<p>  A quirk in the implementation leaves a stray negative sign in the
  definition of DP.  The derivative of the *residual* should be
  "-FGRAD(x,p,i) / err" because of how the residual is defined
  ("resid = (data - model) / err").  **HOWEVER** because of the
  implementation quirk, MPFIT expects FGRAD(x,p,i)/err instead,
  i.e. the opposite sign of the gradient of RESID.
</p>

<p>  Derivatives should be returned in the DP array. DP should be an
  ARRAY(m,n) array, where m is the number of data points and n is the
  number of parameters.  -DP[i,j] is the derivative of the ith
  residual with respect to the jth parameter (note the minus sign
  due to the quirk described above).
</p>

<p>  As noted above, MPFIT may not always request derivatives from the
  user function.  In those cases, the parameter DP is not passed.
  Therefore functions can use N_PARAMS() to indicate whether they
  must compute the derivatives or not.
</p>

<p>  The derivatives with respect to fixed parameters are ignored; zero
  is an appropriate value to insert for those derivatives.  Upon
  input to the user function, DP is set to a vector with the same
  length as P, with a value of 1 for a parameter which is free, and a
  value of zero for a parameter which is fixed (and hence no
  derivative needs to be calculated).  This input vector may be
  overwritten as needed.  In the example above, the original DP
  vector is saved to a variable called REQUESTED, and used as a mask
  to calculate only those derivatives that are required.
</p>

<p>  If the data is higher than one dimensional, then the *last*
  dimension should be the parameter dimension.  Example: fitting a
  50x50 image, "dp" should be 50x50xNPAR.
</p>

<p> EXPLICIT DERIVATIVES - TESTING and DEBUGGING
</p>

<p>  For reasonably complicated user functions, the calculation of
  explicit derivatives of the correct sign and magnitude can be
  difficult to get right.  A simple sign error can cause MPFIT to be
  confused.  MPFIT has a derivative debugging mode which will compute
  the derivatives *both* numerically and explicitly, and compare the
  results.
</p>

<p>  It is expected that during production usage, derivative debugging
  should be disabled for all parameters.
</p>

<p>  In order to enable derivative debugging mode, set the following
  PARINFO members for the ith parameter.
      PARINFO[i].MPSIDE = 3          ; Enable explicit derivatives
      PARINFO[i].MPDERIV_DEBUG = 1   ; Enable derivative debugging mode
      PARINFO[i].MPDERIV_RELTOL = ?? ; Relative tolerance for comparison
      PARINFO[i].MPDERIV_ABSTOL = ?? ; Absolute tolerance for comparison
  Note that these settings are maintained on a parameter-by-parameter
  basis using PARINFO, so the user can choose which parameters
  derivatives will be tested.
</p>

<p>  When .MPDERIV_DEBUG is set, then MPFIT first computes the
  derivative explicitly by requesting them from the user function.
  Then, it computes the derivatives numerically via finite
  differencing, and compares the two values.  If the difference
  exceeds a tolerance threshold, then the values are printed out to
  alert the user.  The tolerance level threshold contains both a
  relative and an absolute component, and is expressed as,
</p>

<p>     ABS(DERIV_U - DERIV_N) GE (ABSTOL + RELTOL*ABS(DERIV_U))
</p>

<p>  where DERIV_U and DERIV_N are the derivatives computed explicitly
  and numerically, respectively.  Appropriate values
  for most users will be:
</p>

<p>      PARINFO[i].MPDERIV_RELTOL = 1d-3 ;; Suggested relative tolerance
      PARINFO[i].MPDERIV_ABSTOL = 1d-7 ;; Suggested absolute tolerance
</p>

<p>  although these thresholds may have to be adjusted for a particular
  problem.  When the threshold is exceeded, users can expect to see a
  tabular report like this one:
</p>

<p>    FJAC DEBUG BEGIN
    #        IPNT       FUNC    DERIV_U    DERIV_N   DIFF_ABS   DIFF_REL
    FJAC PARM 2
               80    -0.7308    0.04233    0.04233 -5.543E-07 -1.309E-05
               99      1.370    0.01417    0.01417 -5.518E-07 -3.895E-05
              118    0.07187   -0.01400   -0.01400 -5.566E-07  3.977E-05
              137      1.844   -0.04216   -0.04216 -5.589E-07  1.326E-05
    FJAC DEBUG END
</p>

<p>  The report will be bracketed by FJAC DEBUG BEGIN/END statements.
  Each parameter will be delimited by the statement FJAC PARM n,
  where n is the parameter number.  The columns are,
</p>

<p>      IPNT - data point number  (0 ... M-1)
      FUNC - function value at that point
      DERIV_U - explicit derivative value at that point
      DERIV_N - numerical derivative estimate at that point
      DIFF_ABS - absolute difference = (DERIV_U - DERIV_N)
      DIFF_REL - relative difference = (DIFF_ABS)/(DERIV_U)
</p>

<p>  When prints appear in this report, it is most important to check
  that the derivatives computed in two different ways have the same
  numerical sign and the same order of magnitude, since these are the
  most common programming mistakes.
</p>

<p> CONSTRAINING PARAMETER VALUES WITH THE PARINFO KEYWORD
</p>

<p>  The behavior of MPFIT can be modified with respect to each
  parameter to be fitted.  A parameter value can be fixed; simple
  boundary constraints can be imposed; limitations on the parameter
  changes can be imposed; properties of the automatic derivative can
  be modified; and parameters can be tied to one another.
</p>

<p>  These properties are governed by the PARINFO structure, which is
  passed as a keyword parameter to MPFIT.
</p>

<p>  PARINFO should be an array of structures, one for each parameter.
  Each parameter is associated with one element of the array, in
  numerical order.  The structure can have the following entries
  (none are required):
</p>

<p>     .VALUE - the starting parameter value (but see the START_PARAMS
              parameter for more information).
</p>

<p>     .FIXED - a boolean value, whether the parameter is to be held
              fixed or not.  Fixed parameters are not varied by
              MPFIT, but are passed on to MYFUNCT for evaluation.
</p>

<p>     .LIMITED - a two-element boolean array.  If the first/second
                element is set, then the parameter is bounded on the
                lower/upper side.  A parameter can be bounded on both
                sides.  Both LIMITED and LIMITS must be given
                together.
</p>

<p>     .LIMITS - a two-element float or double array.  Gives the
               parameter limits on the lower and upper sides,
               respectively.  Zero, one or two of these values can be
               set, depending on the values of LIMITED.  Both LIMITED
               and LIMITS must be given together.
</p>

<p>     .PARNAME - a string, giving the name of the parameter.  The
                fitting code of MPFIT does not use this tag in any
                way.  However, the default ITERPROC will print the
                parameter name if available.
</p>

<p>     .STEP - the step size to be used in calculating the numerical
             derivatives.  If set to zero, then the step size is
             computed automatically.  Ignored when AUTODERIVATIVE=0.
             This value is superceded by the RELSTEP value.
</p>

<p>     .RELSTEP - the *relative* step size to be used in calculating
                the numerical derivatives.  This number is the
                fractional size of the step, compared to the
                parameter value.  This value supercedes the STEP
                setting.  If the parameter is zero, then a default
                step size is chosen.
</p>

<p>     .MPSIDE - selector for type of derivative calculation. This
               field can take one of five possible values:
</p>

<p>                  0 - one-sided derivative computed automatically
                  1 - one-sided derivative (f(x+h) - f(x)  )/h
                 -1 - one-sided derivative (f(x)   - f(x-h))/h
                  2 - two-sided derivative (f(x+h) - f(x-h))/(2*h)
                  3 - explicit derivative used for this parameter
</p>

<p>              In the first four cases, the derivative is approximated
              numerically by finite difference, with step size
              H=STEP, where the STEP parameter is defined above.  The
              last case, MPSIDE=3, indicates to allow the user
              function to compute the derivative explicitly (see
              section on "EXPLICIT DERIVATIVES").  AUTODERIVATIVE=0
              overrides this setting for all parameters, and is
              equivalent to MPSIDE=3 for all parameters.  For
              MPSIDE=0, the "automatic" one-sided derivative method
              will chose a direction for the finite difference which
              does not violate any constraints.  The other methods
              (MPSIDE=-1 or MPSIDE=1) do not perform this check.  The
              two-sided method is in principle more precise, but
              requires twice as many function evaluations.  Default:
              0.
</p>

<p>     .MPDERIV_DEBUG - set this value to 1 to enable debugging of
              user-supplied explicit derivatives (see "TESTING and
              DEBUGGING" section above).  In addition, the
              user must enable calculation of explicit derivatives by
              either setting AUTODERIVATIVE=0, or MPSIDE=3 for the
              desired parameters.  When this option is enabled, a
              report may be printed to the console, depending on the
              MPDERIV_ABSTOL and MPDERIV_RELTOL settings.
              Default: 0 (no debugging)
</p>

<p>     .MPDERIV_ABSTOL, .MPDERIV_RELTOL - tolerance settings for
              print-out of debugging information, for each parameter
              where debugging is enabled.  See "TESTING and
              DEBUGGING" section above for the meanings of these two
              fields.
</p>

<p>     .MPMAXSTEP - the maximum change to be made in the parameter
                  value.  During the fitting process, the parameter
                  will never be changed by more than this value in
                  one iteration.
</p>

<p>                  A value of 0 indicates no maximum.  Default: 0.
</p>

<p>     .TIED - a string expression which "ties" the parameter to other
             free or fixed parameters as an equality constraint.  Any
             expression involving constants and the parameter array P
             are permitted.
             Example: if parameter 2 is always to be twice parameter
             1 then use the following: parinfo[2].tied = '2 * P[1]'.
             Since they are totally constrained, tied parameters are
             considered to be fixed; no errors are computed for them,
             and any LIMITS are not obeyed.
             [ NOTE: the PARNAME can't be used in a TIED expression. ]
</p>

<p>     .MPPRINT - if set to 1, then the default ITERPROC will print the
                parameter value.  If set to 0, the parameter value
                will not be printed.  This tag can be used to
                selectively print only a few parameter values out of
                many.  Default: 1 (all parameters printed)
</p>

<p>     .MPFORMAT - IDL format string to print the parameter within
                 ITERPROC.  Default: '(G20.6)'  (An empty string will
                 also use the default.)
</p>

<p>  Future modifications to the PARINFO structure, if any, will involve
  adding structure tags beginning with the two letters "MP".
  Therefore programmers are urged to avoid using tags starting with
  "MP", but otherwise they are free to include their own fields
  within the PARINFO structure, which will be ignored by MPFIT.
</p>

<p>  PARINFO Example:
  parinfo = replicate({value:0.D, fixed:0, limited:[0,0], $
                       limits:[0.D,0]}, 5)
  parinfo[0].fixed = 1
  parinfo[4].limited[0] = 1
  parinfo[4].limits[0]  = 50.D
  parinfo[*].value = [5.7D, 2.2, 500., 1.5, 2000.]
</p>

<p>  A total of 5 parameters, with starting values of 5.7,
  2.2, 500, 1.5, and 2000 are given.  The first parameter
  is fixed at a value of 5.7, and the last parameter is
  constrained to be above 50.
</p>

<p> COMPATIBILITY
</p>

<p>  This function is designed to work with IDL 5.0 or greater.
</p>

<p>  Because TIED parameters and the "(EXTERNAL)" user-model feature use
  the EXECUTE() function, they cannot be used with the free version
  of the IDL Virtual Machine.
</p>

<p> DETERMINING THE VERSION OF MPFIT
</p>

<p>  MPFIT is a changing library.  Users of MPFIT may also depend on a
  specific version of the library being present.  As of version 1.70
  of MPFIT, a VERSION keyword has been added which allows the user to
  query which version is present.  The keyword works like this:
</p>

<p>    RESULT = MPFIT(/query, VERSION=version)
</p>

<p>  This call uses the /QUERY keyword to query the version number
  without performing any computations.  Users of MPFIT can call this
  method to determine which version is in the IDL path before
  actually using MPFIT to do any numerical work.  Upon return, the
  VERSION keyword contains the version number of MPFIT, expressed as
  a string of the form 'X.Y' where X and Y are integers.
</p>

<p>  Users can perform their own version checking, or use the built-in
  error checking of MPFIT.  The MIN_VERSION keyword enforces the
  requested minimum version number.  For example,
</p>

<p>    RESULT = MPFIT(/query, VERSION=version, MIN_VERSION='1.70')
</p>

<p>  will check whether the accessed version is 1.70 or greater, without
  performing any numerical processing.
</p>

<p>  Because the VERSION and MIN_VERSION keywords were added in MPFIT
  version 1.70 and later.  If the caller attempts to use the VERSION
  or MIN_VERSION keywords, and an *older* version of the code is
  present in the caller's path, then IDL will throw an 'unknown
  keyword' error.  Therefore, in order to be robust, the caller, must
  use exception handling.  Here is an example demanding at least
  version 1.70.
</p>

<p>    MPFIT_OK = 0  & VERSION = '&lt;unknown&gt;'
    CATCH, CATCHERR
    IF CATCHERR EQ 0 THEN MPFIT_OK = MPFIT(/query, VERSION=version, $
                                         MIN_VERSION='1.70')
    CATCH, /CANCEL
</p>

<p>    IF NOT MPFIT_OK THEN $
      MESSAGE, 'ERROR: you must have MPFIT version 1.70 or higher in '+$
             'your path (found version '+version+')'
</p>

<p>  Of course, the caller can also do its own version number
  requirements checking.
</p>

<p> HARD-TO-COMPUTE FUNCTIONS: "EXTERNAL" EVALUATION
</p>

<p>  The normal mode of operation for MPFIT is for the user to pass a
  function name, and MPFIT will call the user function multiple times
  as it iterates toward a solution.
</p>

<p>  Some user functions are particularly hard to compute using the
  standard model of MPFIT.  Usually these are functions that depend
  on a large amount of external data, and so it is not feasible, or
  at least highly impractical, to have MPFIT call it.  In those cases
  it may be possible to use the "(EXTERNAL)" evaluation option.
</p>

<p>  In this case the user is responsible for making all function *and
  derivative* evaluations.  The function and Jacobian data are passed
  in through the EXTERNAL_FVEC and EXTERNAL_FJAC keywords,
  respectively.  The user indicates the selection of this option by
  specifying a function name (MYFUNCT) of "(EXTERNAL)".  No
  user-function calls are made when EXTERNAL evaluation is being
  used.
</p>

<p>  ** SPECIAL NOTE ** For the "(EXTERNAL)" case, the quirk noted above
     does not apply.  The gradient matrix, EXTERNAL_FJAC, should be
     comparable to "-FGRAD(x,p)/err", which is the *opposite* sign of
     the DP matrix described above.  In other words, EXTERNAL_FJAC
     has the same sign as the derivative of EXTERNAL_FVEC, and the
     opposite sign of FGRAD.
</p>

<p>  At the end of each iteration, control returns to the user, who must
  reevaluate the function at its new parameter values.  Users should
  check the return value of the STATUS keyword, where a value of 9
  indicates the user should supply more data for the next iteration,
  and re-call MPFIT.  The user may refrain from calling MPFIT
  further; as usual, STATUS will indicate when the solution has
  converged and no more iterations are required.
</p>

<p>  Because MPFIT must maintain its own data structures between calls,
  the user must also pass a named variable to the EXTERNAL_STATE
  keyword.  This variable must be maintained by the user, but not
  changed, throughout the fitting process.  When no more iterations
  are desired, the named variable may be discarded.
</p>

<p> INPUTS:
   MYFUNCT - a string variable containing the name of the function to
             be minimized.  The function should return the weighted
             deviations between the model and the data, as described
             above.
</p>

<p>             For EXTERNAL evaluation of functions, this parameter
             should be set to a value of "(EXTERNAL)".
</p>

<p>   START_PARAMS - An one-dimensional array of starting values for each of the
                  parameters of the model.  The number of parameters
                  should be fewer than the number of measurements.
                  Also, the parameters should have the same data type
                  as the measurements (double is preferred).
</p>

<p>                  This parameter is optional if the PARINFO keyword
                  is used (but see PARINFO).  The PARINFO keyword
                  provides a mechanism to fix or constrain individual
                  parameters.  If both START_PARAMS and PARINFO are
                  passed, then the starting *value* is taken from
                  START_PARAMS, but the *constraints* are taken from
                  PARINFO.
</p>

<p> RETURNS:
</p>

<p>   Returns the array of best-fit parameters.
   Exceptions:
      * if /QUERY is set (see QUERY).
</p>

<p> KEYWORD PARAMETERS:
</p>

<p>   AUTODERIVATIVE - If this is set, derivatives of the function will
                    be computed automatically via a finite
                    differencing procedure.  If not set, then MYFUNCT
                    must provide the explicit derivatives.
                    Default: set (=1)
                    NOTE: to supply your own explicit derivatives,
                      explicitly pass AUTODERIVATIVE=0
</p>

<p>   BESTNORM - the value of the summed squared weighted residuals for
              the returned parameter values, i.e. TOTAL(DEVIATES^2).
</p>

<p>   COVAR - the covariance matrix for the set of parameters returned
           by MPFIT.  The matrix is NxN where N is the number of
           parameters.  The square root of the diagonal elements
           gives the formal 1-sigma statistical errors on the
           parameters IF errors were treated "properly" in MYFUNC.
           Parameter errors are also returned in PERROR.
</p>

<p>           To compute the correlation matrix, PCOR, use this example:
                  PCOR = COV * 0
                  FOR i = 0, n-1 DO FOR j = 0, n-1 DO $
                    PCOR[i,j] = COV[i,j]/sqrt(COV[i,i]*COV[j,j])
           or equivalently, in vector notation,
                  PCOR = COV / (PERROR # PERROR)
</p>

<p>           If NOCOVAR is set or MPFIT terminated abnormally, then
           COVAR is set to a scalar with value !VALUES.D_NAN.
</p>

<p>   DOF - number of degrees of freedom, computed as
             DOF = N_ELEMENTS(DEVIATES) - NFREE
         Note that this doesn't account for pegged parameters (see
         NPEGGED).
</p>

<p>   ERRMSG - a string error or warning message is returned.
</p>

<p>   EXTERNAL_FVEC - upon input, the function values, evaluated at
                   START_PARAMS.  This should be an M-vector, where M
                   is the number of data points.
</p>

<p>   EXTERNAL_FJAC - upon input, the Jacobian array of partial
                   derivative values.  This should be a M x N array,
                   where M is the number of data points and N is the
                   number of parameters.  NOTE: that all FIXED or
                   TIED parameters must *not* be included in this
                   array.
</p>

<p>   EXTERNAL_STATE - a named variable to store MPFIT-related state
                    information between iterations (used in input and
                    output to MPFIT).  The user must not manipulate
                    or discard this data until the final iteration is
                    performed.
</p>

<p>   FASTNORM - set this keyword to select a faster algorithm to
              compute sum-of-square values internally.  For systems
              with large numbers of data points, the standard
              algorithm can become prohibitively slow because it
              cannot be vectorized well.  By setting this keyword,
              MPFIT will run faster, but it will be more prone to
              floating point overflows and underflows.  Thus, setting
              this keyword may sacrifice some stability in the
              fitting process.
</p>

<p>   FTOL - a nonnegative input variable. Termination occurs when both
          the actual and predicted relative reductions in the sum of
          squares are at most FTOL (and STATUS is accordingly set to
          1 or 3).  Therefore, FTOL measures the relative error
          desired in the sum of squares.  Default: 1D-10
</p>

<p>   FUNCTARGS - A structure which contains the parameters to be passed
               to the user-supplied function specified by MYFUNCT via
               the _EXTRA mechanism.  This is the way you can pass
               additional data to your user-supplied function without
               using common blocks.
</p>

<p>               Consider the following example:
                if FUNCTARGS = { XVAL:[1.D,2,3], YVAL:[1.D,4,9],
                                 ERRVAL:[1.D,1,1] }
                then the user supplied function should be declared
                like this:
                FUNCTION MYFUNCT, P, XVAL=x, YVAL=y, ERRVAL=err
</p>

<p>               By default, no extra parameters are passed to the
               user-supplied function, but your function should
               accept *at least* one keyword parameter.  [ This is to
               accomodate a limitation in IDL's _EXTRA
               parameter-passing mechanism. ]
</p>

<p>   GTOL - a nonnegative input variable. Termination occurs when the
          cosine of the angle between fvec and any column of the
          jacobian is at most GTOL in absolute value (and STATUS is
          accordingly set to 4). Therefore, GTOL measures the
          orthogonality desired between the function vector and the
          columns of the jacobian.  Default: 1D-10
</p>

<p>   ITERARGS - The keyword arguments to be passed to ITERPROC via the
              _EXTRA mechanism.  This should be a structure, and is
              similar in operation to FUNCTARGS.
              Default: no arguments are passed.
</p>

<p>   ITERPRINT - The name of an IDL procedure, equivalent to PRINT,
               that ITERPROC will use to render output.  ITERPRINT
               should be able to accept at least four positional
               arguments.  In addition, it should be able to accept
               the standard FORMAT keyword for output formatting; and
               the UNIT keyword, to redirect output to a logical file
               unit (default should be UNIT=1, standard output).
               These keywords are passed using the ITERARGS keyword
               above.  The ITERPRINT procedure must accept the _EXTRA
               keyword.
               NOTE: that much formatting can be handled with the
                     MPPRINT and MPFORMAT tags.
               Default: 'MPFIT_DEFPRINT' (default internal formatter)
</p>

<p>   ITERPROC - The name of a procedure to be called upon each NPRINT
              iteration of the MPFIT routine.  ITERPROC is always
              called in the final iteration.  It should be declared
              in the following way:
</p>

<p>              PRO ITERPROC, MYFUNCT, p, iter, fnorm, FUNCTARGS=fcnargs, $
                PARINFO=parinfo, QUIET=quiet, DOF=dof, PFORMAT=pformat, $
                UNIT=unit, ...
                ; perform custom iteration update
              END
</p>

<p>              ITERPROC must either accept all three keyword
              parameters (FUNCTARGS, PARINFO and QUIET), or at least
              accept them via the _EXTRA keyword.
</p>

<p>              MYFUNCT is the user-supplied function to be minimized,
              P is the current set of model parameters, ITER is the
              iteration number, and FUNCTARGS are the arguments to be
              passed to MYFUNCT.  FNORM should be the chi-squared
              value.  QUIET is set when no textual output should be
              printed.  DOF is the number of degrees of freedom,
              normally the number of points less the number of free
              parameters.  See below for documentation of PARINFO.
              PFORMAT is the default parameter value format.  UNIT is
              passed on to the ITERPRINT procedure, and should
              indicate the file unit where log output will be sent
              (default: standard output).
</p>

<p>              In implementation, ITERPROC can perform updates to the
              terminal or graphical user interface, to provide
              feedback while the fit proceeds.  If the fit is to be
              stopped for any reason, then ITERPROC should set the
              common block variable ERROR_CODE to negative value
              between -15 and -1 (see MPFIT_ERROR common block
              below).  In principle, ITERPROC should probably not
              modify the parameter values, because it may interfere
              with the algorithm's stability.  In practice it is
              allowed.
</p>

<p>              Default: an internal routine is used to print the
                       parameter values.
</p>

<p>   ITERSTOP - Set this keyword if you wish to be able to stop the
              fitting by hitting the predefined ITERKEYSTOP key on
              the keyboard.  This only works if you use the default
              ITERPROC.
</p>

<p>   ITERKEYSTOP - A keyboard key which will halt the fit (and if
                 ITERSTOP is set and the default ITERPROC is used).
                 ITERSTOPKEY may either be a one-character string
                 with the desired key, or a scalar integer giving the
                 ASCII code of the desired key.
                 Default: 7b (control-g)
</p>

<p>                 NOTE: the default value of ASCI 7 (control-G) cannot
                 be read in some windowing environments, so you must
                 change to a printable character like 'q'.
</p>

<p>   MAXITER - The maximum number of iterations to perform.  If the
             number is exceeded, then the STATUS value is set to 5
             and MPFIT returns.
             Default: 200 iterations
</p>

<p>   MIN_VERSION - The minimum requested version number.  This must be
                 a scalar string of the form returned by the VERSION
                 keyword.  If the current version of MPFIT does not
                 satisfy the minimum requested version number, then,
                    MPFIT(/query, min_version='...') returns 0
                    MPFIT(...) returns NAN
                 Default: no version number check
                 NOTE: MIN_VERSION was added in MPFIT version 1.70
</p>

<p>   NFEV - the number of MYFUNCT function evaluations performed.
</p>

<p>   NFREE - the number of free parameters in the fit.  This includes
           parameters which are not FIXED and not TIED, but it does
           include parameters which are pegged at LIMITS.
</p>

<p>   NITER - the number of iterations completed.
</p>

<p>   NOCATCH - if set, then MPFIT will not perform any error trapping.
             By default (not set), MPFIT will trap errors and report
             them to the caller.  This keyword will typically be used
             for debugging.
</p>

<p>   NOCOVAR - set this keyword to prevent the calculation of the
             covariance matrix before returning (see COVAR)
</p>

<p>   NPEGGED - the number of free parameters which are pegged at a
             LIMIT.
</p>

<p>   NPRINT - The frequency with which ITERPROC is called.  A value of
            1 indicates that ITERPROC is called with every iteration,
            while 2 indicates every other iteration, etc.  Be aware
            that several Levenberg-Marquardt attempts can be made in
            a single iteration.  Also, the ITERPROC is *always*
            called for the final iteration, regardless of the
            iteration number.
            Default value: 1
</p>

<p>   PARINFO - A one-dimensional array of structures.
             Provides a mechanism for more sophisticated constraints
             to be placed on parameter values.  When PARINFO is not
             passed, then it is assumed that all parameters are free
             and unconstrained.  Values in PARINFO are never
             modified during a call to MPFIT.
</p>

<p>             See description above for the structure of PARINFO.
</p>

<p>             Default value:  all parameters are free and unconstrained.
</p>

<p>   PERROR - The formal 1-sigma errors in each parameter, computed
            from the covariance matrix.  If a parameter is held
            fixed, or if it touches a boundary, then the error is
            reported as zero.
</p>

<p>            If the fit is unweighted (i.e. no errors were given, or
            the weights were uniformly set to unity), then PERROR
            will probably not represent the true parameter
            uncertainties.
</p>

<p>            *If* you can assume that the true reduced chi-squared
            value is unity -- meaning that the fit is implicitly
            assumed to be of good quality -- then the estimated
            parameter uncertainties can be computed by scaling PERROR
            by the measured chi-squared value.
</p>

<p>              DOF     = N_ELEMENTS(X) - N_ELEMENTS(PARMS) ; deg of freedom
              PCERROR = PERROR * SQRT(BESTNORM / DOF)   ; scaled uncertainties
</p>

<p>   QUERY - if set, then MPFIT() will return immediately with one of
           the following values:
                 1 - if MIN_VERSION is not set
                 1 - if MIN_VERSION is set and MPFIT satisfies the minimum
                 0 - if MIN_VERSION is set and MPFIT does not satisfy it
           The VERSION output keyword is always set upon return.
           Default: not set.
</p>

<p>   QUIET - set this keyword when no textual output should be printed
           by MPFIT
</p>

<p>   RESDAMP - a scalar number, indicating the cut-off value of
             residuals where "damping" will occur.  Residuals with
             magnitudes greater than this number will be replaced by
             their logarithm.  This partially mitigates the so-called
             large residual problem inherent in least-squares solvers
             (as for the test problem CURVI, http://www.maxthis.com/-
             curviex.htm).  A value of 0 indicates no damping.
             Default: 0
</p>

<p>             Note: RESDAMP doesn't work with AUTODERIV=0
</p>

<p>   STATUS - an integer status code is returned.  All values greater
            than zero can represent success (however STATUS EQ 5 may
            indicate failure to converge).  It can have one of the
            following values:
</p>

<p>        -18  a fatal execution error has occurred.  More information
             may be available in the ERRMSG string.
</p>

<p>        -16  a parameter or function value has become infinite or an
             undefined number.  This is usually a consequence of
             numerical overflow in the user's model function, which
             must be avoided.
</p>

<p>        -15 to -1
             these are error codes that either MYFUNCT or ITERPROC
             may return to terminate the fitting process (see
             description of MPFIT_ERROR common below).  If either
             MYFUNCT or ITERPROC set ERROR_CODE to a negative number,
             then that number is returned in STATUS.  Values from -15
             to -1 are reserved for the user functions and will not
             clash with MPFIT.
</p>

<p>	   0  improper input parameters.
</p>

<p>	   1  both actual and predicted relative reductions
	      in the sum of squares are at most FTOL.
</p>

<p>	   2  relative error between two consecutive iterates
	      is at most XTOL
</p>

<p>	   3  conditions for STATUS = 1 and STATUS = 2 both hold.
</p>

<p>	   4  the cosine of the angle between fvec and any
	      column of the jacobian is at most GTOL in
	      absolute value.
</p>

<p>	   5  the maximum number of iterations has been reached
</p>

<p>	   6  FTOL is too small. no further reduction in
	      the sum of squares is possible.
</p>

<p>	   7  XTOL is too small. no further improvement in
	      the approximate solution x is possible.
</p>

<p>	   8  GTOL is too small. fvec is orthogonal to the
	      columns of the jacobian to machine precision.
</p>

<p>          9  A successful single iteration has been completed, and
             the user must supply another "EXTERNAL" evaluation of
             the function and its derivatives.  This status indicator
             is neither an error nor a convergence indicator.
</p>

<p>   VERSION - upon return, VERSION will be set to the MPFIT internal
             version number.  The version number will be a string of
             the form "X.Y" where X is a major revision number and Y
             is a minor revision number.
             NOTE: the VERSION keyword was not present before
               MPFIT version number 1.70, therefore, callers must
               use exception handling when using this keyword.
</p>

<p>   XTOL - a nonnegative input variable. Termination occurs when the
          relative error between two consecutive iterates is at most
          XTOL (and STATUS is accordingly set to 2 or 3).  Therefore,
          XTOL measures the relative error desired in the approximate
          solution.  Default: 1D-10
</p>

<p> EXAMPLE:
</p>

<p>   p0 = [5.7D, 2.2, 500., 1.5, 2000.]
   fa = {X:x, Y:y, ERR:err}
   p = mpfit('MYFUNCT', p0, functargs=fa)
</p>

<p>   Minimizes sum of squares of MYFUNCT.  MYFUNCT is called with the X,
   Y, and ERR keyword parameters that are given by FUNCTARGS.  The
   resulting parameter values are returned in p.
</p>

<p> COMMON BLOCKS:
</p>

<p>   COMMON MPFIT_ERROR, ERROR_CODE
</p>

<p>     User routines may stop the fitting process at any time by
     setting an error condition.  This condition may be set in either
     the user's model computation routine (MYFUNCT), or in the
     iteration procedure (ITERPROC).
</p>

<p>     To stop the fitting, the above common block must be declared,
     and ERROR_CODE must be set to a negative number.  After the user
     procedure or function returns, MPFIT checks the value of this
     common block variable and exits immediately if the error
     condition has been set.  This value is also returned in the
     STATUS keyword: values of -1 through -15 are reserved error
     codes for the user routines.  By default the value of ERROR_CODE
     is zero, indicating a successful function/procedure call.
</p>

<p>   COMMON MPFIT_PROFILE
   COMMON MPFIT_MACHAR
   COMMON MPFIT_CONFIG
</p>

<p>     These are undocumented common blocks are used internally by
     MPFIT and may change in future implementations.
</p>

<p> THEORY OF OPERATION:
</p>

<p>   There are many specific strategies for function minimization.  One
   very popular technique is to use function gradient information to
   realize the local structure of the function.  Near a local minimum
   the function value can be taylor expanded about x0 as follows:
</p>

<p>      f(x) = f(x0) + f'(x0) . (x-x0) + (1/2) (x-x0) . f''(x0) . (x-x0)
             -----   ---------------   -------------------------------  (1)
     Order    0th          1st                      2nd
</p>

<p>   Here f'(x) is the gradient vector of f at x, and f''(x) is the
   Hessian matrix of second derivatives of f at x.  The vector x is
   the set of function parameters, not the measured data vector.  One
   can find the minimum of f, f(xm) using Newton's method, and
   arrives at the following linear equation:
</p>

<p>      f''(x0) . (xm-x0) = - f'(x0)                            (2)
</p>

<p>   If an inverse can be found for f''(x0) then one can solve for
   (xm-x0), the step vector from the current position x0 to the new
   projected minimum.  Here the problem has been linearized (ie, the
   gradient information is known to first order).  f''(x0) is
   symmetric n x n matrix, and should be positive definite.
</p>

<p>   The Levenberg - Marquardt technique is a variation on this theme.
   It adds an additional diagonal term to the equation which may aid the
   convergence properties:
</p>

<p>      (f''(x0) + nu I) . (xm-x0) = -f'(x0)                  (2a)
</p>

<p>   where I is the identity matrix.  When nu is large, the overall
   matrix is diagonally dominant, and the iterations follow steepest
   descent.  When nu is small, the iterations are quadratically
   convergent.
</p>

<p>   In principle, if f''(x0) and f'(x0) are known then xm-x0 can be
   determined.  However the Hessian matrix is often difficult or
   impossible to compute.  The gradient f'(x0) may be easier to
   compute, if even by finite difference techniques.  So-called
   quasi-Newton techniques attempt to successively estimate f''(x0)
   by building up gradient information as the iterations proceed.
</p>

<p>   In the least squares problem there are further simplifications
   which assist in solving eqn (2).  The function to be minimized is
   a sum of squares:
</p>

<p>       f = Sum(hi^2)                                         (3)
</p>

<p>   where hi is the ith residual out of m residuals as described
   above.  This can be substituted back into eqn (2) after computing
   the derivatives:
</p>

<p>       f'  = 2 Sum(hi  hi')
       f'' = 2 Sum(hi' hj') + 2 Sum(hi hi'')                (4)
</p>

<p>   If one assumes that the parameters are already close enough to a
   minimum, then one typically finds that the second term in f'' is
   negligible [or, in any case, is too difficult to compute].  Thus,
   equation (2) can be solved, at least approximately, using only
   gradient information.
</p>

<p>   In matrix notation, the combination of eqns (2) and (4) becomes:
</p>

<p>        hT' . h' . dx = - hT' . h                          (5)
</p>

<p>   Where h is the residual vector (length m), hT is its transpose, h'
   is the Jacobian matrix (dimensions n x m), and dx is (xm-x0).  The
   user function supplies the residual vector h, and in some cases h'
   when it is not found by finite differences (see MPFIT_FDJAC2,
   which finds h and hT').  Even if dx is not the best absolute step
   to take, it does provide a good estimate of the best *direction*,
   so often a line minimization will occur along the dx vector
   direction.
</p>

<p>   The method of solution employed by MINPACK is to form the Q . R
   factorization of h', where Q is an orthogonal matrix such that QT .
   Q = I, and R is upper right triangular.  Using h' = Q . R and the
   ortogonality of Q, eqn (5) becomes
</p>

<p>        (RT . QT) . (Q . R) . dx = - (RT . QT) . h
                     RT . R . dx = - RT . QT . h         (6)
                          R . dx = - QT . h
</p>

<p>   where the last statement follows because R is upper triangular.
   Here, R, QT and h are known so this is a matter of solving for dx.
   The routine MPFIT_QRFAC provides the QR factorization of h, with
   pivoting, and MPFIT_QRSOL;V provides the solution for dx.
</p>

<p> REFERENCES:
</p>

<p>   Markwardt, C. B. 2008, "Non-Linear Least Squares Fitting in IDL
     with MPFIT," in proc. Astronomical Data Analysis Software and
     Systems XVIII, Quebec, Canada, ASP Conference Series, Vol. XXX, eds.
     D. Bohlender, P. Dowler & D. Durand (Astronomical Society of the
     Pacific: San Francisco), p. 251-254 (ISBN: 978-1-58381-702-5)
       http://arxiv.org/abs/0902.2850
       Link to NASA ADS: http://adsabs.harvard.edu/abs/2009ASPC..411..251M
       Link to ASP: http://aspbooks.org/a/volumes/table_of_contents/411
</p>

<p>   Refer to the MPFIT website as:
       http://purl.com/net/mpfit
</p>

<p>   MINPACK-1 software, by Jorge More' et al, available from netlib.
     http://www.netlib.org/
</p>

<p>   "Optimization Software Guide," Jorge More' and Stephen Wright,
     SIAM, *Frontiers in Applied Mathematics*, Number 14.
     (ISBN: 978-0-898713-22-0)
</p>

<p>   More', J. 1978, "The Levenberg-Marquardt Algorithm: Implementation
     and Theory," in Numerical Analysis, vol. 630, ed. G. A. Watson
     (Springer-Verlag: Berlin), p. 105 (DOI: 10.1007/BFb0067690 )
</p>

<p> MODIFICATION HISTORY:
   Translated from MINPACK-1 in FORTRAN, Apr-Jul 1998, CM
   Fixed bug in parameter limits (x vs xnew), 04 Aug 1998, CM
   Added PERROR keyword, 04 Aug 1998, CM
   Added COVAR keyword, 20 Aug 1998, CM
   Added NITER output keyword, 05 Oct 1998
      D.L Windt, Bell Labs, windt@bell-labs.com;
   Made each PARINFO component optional, 05 Oct 1998 CM
   Analytical derivatives allowed via AUTODERIVATIVE keyword, 09 Nov 1998
   Parameter values can be tied to others, 09 Nov 1998
   Fixed small bugs (Wayne Landsman), 24 Nov 1998
   Added better exception error reporting, 24 Nov 1998 CM
   Cosmetic documentation changes, 02 Jan 1999 CM
   Changed definition of ITERPROC to be consistent with TNMIN, 19 Jan 1999 CM
   Fixed bug when AUTDERIVATIVE=0.  Incorrect sign, 02 Feb 1999 CM
   Added keyboard stop to MPFIT_DEFITER, 28 Feb 1999 CM
   Cosmetic documentation changes, 14 May 1999 CM
   IDL optimizations for speed & FASTNORM keyword, 15 May 1999 CM
   Tried a faster version of mpfit_enorm, 30 May 1999 CM
   Changed web address to cow.physics.wisc.edu, 14 Jun 1999 CM
   Found malformation of FDJAC in MPFIT for 1 parm, 03 Aug 1999 CM
   Factored out user-function call into MPFIT_CALL.  It is possible,
     but currently disabled, to call procedures.  The calling format
     is similar to CURVEFIT, 25 Sep 1999, CM
   Slightly changed mpfit_tie to be less intrusive, 25 Sep 1999, CM
   Fixed some bugs associated with tied parameters in mpfit_fdjac, 25
     Sep 1999, CM
   Reordered documentation; now alphabetical, 02 Oct 1999, CM
   Added QUERY keyword for more robust error detection in drivers, 29
     Oct 1999, CM
   Documented PERROR for unweighted fits, 03 Nov 1999, CM
   Split out MPFIT_RESETPROF to aid in profiling, 03 Nov 1999, CM
   Some profiling and speed optimization, 03 Nov 1999, CM
     Worst offenders, in order: fdjac2, qrfac, qrsolv, enorm.
     fdjac2 depends on user function, qrfac and enorm seem to be
     fully optimized.  qrsolv probably could be tweaked a little, but
     is still &lt;10% of total compute time.
   Made sure that !err was set to 0 in MPFIT_DEFITER, 10 Jan 2000, CM
   Fixed small inconsistency in setting of QANYLIM, 28 Jan 2000, CM
   Added PARINFO field RELSTEP, 28 Jan 2000, CM
   Converted to MPFIT_ERROR common block for indicating error
     conditions, 28 Jan 2000, CM
   Corrected scope of MPFIT_ERROR common block, CM, 07 Mar 2000
   Minor speed improvement in MPFIT_ENORM, CM 26 Mar 2000
   Corrected case where ITERPROC changed parameter values and
     parameter values were TIED, CM 26 Mar 2000
   Changed MPFIT_CALL to modify NFEV automatically, and to support
     user procedures more, CM 26 Mar 2000
   Copying permission terms have been liberalized, 26 Mar 2000, CM
   Catch zero value of zero a(j,lj) in MPFIT_QRFAC, 20 Jul 2000, CM
      (thanks to David Schlegel &lt;schlegel@astro.princeton.edu&gt;)
   MPFIT_SETMACHAR is called only once at init; only one common block
     is created (MPFIT_MACHAR); it is now a structure; removed almost
     all CHECK_MATH calls for compatibility with IDL5 and !EXCEPT;
     profiling data is now in a structure too; noted some
     mathematical discrepancies in Linux IDL5.0, 17 Nov 2000, CM
   Some significant changes.  New PARINFO fields: MPSIDE, MPMINSTEP,
     MPMAXSTEP.  Improved documentation.  Now PTIED constraints are
     maintained in the MPCONFIG common block.  A new procedure to
     parse PARINFO fields.  FDJAC2 now computes a larger variety of
     one-sided and two-sided finite difference derivatives.  NFEV is
     stored in the MPCONFIG common now.  17 Dec 2000, CM
   Added check that PARINFO and XALL have same size, 29 Dec 2000 CM
   Don't call function in TERMINATE when there is an error, 05 Jan
     2000
   Check for float vs. double discrepancies; corrected implementation
     of MIN/MAXSTEP, which I still am not sure of, but now at least
     the correct behavior occurs *without* it, CM 08 Jan 2001
   Added SCALE_FCN keyword, to allow for scaling, as for the CASH
     statistic; added documentation about the theory of operation,
     and under the QR factorization; slowly I'm beginning to
     understand the bowels of this algorithm, CM 10 Jan 2001
   Remove MPMINSTEP field of PARINFO, for now at least, CM 11 Jan
     2001
   Added RESDAMP keyword, CM, 14 Jan 2001
   Tried to improve the DAMP handling a little, CM, 13 Mar 2001
   Corrected .PARNAME behavior in _DEFITER, CM, 19 Mar 2001
   Added checks for parameter and function overflow; a new STATUS
     value to reflect this; STATUS values of -15 to -1 are reserved
     for user function errors, CM, 03 Apr 2001
   DAMP keyword is now a TANH, CM, 03 Apr 2001
   Added more error checking of float vs. double, CM, 07 Apr 2001
   Fixed bug in handling of parameter lower limits; moved overflow
     checking to end of loop, CM, 20 Apr 2001
   Failure using GOTO, TERMINATE more graceful if FNORM1 not defined,
     CM, 13 Aug 2001
   Add MPPRINT tag to PARINFO, CM, 19 Nov 2001
   Add DOF keyword to DEFITER procedure, and print degrees of
     freedom, CM, 28 Nov 2001
   Add check to be sure MYFUNCT is a scalar string, CM, 14 Jan 2002
   Addition of EXTERNAL_FJAC, EXTERNAL_FVEC keywords; ability to save
     fitter's state from one call to the next; allow '(EXTERNAL)'
     function name, which implies that user will supply function and
     Jacobian at each iteration, CM, 10 Mar 2002
   Documented EXTERNAL evaluation code, CM, 10 Mar 2002
   Corrected signficant bug in the way that the STEP parameter, and
     FIXED parameters interacted (Thanks Andrew Steffl), CM, 02 Apr
     2002
   Allow COVAR and PERROR keywords to be computed, even in case of
     '(EXTERNAL)' function, 26 May 2002
   Add NFREE and NPEGGED keywords; compute NPEGGED; compute DOF using
     NFREE instead of n_elements(X), thanks to Kristian Kjaer, CM 11
     Sep 2002
   Hopefully PERROR is all positive now, CM 13 Sep 2002
   Documented RELSTEP field of PARINFO (!!), CM, 25 Oct 2002
   Error checking to detect missing start pars, CM 12 Apr 2003
   Add DOF keyword to return degrees of freedom, CM, 30 June 2003
   Always call ITERPROC in the final iteration; add ITERKEYSTOP
     keyword, CM, 30 June 2003
   Correct bug in MPFIT_LMPAR of singularity handling, which might
     likely be fatal for one-parameter fits, CM, 21 Nov 2003
     (with thanks to Peter Tuthill for the proper test case)
   Minor documentation adjustment, 03 Feb 2004, CM
   Correct small error in QR factorization when pivoting; document
     the return values of QRFAC when pivoting, 21 May 2004, CM
   Add MPFORMAT field to PARINFO, and correct behavior of interaction
     between MPPRINT and PARNAME in MPFIT_DEFITERPROC (thanks to Tim
     Robishaw), 23 May 2004, CM
   Add the ITERPRINT keyword to allow redirecting output, 26 Sep
     2004, CM
   Correct MAXSTEP behavior in case of a negative parameter, 26 Sep
     2004, CM
   Fix bug in the parsing of MINSTEP/MAXSTEP, 10 Apr 2005, CM
   Fix bug in the handling of upper/lower limits when the limit was
     negative (the fitting code would never "stick" to the lower
     limit), 29 Jun 2005, CM
   Small documentation update for the TIED field, 05 Sep 2005, CM
   Convert to IDL 5 array syntax (!), 16 Jul 2006, CM
   If MAXITER equals zero, then do the basic parameter checking and
     uncertainty analysis, but do not adjust the parameters, 15 Aug
     2006, CM
   Added documentation, 18 Sep 2006, CM
   A few more IDL 5 array syntax changes, 25 Sep 2006, CM
   Move STRICTARR compile option inside each function/procedure, 9 Oct 2006
   Bug fix for case of MPMAXSTEP and fixed parameters, thanks
     to Huib Intema (who found it from the Python translation!), 05 Feb 2007
   Similar fix for MPFIT_FDJAC2 and the MPSIDE sidedness of
     derivatives, also thanks to Huib Intema, 07 Feb 2007
   Clarify documentation on user-function, derivatives, and PARINFO,
     27 May 2007
   Change the wording of "Analytic Derivatives" to "Explicit
     Derivatives" in the documentation, CM, 03 Sep 2007
   Further documentation tweaks, CM, 13 Dec 2007
   Add COMPATIBILITY section and add credits to copyright, CM, 13 Dec
      2007
   Document and enforce that START_PARMS and PARINFO are 1-d arrays,
      CM, 29 Mar 2008
   Previous change for 1-D arrays wasn't correct for
      PARINFO.LIMITED/.LIMITS; now fixed, CM, 03 May 2008
   Documentation adjustments, CM, 20 Aug 2008
   Change some minor FOR-loop variables to type-long, CM, 03 Sep 2008
   Change error handling slightly, document NOCATCH keyword,
      document error handling in general, CM, 01 Oct 2008
   Special case: when either LIMITS is zero, and a parameter pushes
      against that limit, the coded that 'pegged' it there would not
      work since it was a relative condition; now zero is handled
      properly, CM, 08 Nov 2008
   Documentation of how TIED interacts with LIMITS, CM, 21 Dec 2008
   Better documentation of references, CM, 27 Feb 2009
   If MAXITER=0, then be sure to set STATUS=5, which permits the
      the covariance matrix to be computed, CM, 14 Apr 2009
   Avoid numerical underflow while solving for the LM parameter,
      (thanks to Sergey Koposov) CM, 14 Apr 2009
   Use individual functions for all possible MPFIT_CALL permutations,
      (and make sure the syntax is right) CM, 01 Sep 2009
   Correct behavior of MPMAXSTEP when some parameters are frozen,
      thanks to Josh Destree, CM, 22 Nov 2009
   Update the references section, CM, 22 Nov 2009
   1.70 - Add the VERSION and MIN_VERSION keywords, CM, 22 Nov 2009
   1.71 - Store pre-calculated revision in common, CM, 23 Nov 2009
   1.72-1.74 - Documented alternate method to compute correlation matrix,
          CM, 05 Feb 2010
   1.75 - Enforce TIED constraints when preparing to terminate the
          routine, CM, 2010-06-22
</p>

<p>  $Id: mpfit.pro,v 1.75 2010/06/22 06:43:35 craigm Exp $
</p>

</div>
      </div>
      

      

      

      

      

      
      <div>
        <h2>Routines</h2>

        <dl class="routine-summary">
          
            <dt class="syntax"><a href="#mpfit_dummy"><code>mpfit_dummy</code></a></dt>
            <dd class="small"></dd>
          
            <dt class="syntax"><a href="#mpfit_resetprof"><code>mpfit_resetprof</code></a></dt>
            <dd class="small"></dd>
          
            <dt class="syntax"><a href="#mpfit_setmachar"><code>mpfit_setmachar<span class="argument">, double=<span class="var">double</span></span></code></a></dt>
            <dd class="small"></dd>
          
            <dt class="syntax"><a href="#mpfit_call_func_noextra"><code><span class="var">result</span> = mpfit_call_func_noextra(<span class="argument">fcn</span><span class="argument">, x</span><span class="argument">, fjac</span><span class="argument">, _EXTRA=<span class="var">_EXTRA</span></span>)</code></a></dt>
            <dd class="small"></dd>
          
            <dt class="syntax"><a href="#mpfit_call_func_extra"><code><span class="var">result</span> = mpfit_call_func_extra(<span class="argument">fcn</span><span class="argument">, x</span><span class="argument">, fjac</span><span class="argument">, _EXTRA=<span class="var">_EXTRA</span></span>)</code></a></dt>
            <dd class="small"></dd>
          
            <dt class="syntax"><a href="#mpfit_call_pro_noextra"><code><span class="var">result</span> = mpfit_call_pro_noextra(<span class="argument">fcn</span><span class="argument">, x</span><span class="argument">, fjac</span><span class="argument">, _EXTRA=<span class="var">_EXTRA</span></span>)</code></a></dt>
            <dd class="small"></dd>
          
            <dt class="syntax"><a href="#mpfit_call_pro_extra"><code><span class="var">result</span> = mpfit_call_pro_extra(<span class="argument">fcn</span><span class="argument">, x</span><span class="argument">, fjac</span><span class="argument">, _EXTRA=<span class="var">_EXTRA</span></span>)</code></a></dt>
            <dd class="small"></dd>
          
            <dt class="syntax"><a href="#mpfit_call"><code><span class="var">result</span> = mpfit_call(<span class="argument">fcn</span><span class="argument">, x</span><span class="argument">, fjac</span><span class="argument">, _EXTRA=<span class="var">_EXTRA</span></span>)</code></a></dt>
            <dd class="small"></dd>
          
            <dt class="syntax"><a href="#mpfit_fdjac2"><code><span class="var">result</span> = mpfit_fdjac2(<span class="argument">fcn</span><span class="argument">, x</span><span class="argument">, fvec</span><span class="argument">, step</span><span class="argument">, ulimited</span><span class="argument">, ulimit</span><span class="argument">, dside</span><span class="argument">, iflag=<span class="var">iflag</span></span><span class="argument">, epsfcn=<span class="var">epsfcn</span></span><span class="argument">, autoderiv=<span class="var">autoderiv</span></span><span class="argument">, FUNCTARGS=<span class="var">FUNCTARGS</span></span><span class="argument">, xall=<span class="var">xall</span></span><span class="argument">, ifree=<span class="var">ifree</span></span><span class="argument">, dstep=<span class="var">dstep</span></span><span class="argument">, deriv_debug=<span class="var">deriv_debug</span></span><span class="argument">, deriv_reltol=<span class="var">deriv_reltol</span></span><span class="argument">, deriv_abstol=<span class="var">deriv_abstol</span></span>)</code></a></dt>
            <dd class="small"></dd>
          
            <dt class="syntax"><a href="#mpfit_enorm"><code><span class="var">result</span> = mpfit_enorm(<span class="argument">vec</span>)</code></a></dt>
            <dd class="small"></dd>
          
            <dt class="syntax"><a href="#mpfit_qrfac"><code>mpfit_qrfac<span class="argument">, a</span><span class="argument">, ipvt</span><span class="argument">, rdiag</span><span class="argument">, acnorm</span><span class="argument">, pivot=<span class="var">pivot</span></span></code></a></dt>
            <dd class="small"></dd>
          
            <dt class="syntax"><a href="#mpfit_qrsolv"><code>mpfit_qrsolv<span class="argument">, r</span><span class="argument">, ipvt</span><span class="argument">, diag</span><span class="argument">, qtb</span><span class="argument">, x</span><span class="argument">, sdiag</span></code></a></dt>
            <dd class="small"></dd>
          
            <dt class="syntax"><a href="#mpfit_lmpar"><code><span class="var">result</span> = mpfit_lmpar(<span class="argument">r</span><span class="argument">, ipvt</span><span class="argument">, diag</span><span class="argument">, qtb</span><span class="argument">, delta</span><span class="argument">, x</span><span class="argument">, sdiag</span><span class="argument">, par=<span class="var">par</span></span>)</code></a></dt>
            <dd class="small"></dd>
          
            <dt class="syntax"><a href="#mpfit_tie"><code>mpfit_tie<span class="argument">, p</span><span class="argument">, _ptied</span></code></a></dt>
            <dd class="small"></dd>
          
            <dt class="syntax"><a href="#mpfit_defprint"><code>mpfit_defprint<span class="argument">, p1</span><span class="argument">, p2</span><span class="argument">, p3</span><span class="argument">, p4</span><span class="argument">, p5</span><span class="argument">, p6</span><span class="argument">, p7</span><span class="argument">, p8</span><span class="argument">, p9</span><span class="argument">, p10</span><span class="argument">, p11</span><span class="argument">, p12</span><span class="argument">, p13</span><span class="argument">, p14</span><span class="argument">, p15</span><span class="argument">, p16</span><span class="argument">, p17</span><span class="argument">, p18</span><span class="argument">, format=<span class="var">format</span></span><span class="argument">, unit=<span class="var">unit</span></span><span class="argument">, _EXTRA=<span class="var">_EXTRA</span></span></code></a></dt>
            <dd class="small"></dd>
          
            <dt class="syntax"><a href="#mpfit_defiter"><code>mpfit_defiter<span class="argument">, fcn</span><span class="argument">, x</span><span class="argument">, iter</span><span class="argument">, fnorm</span><span class="argument">, FUNCTARGS=<span class="var">FUNCTARGS</span></span><span class="argument">, quiet=<span class="var">quiet</span></span><span class="argument">, iterstop=<span class="var">iterstop</span></span><span class="argument">, iterkeybyte=<span class="var">iterkeybyte</span></span><span class="argument">, parinfo=<span class="var">parinfo</span></span><span class="argument">, iterprint=<span class="var">iterprint</span></span><span class="argument">, format=<span class="var">format</span></span><span class="argument">, pformat=<span class="var">pformat</span></span><span class="argument">, dof=<span class="var">dof</span></span><span class="argument">, _EXTRA=<span class="var">_EXTRA</span></span></code></a></dt>
            <dd class="small"></dd>
          
            <dt class="syntax"><a href="#mpfit_parinfo"><code>mpfit_parinfo<span class="argument">, parinfo</span><span class="argument">, tnames</span><span class="argument">, tag</span><span class="argument">, values</span><span class="argument">, default=<span class="var">default</span></span><span class="argument">, status=<span class="var">status</span></span><span class="argument">, n_param=<span class="var">n_param</span></span></code></a></dt>
            <dd class="small"></dd>
          
            <dt class="syntax"><a href="#mpfit_covar"><code><span class="var">result</span> = mpfit_covar(<span class="argument">rr</span><span class="argument">, ipvt</span><span class="argument">, tol=<span class="var">tol</span></span>)</code></a></dt>
            <dd class="small"></dd>
          
            <dt class="syntax"><a href="#mpfit_revision"><code><span class="var">result</span> = mpfit_revision()</code></a></dt>
            <dd class="small"></dd>
          
            <dt class="syntax"><a href="#mpfit_parse_version"><code><span class="var">result</span> = mpfit_parse_version(<span class="argument">version</span>)</code></a></dt>
            <dd class="small"></dd>
          
            <dt class="syntax"><a href="#mpfit_min_version"><code><span class="var">result</span> = mpfit_min_version(<span class="argument">version</span><span class="argument">, min_version</span>)</code></a></dt>
            <dd class="small"></dd>
          
            <dt class="syntax"><a href="#mpfit"><code><span class="var">result</span> = mpfit(<span class="argument">fcn</span><span class="argument">, xall</span><span class="argument">, FUNCTARGS=<span class="var">FUNCTARGS</span></span><span class="argument">, SCALE_FCN=<span class="var">SCALE_FCN</span></span><span class="argument">, ftol=<span class="var">ftol</span></span><span class="argument">, xtol=<span class="var">xtol</span></span><span class="argument">, gtol=<span class="var">gtol</span></span><span class="argument">, epsfcn=<span class="var">epsfcn</span></span><span class="argument">, resdamp=<span class="var">resdamp</span></span><span class="argument">, nfev=<span class="var">nfev</span></span><span class="argument">, maxiter=<span class="var">maxiter</span></span><span class="argument">, errmsg=<span class="var">errmsg</span></span><span class="argument">, factor=<span class="var">factor</span></span><span class="argument">, nprint=<span class="var">nprint</span></span><span class="argument">, STATUS=<span class="var">STATUS</span></span><span class="argument">, iterproc=<span class="var">iterproc</span></span><span class="argument">, iterargs=<span class="var">iterargs</span></span><span class="argument">, iterstop=<span class="var">iterstop</span></span><span class="argument">, iterkeystop=<span class="var">iterkeystop</span></span><span class="argument">, niter=<span class="var">niter</span></span><span class="argument">, nfree=<span class="var">nfree</span></span><span class="argument">, npegged=<span class="var">npegged</span></span><span class="argument">, dof=<span class="var">dof</span></span><span class="argument">, diag=<span class="var">diag</span></span><span class="argument">, rescale=<span class="var">rescale</span></span><span class="argument">, autoderivative=<span class="var">autoderivative</span></span><span class="argument">, perror=<span class="var">perror</span></span><span class="argument">, covar=<span class="var">covar</span></span><span class="argument">, nocovar=<span class="var">nocovar</span></span><span class="argument">, bestnorm=<span class="var">bestnorm</span></span><span class="argument">, parinfo=<span class="var">parinfo</span></span><span class="argument">, quiet=<span class="var">quiet</span></span><span class="argument">, nocatch=<span class="var">nocatch</span></span><span class="argument">, fastnorm=<span class="var">fastnorm</span></span><span class="argument">, proc=<span class="var">proc</span></span><span class="argument">, query=<span class="var">query</span></span><span class="argument">, external_state=<span class="var">external_state</span></span><span class="argument">, external_init=<span class="var">external_init</span></span><span class="argument">, external_fvec=<span class="var">external_fvec</span></span><span class="argument">, external_fjac=<span class="var">external_fjac</span></span><span class="argument">, version=<span class="var">version</span></span><span class="argument">, min_version=<span class="var">min_version</span></span>)</code></a></dt>
            <dd class="small"></dd>
          
        </dl>
      </div>
      


      
      <div id="routine-details">
        <h2>Routine details</h2>

        
        <div class="routine-details details" id="mpfit_dummy">
          <h2 class="routine-name"><a href="#root" class="top">top</a> <a href="mpfit-code.html#mpfit_dummy:source" class="top">source</a> mpfit_dummy<span class="routine-attributes"></span></h2>

          

          <p class="syntax"><code>mpfit_dummy</code></p>

          

          

          

          

          

          

          

          

        </div>
        
        <div class="routine-details details" id="mpfit_resetprof">
          <h2 class="routine-name"><a href="#root" class="top">top</a> <a href="mpfit-code.html#mpfit_resetprof:source" class="top">source</a> mpfit_resetprof<span class="routine-attributes"></span></h2>

          

          <p class="syntax"><code>mpfit_resetprof</code></p>

          

          

          

          

          

          

          

          

        </div>
        
        <div class="routine-details details" id="mpfit_setmachar">
          <h2 class="routine-name"><a href="#root" class="top">top</a> <a href="mpfit-code.html#mpfit_setmachar:source" class="top">source</a> mpfit_setmachar<span class="routine-attributes"></span></h2>

          

          <p class="syntax"><code>mpfit_setmachar<span class="argument">, <a href="#mpfit_setmachar:k:double">double</a>=<span class="var">double</span></span></code></p>

          

          

          

          
          <h3>Keywords</h3>
            <dl>
              
              <dt id="mpfit_setmachar:k:double">double <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
            </dl>
          

          

          

          

          

        </div>
        
        <div class="routine-details details" id="mpfit_call_func_noextra">
          <h2 class="routine-name"><a href="#root" class="top">top</a> <a href="mpfit-code.html#mpfit_call_func_noextra:source" class="top">source</a> mpfit_call_func_noextra<span class="routine-attributes"></span></h2>

          

          <p class="syntax"><code><span class="var">result</span> = mpfit_call_func_noextra(<span class="argument"><a href="#mpfit_call_func_noextra:p:fcn">fcn</a></span><span class="argument">, <a href="#mpfit_call_func_noextra:p:x">x</a></span><span class="argument">, <a href="#mpfit_call_func_noextra:p:fjac">fjac</a></span><span class="argument">, <a href="#mpfit_call_func_noextra:k:_EXTRA">_EXTRA</a>=<span class="var">_EXTRA</span></span>)</code></p>

          

          

          
          <h3>Parameters</h3>
            <dl>
              
              <dt id="mpfit_call_func_noextra:p:fcn">fcn <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit_call_func_noextra:p:x">x <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit_call_func_noextra:p:fjac">fjac <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
            </dl>
          

          
          <h3>Keywords</h3>
            <dl>
              
              <dt id="mpfit_call_func_noextra:k:_EXTRA">_EXTRA <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
            </dl>
          

          

          

          

          

        </div>
        
        <div class="routine-details details" id="mpfit_call_func_extra">
          <h2 class="routine-name"><a href="#root" class="top">top</a> <a href="mpfit-code.html#mpfit_call_func_extra:source" class="top">source</a> mpfit_call_func_extra<span class="routine-attributes"></span></h2>

          

          <p class="syntax"><code><span class="var">result</span> = mpfit_call_func_extra(<span class="argument"><a href="#mpfit_call_func_extra:p:fcn">fcn</a></span><span class="argument">, <a href="#mpfit_call_func_extra:p:x">x</a></span><span class="argument">, <a href="#mpfit_call_func_extra:p:fjac">fjac</a></span><span class="argument">, <a href="#mpfit_call_func_extra:k:_EXTRA">_EXTRA</a>=<span class="var">_EXTRA</span></span>)</code></p>

          

          

          
          <h3>Parameters</h3>
            <dl>
              
              <dt id="mpfit_call_func_extra:p:fcn">fcn <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit_call_func_extra:p:x">x <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit_call_func_extra:p:fjac">fjac <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
            </dl>
          

          
          <h3>Keywords</h3>
            <dl>
              
              <dt id="mpfit_call_func_extra:k:_EXTRA">_EXTRA <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
            </dl>
          

          

          

          

          

        </div>
        
        <div class="routine-details details" id="mpfit_call_pro_noextra">
          <h2 class="routine-name"><a href="#root" class="top">top</a> <a href="mpfit-code.html#mpfit_call_pro_noextra:source" class="top">source</a> mpfit_call_pro_noextra<span class="routine-attributes"></span></h2>

          

          <p class="syntax"><code><span class="var">result</span> = mpfit_call_pro_noextra(<span class="argument"><a href="#mpfit_call_pro_noextra:p:fcn">fcn</a></span><span class="argument">, <a href="#mpfit_call_pro_noextra:p:x">x</a></span><span class="argument">, <a href="#mpfit_call_pro_noextra:p:fjac">fjac</a></span><span class="argument">, <a href="#mpfit_call_pro_noextra:k:_EXTRA">_EXTRA</a>=<span class="var">_EXTRA</span></span>)</code></p>

          

          

          
          <h3>Parameters</h3>
            <dl>
              
              <dt id="mpfit_call_pro_noextra:p:fcn">fcn <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit_call_pro_noextra:p:x">x <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit_call_pro_noextra:p:fjac">fjac <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
            </dl>
          

          
          <h3>Keywords</h3>
            <dl>
              
              <dt id="mpfit_call_pro_noextra:k:_EXTRA">_EXTRA <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
            </dl>
          

          

          

          

          

        </div>
        
        <div class="routine-details details" id="mpfit_call_pro_extra">
          <h2 class="routine-name"><a href="#root" class="top">top</a> <a href="mpfit-code.html#mpfit_call_pro_extra:source" class="top">source</a> mpfit_call_pro_extra<span class="routine-attributes"></span></h2>

          

          <p class="syntax"><code><span class="var">result</span> = mpfit_call_pro_extra(<span class="argument"><a href="#mpfit_call_pro_extra:p:fcn">fcn</a></span><span class="argument">, <a href="#mpfit_call_pro_extra:p:x">x</a></span><span class="argument">, <a href="#mpfit_call_pro_extra:p:fjac">fjac</a></span><span class="argument">, <a href="#mpfit_call_pro_extra:k:_EXTRA">_EXTRA</a>=<span class="var">_EXTRA</span></span>)</code></p>

          

          

          
          <h3>Parameters</h3>
            <dl>
              
              <dt id="mpfit_call_pro_extra:p:fcn">fcn <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit_call_pro_extra:p:x">x <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit_call_pro_extra:p:fjac">fjac <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
            </dl>
          

          
          <h3>Keywords</h3>
            <dl>
              
              <dt id="mpfit_call_pro_extra:k:_EXTRA">_EXTRA <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
            </dl>
          

          

          

          

          

        </div>
        
        <div class="routine-details details" id="mpfit_call">
          <h2 class="routine-name"><a href="#root" class="top">top</a> <a href="mpfit-code.html#mpfit_call:source" class="top">source</a> mpfit_call<span class="routine-attributes"></span></h2>

          

          <p class="syntax"><code><span class="var">result</span> = mpfit_call(<span class="argument"><a href="#mpfit_call:p:fcn">fcn</a></span><span class="argument">, <a href="#mpfit_call:p:x">x</a></span><span class="argument">, <a href="#mpfit_call:p:fjac">fjac</a></span><span class="argument">, <a href="#mpfit_call:k:_EXTRA">_EXTRA</a>=<span class="var">_EXTRA</span></span>)</code></p>

          

          

          
          <h3>Parameters</h3>
            <dl>
              
              <dt id="mpfit_call:p:fcn">fcn <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit_call:p:x">x <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit_call:p:fjac">fjac <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
            </dl>
          

          
          <h3>Keywords</h3>
            <dl>
              
              <dt id="mpfit_call:k:_EXTRA">_EXTRA <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
            </dl>
          

          

          

          

          

        </div>
        
        <div class="routine-details details" id="mpfit_fdjac2">
          <h2 class="routine-name"><a href="#root" class="top">top</a> <a href="mpfit-code.html#mpfit_fdjac2:source" class="top">source</a> mpfit_fdjac2<span class="routine-attributes"></span></h2>

          

          <p class="syntax"><code><span class="var">result</span> = mpfit_fdjac2(<span class="argument"><a href="#mpfit_fdjac2:p:fcn">fcn</a></span><span class="argument">, <a href="#mpfit_fdjac2:p:x">x</a></span><span class="argument">, <a href="#mpfit_fdjac2:p:fvec">fvec</a></span><span class="argument">, <a href="#mpfit_fdjac2:p:step">step</a></span><span class="argument">, <a href="#mpfit_fdjac2:p:ulimited">ulimited</a></span><span class="argument">, <a href="#mpfit_fdjac2:p:ulimit">ulimit</a></span><span class="argument">, <a href="#mpfit_fdjac2:p:dside">dside</a></span><span class="argument">, <a href="#mpfit_fdjac2:k:iflag">iflag</a>=<span class="var">iflag</span></span><span class="argument">, <a href="#mpfit_fdjac2:k:epsfcn">epsfcn</a>=<span class="var">epsfcn</span></span><span class="argument">, <a href="#mpfit_fdjac2:k:autoderiv">autoderiv</a>=<span class="var">autoderiv</span></span><span class="argument">, <a href="#mpfit_fdjac2:k:FUNCTARGS">FUNCTARGS</a>=<span class="var">FUNCTARGS</span></span><span class="argument">, <a href="#mpfit_fdjac2:k:xall">xall</a>=<span class="var">xall</span></span><span class="argument">, <a href="#mpfit_fdjac2:k:ifree">ifree</a>=<span class="var">ifree</span></span><span class="argument">, <a href="#mpfit_fdjac2:k:dstep">dstep</a>=<span class="var">dstep</span></span><span class="argument">, <a href="#mpfit_fdjac2:k:deriv_debug">deriv_debug</a>=<span class="var">deriv_debug</span></span><span class="argument">, <a href="#mpfit_fdjac2:k:deriv_reltol">deriv_reltol</a>=<span class="var">deriv_reltol</span></span><span class="argument">, <a href="#mpfit_fdjac2:k:deriv_abstol">deriv_abstol</a>=<span class="var">deriv_abstol</span></span>)</code></p>

          

          

          
          <h3>Parameters</h3>
            <dl>
              
              <dt id="mpfit_fdjac2:p:fcn">fcn <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit_fdjac2:p:x">x <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit_fdjac2:p:fvec">fvec <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit_fdjac2:p:step">step <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit_fdjac2:p:ulimited">ulimited <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit_fdjac2:p:ulimit">ulimit <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit_fdjac2:p:dside">dside <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
            </dl>
          

          
          <h3>Keywords</h3>
            <dl>
              
              <dt id="mpfit_fdjac2:k:iflag">iflag <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit_fdjac2:k:epsfcn">epsfcn <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit_fdjac2:k:autoderiv">autoderiv <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit_fdjac2:k:FUNCTARGS">FUNCTARGS <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit_fdjac2:k:xall">xall <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit_fdjac2:k:ifree">ifree <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit_fdjac2:k:dstep">dstep <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit_fdjac2:k:deriv_debug">deriv_debug <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit_fdjac2:k:deriv_reltol">deriv_reltol <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit_fdjac2:k:deriv_abstol">deriv_abstol <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
            </dl>
          

          

          

          

          

        </div>
        
        <div class="routine-details details" id="mpfit_enorm">
          <h2 class="routine-name"><a href="#root" class="top">top</a> <a href="mpfit-code.html#mpfit_enorm:source" class="top">source</a> mpfit_enorm<span class="routine-attributes"></span></h2>

          

          <p class="syntax"><code><span class="var">result</span> = mpfit_enorm(<span class="argument"><a href="#mpfit_enorm:p:vec">vec</a></span>)</code></p>

          

          

          
          <h3>Parameters</h3>
            <dl>
              
              <dt id="mpfit_enorm:p:vec">vec <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
            </dl>
          

          

          

          

          

          

        </div>
        
        <div class="routine-details details" id="mpfit_qrfac">
          <h2 class="routine-name"><a href="#root" class="top">top</a> <a href="mpfit-code.html#mpfit_qrfac:source" class="top">source</a> mpfit_qrfac<span class="routine-attributes"></span></h2>

          

          <p class="syntax"><code>mpfit_qrfac<span class="argument">, <a href="#mpfit_qrfac:p:a">a</a></span><span class="argument">, <a href="#mpfit_qrfac:p:ipvt">ipvt</a></span><span class="argument">, <a href="#mpfit_qrfac:p:rdiag">rdiag</a></span><span class="argument">, <a href="#mpfit_qrfac:p:acnorm">acnorm</a></span><span class="argument">, <a href="#mpfit_qrfac:k:pivot">pivot</a>=<span class="var">pivot</span></span></code></p>

          

          

          
          <h3>Parameters</h3>
            <dl>
              
              <dt id="mpfit_qrfac:p:a">a <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit_qrfac:p:ipvt">ipvt <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit_qrfac:p:rdiag">rdiag <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit_qrfac:p:acnorm">acnorm <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
            </dl>
          

          
          <h3>Keywords</h3>
            <dl>
              
              <dt id="mpfit_qrfac:k:pivot">pivot <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
            </dl>
          

          

          

          

          

        </div>
        
        <div class="routine-details details" id="mpfit_qrsolv">
          <h2 class="routine-name"><a href="#root" class="top">top</a> <a href="mpfit-code.html#mpfit_qrsolv:source" class="top">source</a> mpfit_qrsolv<span class="routine-attributes"></span></h2>

          

          <p class="syntax"><code>mpfit_qrsolv<span class="argument">, <a href="#mpfit_qrsolv:p:r">r</a></span><span class="argument">, <a href="#mpfit_qrsolv:p:ipvt">ipvt</a></span><span class="argument">, <a href="#mpfit_qrsolv:p:diag">diag</a></span><span class="argument">, <a href="#mpfit_qrsolv:p:qtb">qtb</a></span><span class="argument">, <a href="#mpfit_qrsolv:p:x">x</a></span><span class="argument">, <a href="#mpfit_qrsolv:p:sdiag">sdiag</a></span></code></p>

          

          

          
          <h3>Parameters</h3>
            <dl>
              
              <dt id="mpfit_qrsolv:p:r">r <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit_qrsolv:p:ipvt">ipvt <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit_qrsolv:p:diag">diag <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit_qrsolv:p:qtb">qtb <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit_qrsolv:p:x">x <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit_qrsolv:p:sdiag">sdiag <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
            </dl>
          

          

          

          

          

          

        </div>
        
        <div class="routine-details details" id="mpfit_lmpar">
          <h2 class="routine-name"><a href="#root" class="top">top</a> <a href="mpfit-code.html#mpfit_lmpar:source" class="top">source</a> mpfit_lmpar<span class="routine-attributes"></span></h2>

          

          <p class="syntax"><code><span class="var">result</span> = mpfit_lmpar(<span class="argument"><a href="#mpfit_lmpar:p:r">r</a></span><span class="argument">, <a href="#mpfit_lmpar:p:ipvt">ipvt</a></span><span class="argument">, <a href="#mpfit_lmpar:p:diag">diag</a></span><span class="argument">, <a href="#mpfit_lmpar:p:qtb">qtb</a></span><span class="argument">, <a href="#mpfit_lmpar:p:delta">delta</a></span><span class="argument">, <a href="#mpfit_lmpar:p:x">x</a></span><span class="argument">, <a href="#mpfit_lmpar:p:sdiag">sdiag</a></span><span class="argument">, <a href="#mpfit_lmpar:k:par">par</a>=<span class="var">par</span></span>)</code></p>

          

          

          
          <h3>Parameters</h3>
            <dl>
              
              <dt id="mpfit_lmpar:p:r">r <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit_lmpar:p:ipvt">ipvt <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit_lmpar:p:diag">diag <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit_lmpar:p:qtb">qtb <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit_lmpar:p:delta">delta <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit_lmpar:p:x">x <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit_lmpar:p:sdiag">sdiag <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
            </dl>
          

          
          <h3>Keywords</h3>
            <dl>
              
              <dt id="mpfit_lmpar:k:par">par <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
            </dl>
          

          

          

          

          

        </div>
        
        <div class="routine-details details" id="mpfit_tie">
          <h2 class="routine-name"><a href="#root" class="top">top</a> <a href="mpfit-code.html#mpfit_tie:source" class="top">source</a> mpfit_tie<span class="routine-attributes"></span></h2>

          

          <p class="syntax"><code>mpfit_tie<span class="argument">, <a href="#mpfit_tie:p:p">p</a></span><span class="argument">, <a href="#mpfit_tie:p:_ptied">_ptied</a></span></code></p>

          

          

          
          <h3>Parameters</h3>
            <dl>
              
              <dt id="mpfit_tie:p:p">p <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit_tie:p:_ptied">_ptied <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
            </dl>
          

          

          

          

          

          

        </div>
        
        <div class="routine-details details" id="mpfit_defprint">
          <h2 class="routine-name"><a href="#root" class="top">top</a> <a href="mpfit-code.html#mpfit_defprint:source" class="top">source</a> mpfit_defprint<span class="routine-attributes"></span></h2>

          

          <p class="syntax"><code>mpfit_defprint<span class="argument">, <a href="#mpfit_defprint:p:p1">p1</a></span><span class="argument">, <a href="#mpfit_defprint:p:p2">p2</a></span><span class="argument">, <a href="#mpfit_defprint:p:p3">p3</a></span><span class="argument">, <a href="#mpfit_defprint:p:p4">p4</a></span><span class="argument">, <a href="#mpfit_defprint:p:p5">p5</a></span><span class="argument">, <a href="#mpfit_defprint:p:p6">p6</a></span><span class="argument">, <a href="#mpfit_defprint:p:p7">p7</a></span><span class="argument">, <a href="#mpfit_defprint:p:p8">p8</a></span><span class="argument">, <a href="#mpfit_defprint:p:p9">p9</a></span><span class="argument">, <a href="#mpfit_defprint:p:p10">p10</a></span><span class="argument">, <a href="#mpfit_defprint:p:p11">p11</a></span><span class="argument">, <a href="#mpfit_defprint:p:p12">p12</a></span><span class="argument">, <a href="#mpfit_defprint:p:p13">p13</a></span><span class="argument">, <a href="#mpfit_defprint:p:p14">p14</a></span><span class="argument">, <a href="#mpfit_defprint:p:p15">p15</a></span><span class="argument">, <a href="#mpfit_defprint:p:p16">p16</a></span><span class="argument">, <a href="#mpfit_defprint:p:p17">p17</a></span><span class="argument">, <a href="#mpfit_defprint:p:p18">p18</a></span><span class="argument">, <a href="#mpfit_defprint:k:format">format</a>=<span class="var">format</span></span><span class="argument">, <a href="#mpfit_defprint:k:unit">unit</a>=<span class="var">unit</span></span><span class="argument">, <a href="#mpfit_defprint:k:_EXTRA">_EXTRA</a>=<span class="var">_EXTRA</span></span></code></p>

          

          

          
          <h3>Parameters</h3>
            <dl>
              
              <dt id="mpfit_defprint:p:p1">p1 <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit_defprint:p:p2">p2 <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit_defprint:p:p3">p3 <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit_defprint:p:p4">p4 <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit_defprint:p:p5">p5 <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit_defprint:p:p6">p6 <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit_defprint:p:p7">p7 <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit_defprint:p:p8">p8 <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit_defprint:p:p9">p9 <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit_defprint:p:p10">p10 <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit_defprint:p:p11">p11 <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit_defprint:p:p12">p12 <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit_defprint:p:p13">p13 <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit_defprint:p:p14">p14 <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit_defprint:p:p15">p15 <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit_defprint:p:p16">p16 <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit_defprint:p:p17">p17 <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit_defprint:p:p18">p18 <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
            </dl>
          

          
          <h3>Keywords</h3>
            <dl>
              
              <dt id="mpfit_defprint:k:format">format <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit_defprint:k:unit">unit <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit_defprint:k:_EXTRA">_EXTRA <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
            </dl>
          

          

          

          

          

        </div>
        
        <div class="routine-details details" id="mpfit_defiter">
          <h2 class="routine-name"><a href="#root" class="top">top</a> <a href="mpfit-code.html#mpfit_defiter:source" class="top">source</a> mpfit_defiter<span class="routine-attributes"></span></h2>

          

          <p class="syntax"><code>mpfit_defiter<span class="argument">, <a href="#mpfit_defiter:p:fcn">fcn</a></span><span class="argument">, <a href="#mpfit_defiter:p:x">x</a></span><span class="argument">, <a href="#mpfit_defiter:p:iter">iter</a></span><span class="argument">, <a href="#mpfit_defiter:p:fnorm">fnorm</a></span><span class="argument">, <a href="#mpfit_defiter:k:FUNCTARGS">FUNCTARGS</a>=<span class="var">FUNCTARGS</span></span><span class="argument">, <a href="#mpfit_defiter:k:quiet">quiet</a>=<span class="var">quiet</span></span><span class="argument">, <a href="#mpfit_defiter:k:iterstop">iterstop</a>=<span class="var">iterstop</span></span><span class="argument">, <a href="#mpfit_defiter:k:iterkeybyte">iterkeybyte</a>=<span class="var">iterkeybyte</span></span><span class="argument">, <a href="#mpfit_defiter:k:parinfo">parinfo</a>=<span class="var">parinfo</span></span><span class="argument">, <a href="#mpfit_defiter:k:iterprint">iterprint</a>=<span class="var">iterprint</span></span><span class="argument">, <a href="#mpfit_defiter:k:format">format</a>=<span class="var">format</span></span><span class="argument">, <a href="#mpfit_defiter:k:pformat">pformat</a>=<span class="var">pformat</span></span><span class="argument">, <a href="#mpfit_defiter:k:dof">dof</a>=<span class="var">dof</span></span><span class="argument">, <a href="#mpfit_defiter:k:_EXTRA">_EXTRA</a>=<span class="var">_EXTRA</span></span></code></p>

          

          

          
          <h3>Parameters</h3>
            <dl>
              
              <dt id="mpfit_defiter:p:fcn">fcn <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit_defiter:p:x">x <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit_defiter:p:iter">iter <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit_defiter:p:fnorm">fnorm <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
            </dl>
          

          
          <h3>Keywords</h3>
            <dl>
              
              <dt id="mpfit_defiter:k:FUNCTARGS">FUNCTARGS <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit_defiter:k:quiet">quiet <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit_defiter:k:iterstop">iterstop <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit_defiter:k:iterkeybyte">iterkeybyte <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit_defiter:k:parinfo">parinfo <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit_defiter:k:iterprint">iterprint <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit_defiter:k:format">format <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit_defiter:k:pformat">pformat <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit_defiter:k:dof">dof <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit_defiter:k:_EXTRA">_EXTRA <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
            </dl>
          

          

          

          

          

        </div>
        
        <div class="routine-details details" id="mpfit_parinfo">
          <h2 class="routine-name"><a href="#root" class="top">top</a> <a href="mpfit-code.html#mpfit_parinfo:source" class="top">source</a> mpfit_parinfo<span class="routine-attributes"></span></h2>

          

          <p class="syntax"><code>mpfit_parinfo<span class="argument">, <a href="#mpfit_parinfo:p:parinfo">parinfo</a></span><span class="argument">, <a href="#mpfit_parinfo:p:tnames">tnames</a></span><span class="argument">, <a href="#mpfit_parinfo:p:tag">tag</a></span><span class="argument">, <a href="#mpfit_parinfo:p:values">values</a></span><span class="argument">, <a href="#mpfit_parinfo:k:default">default</a>=<span class="var">default</span></span><span class="argument">, <a href="#mpfit_parinfo:k:status">status</a>=<span class="var">status</span></span><span class="argument">, <a href="#mpfit_parinfo:k:n_param">n_param</a>=<span class="var">n_param</span></span></code></p>

          

          

          
          <h3>Parameters</h3>
            <dl>
              
              <dt id="mpfit_parinfo:p:parinfo">parinfo <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit_parinfo:p:tnames">tnames <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit_parinfo:p:tag">tag <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit_parinfo:p:values">values <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
            </dl>
          

          
          <h3>Keywords</h3>
            <dl>
              
              <dt id="mpfit_parinfo:k:default">default <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit_parinfo:k:status">status <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit_parinfo:k:n_param">n_param <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
            </dl>
          

          

          

          

          

        </div>
        
        <div class="routine-details details" id="mpfit_covar">
          <h2 class="routine-name"><a href="#root" class="top">top</a> <a href="mpfit-code.html#mpfit_covar:source" class="top">source</a> mpfit_covar<span class="routine-attributes"></span></h2>

          

          <p class="syntax"><code><span class="var">result</span> = mpfit_covar(<span class="argument"><a href="#mpfit_covar:p:rr">rr</a></span><span class="argument">, <a href="#mpfit_covar:p:ipvt">ipvt</a></span><span class="argument">, <a href="#mpfit_covar:k:tol">tol</a>=<span class="var">tol</span></span>)</code></p>

          

          

          
          <h3>Parameters</h3>
            <dl>
              
              <dt id="mpfit_covar:p:rr">rr <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit_covar:p:ipvt">ipvt <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
            </dl>
          

          
          <h3>Keywords</h3>
            <dl>
              
              <dt id="mpfit_covar:k:tol">tol <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
            </dl>
          

          

          

          

          

        </div>
        
        <div class="routine-details details" id="mpfit_revision">
          <h2 class="routine-name"><a href="#root" class="top">top</a> <a href="mpfit-code.html#mpfit_revision:source" class="top">source</a> mpfit_revision<span class="routine-attributes"></span></h2>

          

          <p class="syntax"><code><span class="var">result</span> = mpfit_revision()</code></p>

          

          

          

          

          

          

          

          

        </div>
        
        <div class="routine-details details" id="mpfit_parse_version">
          <h2 class="routine-name"><a href="#root" class="top">top</a> <a href="mpfit-code.html#mpfit_parse_version:source" class="top">source</a> mpfit_parse_version<span class="routine-attributes"></span></h2>

          

          <p class="syntax"><code><span class="var">result</span> = mpfit_parse_version(<span class="argument"><a href="#mpfit_parse_version:p:version">version</a></span>)</code></p>

          

          

          
          <h3>Parameters</h3>
            <dl>
              
              <dt id="mpfit_parse_version:p:version">version <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
            </dl>
          

          

          

          

          

          

        </div>
        
        <div class="routine-details details" id="mpfit_min_version">
          <h2 class="routine-name"><a href="#root" class="top">top</a> <a href="mpfit-code.html#mpfit_min_version:source" class="top">source</a> mpfit_min_version<span class="routine-attributes"></span></h2>

          

          <p class="syntax"><code><span class="var">result</span> = mpfit_min_version(<span class="argument"><a href="#mpfit_min_version:p:version">version</a></span><span class="argument">, <a href="#mpfit_min_version:p:min_version">min_version</a></span>)</code></p>

          

          

          
          <h3>Parameters</h3>
            <dl>
              
              <dt id="mpfit_min_version:p:version">version <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit_min_version:p:min_version">min_version <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
            </dl>
          

          

          

          

          

          

        </div>
        
        <div class="routine-details details" id="mpfit">
          <h2 class="routine-name"><a href="#root" class="top">top</a> <a href="mpfit-code.html#mpfit:source" class="top">source</a> mpfit<span class="routine-attributes"></span></h2>

          

          <p class="syntax"><code><span class="var">result</span> = mpfit(<span class="argument"><a href="#mpfit:p:fcn">fcn</a></span><span class="argument">, <a href="#mpfit:p:xall">xall</a></span><span class="argument">, <a href="#mpfit:k:FUNCTARGS">FUNCTARGS</a>=<span class="var">FUNCTARGS</span></span><span class="argument">, <a href="#mpfit:k:SCALE_FCN">SCALE_FCN</a>=<span class="var">SCALE_FCN</span></span><span class="argument">, <a href="#mpfit:k:ftol">ftol</a>=<span class="var">ftol</span></span><span class="argument">, <a href="#mpfit:k:xtol">xtol</a>=<span class="var">xtol</span></span><span class="argument">, <a href="#mpfit:k:gtol">gtol</a>=<span class="var">gtol</span></span><span class="argument">, <a href="#mpfit:k:epsfcn">epsfcn</a>=<span class="var">epsfcn</span></span><span class="argument">, <a href="#mpfit:k:resdamp">resdamp</a>=<span class="var">resdamp</span></span><span class="argument">, <a href="#mpfit:k:nfev">nfev</a>=<span class="var">nfev</span></span><span class="argument">, <a href="#mpfit:k:maxiter">maxiter</a>=<span class="var">maxiter</span></span><span class="argument">, <a href="#mpfit:k:errmsg">errmsg</a>=<span class="var">errmsg</span></span><span class="argument">, <a href="#mpfit:k:factor">factor</a>=<span class="var">factor</span></span><span class="argument">, <a href="#mpfit:k:nprint">nprint</a>=<span class="var">nprint</span></span><span class="argument">, <a href="#mpfit:k:STATUS">STATUS</a>=<span class="var">STATUS</span></span><span class="argument">, <a href="#mpfit:k:iterproc">iterproc</a>=<span class="var">iterproc</span></span><span class="argument">, <a href="#mpfit:k:iterargs">iterargs</a>=<span class="var">iterargs</span></span><span class="argument">, <a href="#mpfit:k:iterstop">iterstop</a>=<span class="var">iterstop</span></span><span class="argument">, <a href="#mpfit:k:iterkeystop">iterkeystop</a>=<span class="var">iterkeystop</span></span><span class="argument">, <a href="#mpfit:k:niter">niter</a>=<span class="var">niter</span></span><span class="argument">, <a href="#mpfit:k:nfree">nfree</a>=<span class="var">nfree</span></span><span class="argument">, <a href="#mpfit:k:npegged">npegged</a>=<span class="var">npegged</span></span><span class="argument">, <a href="#mpfit:k:dof">dof</a>=<span class="var">dof</span></span><span class="argument">, <a href="#mpfit:k:diag">diag</a>=<span class="var">diag</span></span><span class="argument">, <a href="#mpfit:k:rescale">rescale</a>=<span class="var">rescale</span></span><span class="argument">, <a href="#mpfit:k:autoderivative">autoderivative</a>=<span class="var">autoderivative</span></span><span class="argument">, <a href="#mpfit:k:perror">perror</a>=<span class="var">perror</span></span><span class="argument">, <a href="#mpfit:k:covar">covar</a>=<span class="var">covar</span></span><span class="argument">, <a href="#mpfit:k:nocovar">nocovar</a>=<span class="var">nocovar</span></span><span class="argument">, <a href="#mpfit:k:bestnorm">bestnorm</a>=<span class="var">bestnorm</span></span><span class="argument">, <a href="#mpfit:k:parinfo">parinfo</a>=<span class="var">parinfo</span></span><span class="argument">, <a href="#mpfit:k:quiet">quiet</a>=<span class="var">quiet</span></span><span class="argument">, <a href="#mpfit:k:nocatch">nocatch</a>=<span class="var">nocatch</span></span><span class="argument">, <a href="#mpfit:k:fastnorm">fastnorm</a>=<span class="var">fastnorm</span></span><span class="argument">, <a href="#mpfit:k:proc">proc</a>=<span class="var">proc</span></span><span class="argument">, <a href="#mpfit:k:query">query</a>=<span class="var">query</span></span><span class="argument">, <a href="#mpfit:k:external_state">external_state</a>=<span class="var">external_state</span></span><span class="argument">, <a href="#mpfit:k:external_init">external_init</a>=<span class="var">external_init</span></span><span class="argument">, <a href="#mpfit:k:external_fvec">external_fvec</a>=<span class="var">external_fvec</span></span><span class="argument">, <a href="#mpfit:k:external_fjac">external_fjac</a>=<span class="var">external_fjac</span></span><span class="argument">, <a href="#mpfit:k:version">version</a>=<span class="var">version</span></span><span class="argument">, <a href="#mpfit:k:min_version">min_version</a>=<span class="var">min_version</span></span>)</code></p>

          

          

          
          <h3>Parameters</h3>
            <dl>
              
              <dt id="mpfit:p:fcn">fcn <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit:p:xall">xall <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
            </dl>
          

          
          <h3>Keywords</h3>
            <dl>
              
              <dt id="mpfit:k:FUNCTARGS">FUNCTARGS <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit:k:SCALE_FCN">SCALE_FCN <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit:k:ftol">ftol <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit:k:xtol">xtol <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit:k:gtol">gtol <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit:k:epsfcn">epsfcn <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit:k:resdamp">resdamp <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit:k:nfev">nfev <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit:k:maxiter">maxiter <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit:k:errmsg">errmsg <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit:k:factor">factor <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit:k:nprint">nprint <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit:k:STATUS">STATUS <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit:k:iterproc">iterproc <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit:k:iterargs">iterargs <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit:k:iterstop">iterstop <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit:k:iterkeystop">iterkeystop <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit:k:niter">niter <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit:k:nfree">nfree <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit:k:npegged">npegged <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit:k:dof">dof <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit:k:diag">diag <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit:k:rescale">rescale <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit:k:autoderivative">autoderivative <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit:k:perror">perror <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit:k:covar">covar <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit:k:nocovar">nocovar <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit:k:bestnorm">bestnorm <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit:k:parinfo">parinfo <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit:k:quiet">quiet <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit:k:nocatch">nocatch <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit:k:fastnorm">fastnorm <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit:k:proc">proc <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit:k:query">query <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit:k:external_state">external_state <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit:k:external_init">external_init <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit:k:external_fvec">external_fvec <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit:k:external_fjac">external_fjac <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit:k:version">version <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
              <dt id="mpfit:k:min_version">min_version <span class="smaller"></span></dt>
              <dd class="small"></dd>
              
            </dl>
          

          

          

          

          

        </div>
        

      </div>
      

      <div id="attributes">
        <h2>File attributes</h2>

        <table class="attribute small" summary="File attributes">
          <tr>
            <td class="name">Modification date:</td>
            <td>Thu Oct  6 08:56:07 2011</td>
          </tr>

          <tr>
            <td class="name">Lines:</td>
            <td>3,617</td>
          </tr>

          
        </table>
      </div>

      
    </div>

    <div class="footer">
    
      <table class="smaller" summary="footer">
        <tr>
          <td class="left">Produced by IDLdoc 3.5.1 on Thu Jul  4 16:01:48 2013</td>
          <td class="right"><a target="_top" href="http://idldoc.idldev.com">IDLdoc project information</a></td>
        </tr>
      </table>
    
    </div>
  </body>
</html>