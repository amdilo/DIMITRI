<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Tue Jul  2 12:50:45 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>extract_doublets.pro (Documentation for /home/marrabld/projects/DIMITRI_2.0/Source/)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="extract_doublets.pro (Documentation for /home/marrabld/projects/DIMITRI_2.0/Source/)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">;**************************************************************************************</span>
<span class="comments">;**************************************************************************************</span>
<span class="comments">;*</span>
<span class="comments">;* NAME:</span>
<span class="comments">;*      EXTRACT_DOUBLETS       </span>
<span class="comments">;* </span>
<span class="comments">;* PURPOSE:</span>
<span class="comments">;*      EXTRACTS DOUBLET DATA FOR TWO SENSORS AND PROCESSING VERSIONS FOR A </span>
<span class="comments">;*      SPECIFIED REGION. THE DATA IS SAVED AS SAV VARIABLES WITHIN THE DEFINED </span>
<span class="comments">;*      OUTPUT FOLDER.</span>
<span class="comments">;* </span>
<span class="comments">;* CALLING SEQUENCE:</span>
<span class="comments">;*      RES = EXTRACT_DOUBLETS(OUTPUT_FOLDER,ED_REGION,SENSOR1,PROC_VER1,SENSOR2,$</span>
<span class="comments">;*                             PROC_VER2,CHI_THRESHOLD,DAY_OFFSET,CLOUD_PERCENTAGE,$</span>
<span class="comments">;*                             ROI_PERCENTAGE)      </span>
<span class="comments">;* </span>
<span class="comments">;* INPUTS:</span>
<span class="comments">;*      OUTPUT_FOLDER     - THE FULL PATH OF THE OUTPUT FOLDER  </span>
<span class="comments">;*      ED_REGION         - THE VALIDATION SITE NAME E.G. 'Uyuni'</span>
<span class="comments">;*      SENSOR1           - THE NAME OF THE 1ST SENSOR FOR DOUBLET EXTRACTION E.G. 'MERIS'</span>
<span class="comments">;*      PROC_VER1         - THE PROCESSING VERSION OF THE 1ST SENSOR E.G. '2nd_Processing'</span>
<span class="comments">;*      SENSOR2           - THE NAME OF THE 2ND SENSOR FOR DOUBLET EXTRACTION E.G. 'MODISA</span>
<span class="comments">;*      PROC_VER2         - THE PROCESSING VERSION OF THE 2ND SENSOR E.G. 'Collection_5'</span>
<span class="comments">;*      AMC_THRESHOLD     - THE CHI THRESHOLD VALUE AS RETURNED BY COMPUTE_CHI_THRESHOLD.PRO</span>
<span class="comments">;*      DAY_OFFSET        - THE NUMBER OF DAYS DIFFERENCE ALLOWED BETWEEN DOUBLETS E.G 2</span>
<span class="comments">;*      CLOUD_PERCENTAGE  - THE PERCENTAGE CLOUD COVER THRESHOLD ALLOWED WITHIN PRODUCTS E.G. 60.0 </span>
<span class="comments">;*      ROI_PERCENTAGE    - THE PERCENTAGE ROI COVERAGE ALLOWED WITHIN PRODUCTS E.G. 75.0     </span>
<span class="comments">;*      VZA_MIN           - THE MINIMUM VIEWING ZENITH ANGLE ALLOWED FOR AN OBSERVATION</span>
<span class="comments">;*      VZA_MAX           - THE MAXIMUM VIEWING ZENITH ANGLE ALLOWED FOR AN OBSERVATION</span>
<span class="comments">;*      VAA_MIN           - THE MINIMUM VIEWING AZIMUTH ANGLE ALLOWED FOR AN OBSERVATION</span>
<span class="comments">;*      VAA_MAX           - THE MAXIMUM VIEWING AZIMUTH ANGLE ALLOWED FOR AN OBSERVATION</span>
<span class="comments">;*      SZA_MIN           - THE MINIMUM SOLAR ZENITH ANGLE ALLOWED FOR AN OBSERVATION</span>
<span class="comments">;*      SZA_MAX           - THE MAXIMUM SOLAR ZENITH ANGLE ALLOWED FOR AN OBSERVATION</span>
<span class="comments">;*      SAA_MIN           - THE MINIMUM SOLAR AZIMUTH ANGLE ALLOWED FOR AN OBSERVATION</span>
<span class="comments">;*      SAA_MAX           - THE MAXIMUM SOLAR AZIMTUH ANGLE ALLOWED FOR AN OBSERVATION</span>
<span class="comments">;*</span>
<span class="comments">;* KEYWORDS:</span>
<span class="comments">;*      VERBOSE           - PROCESSING STATUS OUTPUTS</span>
<span class="comments">;*      SADE1             - THE FULL PATH NAME OF THE CEOS IVOS SADE DATA FILE FOR REF SENSOR</span>
<span class="comments">;*      SADE2             - THE FULL PATH NAME OF THE CEOS IVOS SADE DATA FILE FOR CAL SENSOR</span>
<span class="comments">;*      SADEOUTPUT        - OUTPUT SADE DATA FILES</span>
<span class="comments">;*</span>
<span class="comments">;* OUTPUTS:</span>
<span class="comments">;*      STATUS            - 1: NO ERRORS REPORTED, (-1) OR 0: ERRORS DURING INGESTION </span>
<span class="comments">;*</span>
<span class="comments">;* COMMON BLOCKS:</span>
<span class="comments">;*      NONE</span>
<span class="comments">;*</span>
<span class="comments">;* MODIFICATION HISTORY:</span>
<span class="comments">;*                    - M BOUVET  - PROTOTYPE DIMITRI VERSION</span>
<span class="comments">;*        14 JAN 2011 - C KENT    - DIMITRI-2 V1.0</span>
<span class="comments">;*        17 JAN 2011 - C KENT 	  - ADDED ADDITIONAL VERBOSE COMMENTS</span>
<span class="comments">;*        18 JAN 2011 - C KENT    - MINOR CHANGES TO ALLOW COMPILATION, ADDED ED_NO_DATA TO </span>
<span class="comments">;*                                  INDICATE IF NO VALUES BELOW CHI THRESHOLD. CHANGED </span>
<span class="comments">;*                                  OUTPUT FOLDER TO OFOLDER, UPDATED OUTPUT LOG FORMAT</span>
<span class="comments">;*        19 JAN 2011 - C KENT    - CHANGED OUTPUT FILENAMES TO INCLUDE THE REGION</span>
<span class="comments">;*        20 JAN 2011 - C KENT    - ADDED SEMICOLON SEPERATED CSV FILE, ADDED DOUBLET_EXTRACTION </span>
<span class="comments">;*                                  OUTPUT FOLDER AND PROCESSINF VERSION TO OUTPUT NAMES</span>
<span class="comments">;*        08 FEB 2011 - C KENT    - ADDED CHI VALUES TO OUTPUT VARIABLE INSTEAD OF GEOTYPE</span>
<span class="comments">;*        22 FEB 2011 - C KENT    - UPDATED ROI PIXEL THRESHOLD TO BE DOUBLE, NOT INTEGER</span>
<span class="comments">;*        21 MAR 2011 - C KENT    - MODIFIED FILE DEFINITION TO USE GET_DIMITRI_LOCATION</span>
<span class="comments">;*        29 MAR 2011 - C KENT    - ADDED STANDARD DEVIATION RESULTS TO OUTPUT CSV AND DATA</span>
<span class="comments">;*        05 MAY 2011 - C KENT    - ADDED JPEG OUTPUT</span>
<span class="comments">;*        30 JUN 2011 - C KENT    - UPDATED CLOUD SCREENING TO CHECK FOR SUSPECT PRODUCTS</span>
<span class="comments">;*        02 JUL 2011 - C KENT    - ADDED ABSOLUTE ANGULAR CRITERIA</span>
<span class="comments">;*        04 JUL 2011 - C KENT    - UPDATED INPUT SAV'S TO INCLUDE AUX INFO</span>
<span class="comments">;*        15 AUG 2011 - C KENT    - CHANGED PIXEL THRESHOLD TO AN INTEGER</span>
<span class="comments">;*        25 AUG 2011 - C KENT    - FIXED BUG IN CHI STORAGE WITHIN OUTPUT ARRAY AND CSV</span>
<span class="comments">;*        16 SEP 2011 - C KENT    - ADDED TIME OUTPUT TO LOG FILE</span>
<span class="comments">;*        19 SEP 2011 - C KENT    - REMOVED MODISA EXCEPTION, ADDED CENTRE WAVELENGTH OUTPUT</span>
<span class="comments">;*        20 SEP 2011 - C KENT    - ADDED AMC OUTPUT TO CSV</span>
<span class="comments">;*        05 OCT 2011 - C KENT    - UPDATED CSV AND SAV ARRAY OUTPUTS</span>
<span class="comments">;*        16 DEC 2011 - C KENT    - ADDED SADE FORMAT OPTIONS FOR CEOS IVOS REFERENCE DATASET</span>
<span class="comments">;*        11 JAN 2012 - C KENT    - UPDATED SADE FILE PROCESSING</span>
<span class="comments">;*        17 JAN 2012 - C KENT    - UPDATED SADE FILE PROCESSING</span>
<span class="comments">;*        08 MAR 2012 - C KENT    - UPDATED DATABASE/SAV FILE TIME MATCHING TO +-20 MINUTES</span>
<span class="comments">;*        09 MAR 2012 - C KENT    - ADDED ROI COVER CHECK</span>
<span class="comments">;*</span>
<span class="comments">;* VALIDATION HISTORY:</span>
<span class="comments">;*        02 DEC 2010 - C KENT    - WINDOWS 32-BIT MACHINE IDL 8.0: COMPILATION SUCCESSFUL. </span>
<span class="comments">;*                                  RESULTS NOMINAL FOR AATSR VS ATSR2 OVER UYUNI IN 2003</span>
<span class="comments">;*        13 APR 2011 - C KENT    - LINUX 64-BIT MACHINE IDL 8.0: COMPILATION AND OPERATION </span>
<span class="comments">;*                                  NOMINAL, TESTED FOR MERIS VS MERIS AND MERIS VS MODIS</span>
<span class="comments">;*</span>
<span class="comments">;**************************************************************************************</span>
<span class="comments">;**************************************************************************************</span>

FUNCTION EXTRACT_DOUBLETS,OFOLDER,ED_REGION,SENSOR1,PROC_VER1,SENSOR2,PROC_VER2,AMC_THRESHOLD,$
                          DAY_OFFSET,CLOUD_PERCENTAGE,ROI_PERCENTAGE,                         $
                          VZA_MIN,VZA_MAX,VAA_MIN,VAA_MAX,SZA_MIN,SZA_MAX,SAA_MIN,SAA_MAX,VERBOSE=VERBOSE,$
                          SADE1=SADE1,SADE2=SADE2,SADEOUTPUT=SADEOUTPUT

<span class="comments">;-----------------------------------------</span>
<span class="comments">; CHECKS OFFSET AND PERCENTAGES ARE OK</span>

  DAY_OFFSET        = FIX(DAY_OFFSET)
  CP_LIMIT          = FLOAT(CLOUD_PERCENTAGE)*.01
  RP_LIMIT          = FLOAT(ROI_PERCENTAGE)*.01
  NUM_NON_REF       = 5+12 <span class="comments">;NUMBER OF VALUES BEFORE REFLECTANCE WITHIN ARRAY</span>

  IF  CP_LIMIT  GT 1.0 OR CP_LIMIT  LT 0.0 OR $
      RP_LIMIT  GT 1.0 OR RP_LIMIT  LT 0.0 THEN BEGIN
    PRINT, 'DOUBLET_EXTRACTION: ERROR, CLOUD/ROI PERCENTAGES OUT OF RANGE'
    RETURN,-1
  ENDIF
  
  IF KEYWORD_SET(VERBOSE) THEN BEGIN
    PRINT,'DOUBLET_EXTRACTION: REGION = ',ED_REGION,' SENSOR1 = ',SENSOR1,' PROC_VER1 = ',PROC_VER1
    PRINT,'DOUBLET_EXTRACTION: REGION = ',ED_REGION,' SENSOR2 = ',SENSOR2,' PROC_VER2 = ',PROC_VER2
    PRINT,'DOUBLET_EXTRACTION: DAY_OFFSET = ',DAY_OFFSET,' CLOUD % = ',CP_LIMIT,' ROI % = ',RP_LIMIT
  ENDIF

<span class="comments">;----------------------------------------- </span>
<span class="comments">; CHECK INPUT SENSORS AND PROC_VERSIONS </span>

  IF STRCMP(SENSOR1,SENSOR2) EQ 1 AND $
     STRCMP(PROC_VER1,PROC_VER2) EQ 1 THEN BEGIN
    PRINT, 'DOUBLET_EXTRACTION: ERROR, TRYING TO COMPARE THE SAME DATA'
    RETURN,0     
  ENDIF
 
<span class="comments">;-----------------------------------------</span>
<span class="comments">; GET THE CURRENT LOCATION AND DEFINE INPUT/OUTPUT FILES</span>

  CFIG_DATA     = GET_DIMITRI_CONFIGURATION()
  DL            = GET_DIMITRI_LOCATION('DL')
  MAIN_DIRC     = GET_DIMITRI_LOCATION('DIMITRI')
  SITE_FILE     = GET_DIMITRI_LOCATION('SITE_DATA')
  DB_FILE       = GET_DIMITRI_LOCATION('DATABASE')

  ED_FOLDER     = STRING(OFOLDER+DL+'DOUBLET_EXTRACTION'+DL)
  ED_LOG        = STRING(ED_FOLDER+DL+'DOUBLET_EXTRACTION_LOG.txt')
  S1_IFILE      = STRING(MAIN_DIRC+'Input'+DL+'Site_'+ED_REGION+DL+SENSOR1+DL+'Proc_'+PROC_VER1+DL+SENSOR1+'_TOA_REF.dat')
  S2_IFILE      = STRING(MAIN_DIRC+'Input'+DL+'Site_'+ED_REGION+DL+SENSOR2+DL+'Proc_'+PROC_VER2+DL+SENSOR2+'_TOA_REF.dat')

  S1_OFILE      = STRING(ED_FOLDER+'ED_'+ED_REGION+'_'+SENSOR1+'_'+PROC_VER1+'_'+SENSOR2+'_'+PROC_VER2+'.dat')
  S2_OFILE      = STRING(ED_FOLDER+'ED_'+ED_REGION+'_'+SENSOR2+'_'+PROC_VER2+'_'+SENSOR1+'_'+PROC_VER1+'.dat')
  CSV_OFILE     = STRING(OFOLDER+DL+'ED_'+ED_REGION+'_'+SENSOR1+'_'+PROC_VER1+'_'+SENSOR2+'_'+PROC_VER2+'.csv')

  OUT_PLOT_REF  = STRING(ED_FOLDER+'ED_'+ED_REGION+'_'+SENSOR1+'_'+PROC_VER1+'_'+SENSOR2+'_'+PROC_VER2+'.jpg')
  OUT_PLOT_CAL  = STRING(ED_FOLDER+'ED_'+ED_REGION+'_'+SENSOR2+'_'+PROC_VER2+'_'+SENSOR1+'_'+PROC_VER1+'.jpg')

<span class="comments">;--------------------------------</span>
<span class="comments">; CREATE DOUBLET EXTRACTION FOLDER IF IT DOESN'T EXIST</span>

  RES = FILE_INFO(ED_FOLDER)
  IF RES.EXISTS NE 1 OR RES.DIRECTORY NE 1 THEN BEGIN
    IF KEYWORD_SET(VERBOSE) THEN PRINT,"DIMITRI INTERFACE DOUBLET: DOUBLET FOLDER DOESN'T EXIST, CREATING"
    FILE_MKDIR,ED_FOLDER 
  ENDIF

<span class="comments">;-----------------------------------------</span>
<span class="comments">; DEFINE SENSOR AND PROC_VERSION ARRAYS</span>

  SENS = [SENSOR1,SENSOR2]
  PVER = [PROC_VER1,PROC_VER2]

  IF KEYWORD_SET(SADE1) OR KEYWORD_SET(SADE2) THEN GOTO, ED_SADE_IN

<span class="comments">;-----------------------------------------</span>
<span class="comments">; COMPUTE ROI AREA IN KM^2</span>

  ICOORDS = GET_SITE_COORDINATES(ED_REGION,SITE_FILE,VERBOSE=VERBOSE)
  
  IF ICOORDS[0] EQ -1 THEN BEGIN
    PRINT,'DOUBLET_EXTRACTION: ERROR, REGION COORDINATES NOT FOUND'
    RETURN,-1
  ENDIF
  
  ROI_X     = GREAT_CIRCLE_DISTANCE(ICOORDS[0],ICOORDS[2],ICOORDS[0],ICOORDS[3],/DEGREES)
  ROI_Y     = GREAT_CIRCLE_DISTANCE(ICOORDS[0],ICOORDS[2],ICOORDS[1],ICOORDS[2],/DEGREES)
  ROI_AREA  = FLOAT(ROI_X)*FLOAT(ROI_Y)
  IF KEYWORD_SET(VERBOSE) THEN PRINT,'DOUBLET_EXTRACTION: COMPUTED ROI AREA = ',ROI_AREA

<span class="comments">;-----------------------------------------</span>
<span class="comments">; GET PIXEL AREA RESOLUTIONS OF SENSORS</span>

  SPX_AREA    = MAKE_ARRAY(2,/FLOAT)
  SPX_AREA[0] = SENSOR_PIXEL_SIZE(SENSOR1,/AREA,VERBOSE=VERBOSE)
  SPX_AREA[1] = SENSOR_PIXEL_SIZE(SENSOR2,/AREA,VERBOSE=VERBOSE)

<span class="comments">;-----------------------------------------</span>
<span class="comments">; DEFINE ROI PIX THRESHOLD FOR EACH SENSOR</span>

  PX_THRESH     = MAKE_ARRAY(2,/INTEGER)
  PX_THRESH[0]  = FLOOR(DOUBLE(RP_LIMIT*ROI_AREA)/DOUBLE(SPX_AREA[0]))
  PX_THRESH[1]  = FLOOR(DOUBLE(RP_LIMIT*ROI_AREA)/DOUBLE(SPX_AREA[1]))
  IF KEYWORD_SET(VERBOSE) THEN PRINT,'DOUBLET_EXTRACTION: COMPUTED PX_THRESHOLDS = ',PX_THRESH

<span class="comments">;-----------------------------------------</span>
<span class="comments">; ROICOVERAGE CHECK</span>

  IF RP_LIMIT GE 1.0 THEN BEGIN
    ROICOVER = 1
    PX_THRESH[*] = 1  
  ENDIF ELSE ROICOVER = 0
  
<span class="comments">;-----------------------------------------</span>
<span class="comments">; RECORD THIS PROCESSING REQUEST IN A LOG</span>

  TMP_DATE = SYSTIME()
  TMP_DATE = STRING(STRMID(TMP_DATE,8,2)+'-'+STRMID(TMP_DATE,4,3)+'-'+STRMID(TMP_DATE,20,4)+' '+strmid(tmp_date,11,8))
  TEMP = FILE_INFO(ED_LOG)
  IF TEMP.EXISTS EQ 0 THEN BEGIN
    OPENW, DLOG,ED_LOG,/GET_LUN
    PRINTF,DLOG,'DATE;REGION;SENSOR1;PROC_VER1;SENSOR2;PROC_VER2;AMC_THRESHOLD;DAY_OFFSET_LIMIT;CLOUD_PERCENTAGE;ROI_PERCENTAGE'
  ENDIF ELSE OPENW,DLOG,ED_LOG,/GET_LUN,/APPEND

  PRINTF,DLOG,FORMAT='(6(A,1H;),1(F6.3,1H;),1(I3,1H;),1(F6.3,1H;),1(F6.3))',$
  TMP_DATE,ED_REGION,SENSOR1,PROC_VER1,SENSOR2,PROC_VER2,AMC_THRESHOLD,DAY_OFFSET,CP_LIMIT,RP_LIMIT

<span class="comments">;----------------------------------------</span>
<span class="comments">; CLOSE LOG AND RELEASE THE LUN</span>

  FREE_LUN,DLOG

<span class="comments">;----------------------------------------</span>
<span class="comments">; READ THE DIMITRI DATABASE</span>

  TEMP = FILE_INFO(DB_FILE)
  IF TEMP.EXISTS EQ 0 THEN BEGIN
    PRINT, 'DOUBLET_EXTRACTION: ERROR, DIMITRI DATABASE FILE DOES NOT EXIST'
    RETURN,-1
  ENDIF
  
  IF KEYWORD_SET(VERBOSE) THEN PRINT,'DOUBLET_EXTRACTION: READING DIMITRI DATABASE'
  DB_TEMPLATE = GET_DIMITRI_TEMPLATE(1,/TEMPLATE)
  DB_DATA     = READ_ASCII(DB_FILE,TEMPLATE=DB_TEMPLATE)

  
<span class="comments">;----------------------------------------</span>
<span class="comments">; RESTORE THE SENSOR TOA DATA</span>

  RESTORE,S1_IFILE
  S1_ADATA = SENSOR_L1B_REF
  RESTORE,S2_IFILE
  S2_ADATA = SENSOR_L1B_REF 
  SENSOR_L1B_REF=0

<span class="comments">;----------------------------------------</span>
<span class="comments">; LOOP OVER BOTH SENSORS TO EXTRACT DATA </span>
<span class="comments">; WITHIN CLOUD/ROI PARAMETERS</span>

  IF KEYWORD_SET(VERBOSE) THEN PRINT,'DOUBLET_EXTRACTION: STARTING LOOP OVER BOTH SENSORS DATA'
  FOR EDS = 0,1 DO BEGIN
  
<span class="comments">;----------------------------------------  </span>
<span class="comments">; SET ALL DATA VARIABLE  </span>
  
    IF EDS EQ 0 THEN SENSOR_ALL_DATA = S1_ADATA
    IF EDS EQ 1 THEN SENSOR_ALL_DATA = S2_ADATA
  
    RES = WHERE(STRCMP(DB_DATA.REGION,ED_REGION)             EQ 1 AND $
                STRCMP(DB_DATA.SENSOR,SENS[EDS])             EQ 1 AND $
                STRCMP(DB_DATA.PROCESSING_VERSION,PVER[EDS]) EQ 1 AND $
                DB_DATA.ROI_COVER  GE ROICOVER                    AND $
                DB_DATA.NUM_ROI_PX GE PX_THRESH[EDS])            

    IF RES[0] EQ -1 THEN BEGIN
      PRINT, 'DOUBLET_EXTRACTION: ERROR, NO SENSOR DATA FOUND WITHIN PIXEL THRESHOLD'  
      RETURN,0
    ENDIF

<span class="comments">;----------------------------------------</span>
<span class="comments">; GET A LIST OF DATES IN WHICH DATA IS ALSO </span>
<span class="comments">; WITHIN THE CLOUD PERCENTAGE </span>

    GD_DATE = 0.0
    GD_PIX = LONG(0.0)
    GD_MAN = 0
    GD_AUT = 0.
    GD_NAME = ''
        
    IF KEYWORD_SET(VERBOSE) THEN PRINT,'DOUBLET_EXTRACTION: STARTING LOOP OVER GOOD DATES FOR CLOUD PERCENTAGE'  
    FOR I_CS=0l,N_ELEMENTS(RES)-1 DO BEGIN
    
      IF DB_DATA.MANUAL_CS[RES[I_CS]] GE 1.0 THEN CONTINUE
      IF (DB_DATA.MANUAL_CS[RES[I_CS]] EQ 0.0) OR $
        (DB_DATA.AUTO_CS[RES[I_CS]] LE CP_LIMIT AND DB_DATA.AUTO_CS[RES[I_CS]] GT -1.0) THEN BEGIN
        GD_DATE = [GD_DATE,DB_DATA.DECIMAL_YEAR[RES[I_CS]]]
        GD_PIX = [GD_PIX,DB_DATA.NUM_ROI_PX[RES[I_CS]]]
        GD_MAN = [GD_MAN,DB_DATA.MANUAL_CS[RES[I_CS]]]
        GD_AUT = [GD_AUT,DB_DATA.AUTO_CS[RES[I_CS]]]
        GD_NAME= [GD_NAME,DB_DATA.FILENAME[RES[I_CS]]]
        CONTINUE
      ENDIF  
    
    ENDFOR<span class="comments">;END OF LOOP ON GOOD DATES</span>

    IF N_ELEMENTS(GD_DATE) EQ 1 THEN BEGIN
       PRINT, 'DOUBLET_EXTRACTION: ERROR, NO SENSOR DATA FOUND WITHIN CLOUD THRESHOLD'
       RETURN,0
    ENDIF

<span class="comments">;---------------------------------------</span>
<span class="comments">; EXTRACT GOOD DECIMAL DATES AND CORRESPONDING </span>
<span class="comments">; INDEX IN ALL DATA VARIABLE    </span>
  
    GD_DATE = GD_DATE[1:N_ELEMENTS(GD_DATE)-1]
    GD_PIX  = GD_PIX[1:N_ELEMENTS(GD_PIX)-1]
    GD_MAN  = GD_MAN[1:N_ELEMENTS(GD_MAN)-1]
    GD_AUT  = GD_AUT[1:N_ELEMENTS(GD_AUT)-1]
    GD_NAME = GD_NAME[1:N_ELEMENTS(GD_NAME)-1]
    
    GD_IDX = MAKE_ARRAY(N_ELEMENTS(SENSOR_ALL_DATA[0,*]),/INTEGER,VALUE=0)
    GD_AUX = MAKE_ARRAY(N_ELEMENTS(SENSOR_ALL_DATA[0,*]),3,/LONG,VALUE=-1.)
    GD_PRD = MAKE_ARRAY(N_ELEMENTS(SENSOR_ALL_DATA[0,*]),/string,VALUE='')
    TOL=0.00005
    FOR GD=0l,N_ELEMENTS(GD_DATE)-1 DO BEGIN
      RES = WHERE(ABS(SENSOR_ALL_DATA[0,*]-GD_DATE[GD]) LE TOL AND $
                  SENSOR_ALL_DATA[NUM_NON_REF,*] GT 0.0        AND $
                  SENSOR_ALL_DATA[NUM_NON_REF,*] LT 5.0        AND $
                  SENSOR_ALL_DATA[1,*] GT VZA_MIN              AND $
                  SENSOR_ALL_DATA[1,*] LT VZA_MAX              AND $
                  SENSOR_ALL_DATA[2,*] GT VAA_MIN              AND $
                  SENSOR_ALL_DATA[2,*] LT VAA_MAX              AND $                
                  SENSOR_ALL_DATA[3,*] GT SZA_MIN              AND $
                  SENSOR_ALL_DATA[3,*] LT SZA_MAX              AND $
                  SENSOR_ALL_DATA[4,*] GT SAA_MIN              AND $
                  SENSOR_ALL_DATA[4,*] LT SAA_MAX              )                  
                  
      IF RES[0] GT -1 THEN begin
      GD_IDX[RES]=1
      GD_AUX[RES,0]=GD_PIX[GD]
      GD_AUX[RES,1]=GD_AUT[GD]
      GD_AUX[RES,2]=GD_MAN[GD] 
      GD_PRD[RES] = GD_NAME[GD]    
      ENDIF
    ENDFOR <span class="comments">;END OF LOOP ON GOOD DATES TO FIND INDEX IN ALL_DATA ARRAY</span>

<span class="comments">;---------------------------------------</span>
<span class="comments">; DEFINE FINAL VARIABLES WHICH CONTAIN THE </span>
<span class="comments">; ACCEPTABLE DATA</span>

    RES = WHERE(GD_IDX EQ 1)
    IF RES[0] GT -1 THEN BEGIN
      IF EDS EQ 0 THEN BEGIN
        GD_SENSOR1_DATA = SENSOR_ALL_DATA[*,RES]
        GD_AUX1 = GD_AUX[RES,*]
        GD_PRD1 = GD_PRD[RES]
      ENDIF
      IF EDS EQ 1 THEN BEGIN
        GD_SENSOR2_DATA = SENSOR_ALL_DATA[*,RES]
        GD_AUX2 = GD_AUX[RES,*]
        GD_PRD2 = GD_PRD[RES]
      endif
    ENDIF ELSE BEGIN
      PRINT, 'DOUBLET_EXTRACTION: ERROR DURING DOUBLET EXTRACTION, NO GOOD DATES FOUND FOR SENSOR ',SENS[EDS]
      RETURN,0
    ENDELSE
  ENDFOR <span class="comments">;END OF LOOP ON SENSOR1 AND SENSOR2 FILTERING</span>
  IF KEYWORD_SET(VERBOSE) THEN PRINT,'DOUBLET_EXTRACTION: COMPLETED LOOP ON GOOD DATES FOR CLOUD TESTING'

<span class="comments">;---------------------------------------</span>
<span class="comments">; GET SIZE OF GOOD DATASETS</span>
  
  SIZE_S1=SIZE(GD_SENSOR1_DATA)
  SIZE_S2=SIZE(GD_SENSOR2_DATA)

<span class="comments">;---------------------------------------</span>
<span class="comments">; DEFINE THE NUMBER OF BANDS AND OUTPUT VARIABLES </span>

  IF KEYWORD_SET(VERBOSE) THEN PRINT,'DOUBLET_EXTRACTION: DEFINING PARAMETERS AND OUTPUT ARRAYS'
<span class="comments">;  NUM_NON_REF         = 5+12 ;NUMBER OF VALUES BEFORE REFLECTANCE WITHIN ARRAY</span>
  NUM_BANDS1          = (SIZE_S1[1]-NUM_NON_REF)/2
  NUM_BANDS2          = (SIZE_S2[1]-NUM_NON_REF)/2
<span class="comments">;  ED_SENSOR1_SENSOR2  = DBLARR(2*NUM_BANDS1+NUM_NON_REF+5,SIZE_S1[2]);CHI,GEOTYPE,PIX,AUTO,MAN=5</span>
<span class="comments">;  ED_SENSOR2_SENSOR1  = DBLARR(2*NUM_BANDS2+NUM_NON_REF+5,SIZE_S1[2])</span>
  
  ED_SADE_IN:
  
<span class="comments">;---------------------------------------  </span>
<span class="comments">; TEMP CODE TO GENERATE SADE ASCII FILES  </span>

IF KEYWORD_SET(SADEOUTPUT) THEN BEGIN

<span class="comments">;---------------------------------------</span>
<span class="comments">; REMOVE CLOUDY PRODUCTS</span>

  TOL = 0.015 <span class="comments">;1.5% </span>
  RES = WHERE(GD_SENSOR1_DATA[NUM_NON_REF+NUM_BANDS1,*] LT TOL)
    GD_AUX1 = GD_AUX1[RES,0]
    GD_SENSOR1_DATA = GD_SENSOR1_DATA[*,RES]
    GD_PRD1 = GD_PRD1[RES]
  RES = WHERE(GD_SENSOR2_DATA[NUM_NON_REF+NUM_BANDS2,*] LT TOL)
    GD_AUX2 = GD_AUX2[RES,0]
    GD_SENSOR2_DATA = GD_SENSOR2_DATA[*,RES]
    GD_PRD2 = GD_PRD2[RES]
    
<span class="comments">;---------------------------------------  </span>
<span class="comments">; LIMIT TO 2006,2007,2008 AND 2009</span>
    
    MINT = 2006.
    MAXT = 2011.
  
    IDX = WHERE(GD_SENSOR1_DATA[0,*] GT MINT AND GD_SENSOR1_DATA[0,*] LT MAXT)
      GD_AUX1 = GD_AUX1[IDX,0]
      GD_SENSOR1_DATA = GD_SENSOR1_DATA[*,IDX]
      GD_PRD1 = GD_PRD1[IDX]
    IDX = WHERE(GD_SENSOR2_DATA[0,*] GT MINT AND GD_SENSOR2_DATA[0,*] LT MAXT)
      GD_AUX2 = GD_AUX2[IDX,0]
      GD_SENSOR2_DATA = GD_SENSOR2_DATA[*,IDX]
      GD_PRD2 = GD_PRD2[IDX]
  
    NPIXS1 = REFORM(GD_AUX1[*,0],N_ELEMENTS(GD_AUX1[*,0]))
    NPIXS2 = REFORM(GD_AUX2[*,0],N_ELEMENTS(GD_AUX2[*,0]))
    SENSOR_DATA1 = GD_SENSOR1_DATA
    SENSOR_DATA2 = GD_SENSOR2_DATA
    BIDX1 = INDGEN(NUM_BANDS1)
    BIDX2 = INDGEN(NUM_BANDS2)
    IF SENSOR1 EQ 'MODISA' THEN BIDX1 = [0,1,15,2,16,20,21,17,18,19]
    IF SENSOR2 EQ 'MODISA' THEN BIDX2 = [0,1,15,2,16,20,21,17,18,19]
    PFLAG1=0
    PFLAG2=0
    IF SENSOR1 EQ 'PARASOL' THEN PFLAG1=1
    IF SENSOR2 EQ 'PARASOL' THEN PFLAG2=1  
   
    CONVERT_TIMESERIES_TO_SADE,SENSOR1,PROC_VER1,SENSOR_DATA1,NPIXS1,BIDX1,ED_REGION,GD_PRD1,PFLAG1
    CONVERT_TIMESERIES_TO_SADE,SENSOR2,PROC_VER2,SENSOR_DATA2,NPIXS2,BIDX2,ED_REGION,GD_PRD2,PFLAG2
<span class="comments">;---------------------------------------     </span>

ENDIF <span class="comments">;END OF SADE OUTPUT</span>

IF KEYWORD_SET(SADE1) THEN BEGIN
<span class="comments">;---------------------------------------  </span>
<span class="comments">; LOAD THE SADE DATA</span>
  
  SENSOR_TOA_REF = CONVERT_SADE_TO_DIMITRI(SADE1,SENSOR1)
<span class="comments">;  TEMP = STRSPLIT(SADE1,'_'+dl,/EXTRACT)</span>
<span class="comments">;  IF TEMP[N_ELEMENTS(TEMP)-4] EQ 'CNES' OR TEMP[N_ELEMENTS(TEMP)-4] EQ 'Niger2' THEN SFLG=1 ELSE SFLG=0</span>

<span class="comments">;;---------------------------------------  </span>
<span class="comments">;; GET THE AUX AND PRDNAMES INFO</span>
<span class="comments">;  </span>
<span class="comments">;  NEWAUX = MAKE_ARRAY(N_ELEMENTS(SENSOR_TOA_REF[0,*]),3,/LONG,VALUE=-1.)</span>
<span class="comments">;  IF NOT SFLG THEN BEGIN</span>
<span class="comments">;    FOR IAUX = 0L,N_ELEMENTS(SENSOR_TOA_REF[0,*])-1 DO BEGIN</span>
<span class="comments">;      RES = WHERE(ABS(GD_SENSOR1_DATA[0,*]-SENSOR_TOA_REF[0,IAUX]) LT 0.000001 AND $</span>
<span class="comments">;                  ABS(GD_SENSOR1_DATA[1,*]-SENSOR_TOA_REF[1,IAUX]) LT 0.001,COUNT)</span>
<span class="comments">;      IF COUNT GT 0 THEN NEWAUX[IAUX,*] = GD_AUX1[RES[0],*] ELSE SENSOR_TOA_REF[0,IAUX]=-999.</span>
<span class="comments">;    ENDFOR</span>
<span class="comments">;  ENDIF</span>

  RES = WHERE(SENSOR_TOA_REF[1,*] GT VZA_MIN              AND $
              SENSOR_TOA_REF[1,*] LT VZA_MAX              AND $
              SENSOR_TOA_REF[2,*] GT VAA_MIN              AND $
              SENSOR_TOA_REF[2,*] LT VAA_MAX              AND $                
              SENSOR_TOA_REF[3,*] GT SZA_MIN              AND $
              SENSOR_TOA_REF[3,*] LT SZA_MAX              AND $
              SENSOR_TOA_REF[4,*] GT SAA_MIN              AND $
              SENSOR_TOA_REF[4,*] LT SAA_MAX              ,COUNT)
  IF COUNT GT 0 THEN SENSOR_TOA_REF=SENSOR_TOA_REF[*,RES]
  NEWAUX = MAKE_ARRAY(N_ELEMENTS(SENSOR_TOA_REF[0,*]),3,/LONG,VALUE=-999.)

<span class="comments">;---------------------------------------  </span>
<span class="comments">; OVER WRITE THE SENSOR DATA</span>

  IDX = WHERE(SENSOR_TOA_REF[0,*] GT 0.)
  IF N_ELEMENTS(IDX) LT 2 THEN BEGIN
    PRINT,'ERROR NO MATCHING SADE DATA FOR ANGLE CRITERA'
    RETURN,-3
  ENDIF
  GD_SENSOR1_DATA = SENSOR_TOA_REF[*,idx] &  GD_AUX1 = NEWAUX[idx,*]
  SENSOR_TOA_REF = 0 & NEWAUX = 0
ENDIF

IF KEYWORD_SET(SADE2) THEN BEGIN
<span class="comments">;---------------------------------------  </span>
<span class="comments">; LOAD THE SADE DATA</span>
  
  SENSOR_TOA_REF = CONVERT_SADE_TO_DIMITRI(SADE2,SENSOR2)
  RES = WHERE(SENSOR_TOA_REF[1,*] GT VZA_MIN              AND $
              SENSOR_TOA_REF[1,*] LT VZA_MAX              AND $
              SENSOR_TOA_REF[2,*] GT VAA_MIN              AND $
              SENSOR_TOA_REF[2,*] LT VAA_MAX              AND $                
              SENSOR_TOA_REF[3,*] GT SZA_MIN              AND $
              SENSOR_TOA_REF[3,*] LT SZA_MAX              AND $
              SENSOR_TOA_REF[4,*] GT SAA_MIN              AND $
              SENSOR_TOA_REF[4,*] LT SAA_MAX              ,COUNT)
  IF COUNT GT 0 THEN SENSOR_TOA_REF=SENSOR_TOA_REF[*,RES]
  NEWAUX = MAKE_ARRAY(N_ELEMENTS(SENSOR_TOA_REF[0,*]),3,/LONG,VALUE=-999.)

<span class="comments">;---------------------------------------  </span>
<span class="comments">; OVER WRITE THE SENSOR DATA</span>
  
  IDX = WHERE(SENSOR_TOA_REF[0,*] GT 0.)
  IF N_ELEMENTS(IDX) LT 2 THEN BEGIN
    PRINT,'ERROR NO MATCHING SADE DATA FOR ANGLE CRITERA'
    RETURN,-3
  ENDIF
  GD_SENSOR2_DATA = SENSOR_TOA_REF[*,idx] &  GD_AUX2 = NEWAUX[idx,*]
  SENSOR_TOA_REF = 0 & NEWAUX = 0
ENDIF

<span class="comments">;---------------------------------------</span>
<span class="comments">; GET SIZE OF NEW GOOD DATASETS</span>
  
  SIZE_S1=SIZE(GD_SENSOR1_DATA)
  SIZE_S2=SIZE(GD_SENSOR2_DATA)
  NUM_BANDS1          = (SIZE_S1[1]-NUM_NON_REF)/2
  NUM_BANDS2          = (SIZE_S2[1]-NUM_NON_REF)/2
  ED_SENSOR1_SENSOR2  = DBLARR(2*NUM_BANDS1+NUM_NON_REF+5,SIZE_S1[2])<span class="comments">;CHI,GEOTYPE,PIX,AUTO,MAN=5</span>
  ED_SENSOR2_SENSOR1  = DBLARR(2*NUM_BANDS2+NUM_NON_REF+5,SIZE_S1[2])

<span class="comments">;---------------------------------------</span>
<span class="comments">; LOOP OVER EACH DAY RECORD IN SENSOR1 </span>
<span class="comments">; AND FIND MATCHES</span>

  ED_NO_DATA = 0
  IF KEYWORD_SET(VERBOSE) THEN PRINT,'DOUBLET_EXTRACTION: STARTING LOOP OVER EACH GOOD DAY IN SENSOR1'
  FOR I_DAY=0L,SIZE_S1[2]-1 DO BEGIN
  IF KEYWORD_SET(VERBOSE) THEN PRINT,'DOUBLET_EXTRACTION: COMPUTING FOR DAY ITERATION = ',I_DAY

<span class="comments">;---------------------------------------</span>
<span class="comments">; COMPUTE DAY_OFFSET PARAMETER</span>

    CURRENT_DAY=GD_SENSOR1_DATA[0,I_DAY]
    TEMP = FLOAT(FLOOR(CURRENT_DAY))
    IF (TEMP MOD 4) EQ 0 THEN DD=1./366.0 ELSE DD=1./365.0
    DD = DD*DAY_OFFSET

<span class="comments">;---------------------------------------</span>
<span class="comments">; FIND THE NUMBER OF MATCHING DAYS AND </span>
<span class="comments">; THEIR INDEX IN THE DATA </span>

    ID_MATCH_DAY = WHERE(ABS(GD_SENSOR2_DATA[0,*]-CURRENT_DAY) LE DD)
    IF ID_MATCH_DAY[0] EQ -1 THEN GOTO,NEXT_DAY
    NB_MATCHING_DATES=N_ELEMENTS(ID_MATCH_DAY)

<span class="comments">;---------------------------------------  </span>
<span class="comments">; DEFINE VARIABLES TO HOLD THE CHI VALUES</span>
    
    AMC_IDENT = FLTARR(NB_MATCHING_DATES)
    AMC_RECI  = FLTARR(NB_MATCHING_DATES)

<span class="comments">;---------------------------------------  </span>
<span class="comments">; RETRIEVE CHI VALUES FOR MATCHING DATES</span>
    
    FOR I_MATCH=0, NB_MATCHING_DATES-1 DO BEGIN
    
<span class="comments">;-------------------------------</span>
<span class="comments">; SORT OUT RAA ANGLES</span>

      AMC_IDENT[I_MATCH]= COMPUTE_AMC(GD_SENSOR1_DATA[3,I_DAY],$
                                      GD_SENSOR1_DATA[1,I_DAY],$
                                      GD_SENSOR1_DATA[2,I_DAY]-GD_SENSOR1_DATA[4,I_DAY],$
                                      GD_SENSOR2_DATA[3,ID_MATCH_DAY[I_MATCH]],$
                                      GD_SENSOR2_DATA[1,ID_MATCH_DAY[I_MATCH]],$
                                      GD_SENSOR2_DATA[2,ID_MATCH_DAY[I_MATCH]]-GD_SENSOR2_DATA[4,ID_MATCH_DAY[I_MATCH]])

      AMC_RECI[I_MATCH] = COMPUTE_AMC(GD_SENSOR1_DATA[3,I_DAY],$
                                      GD_SENSOR1_DATA[1,I_DAY],$
                                      GD_SENSOR1_DATA[2,I_DAY]-GD_SENSOR1_DATA[4,I_DAY],$
                                      GD_SENSOR2_DATA[1,ID_MATCH_DAY[I_MATCH]],$<span class="comments">;THESE ARE THE VALUES CHANGED FOR RECIPROCAL ANALYSIS</span>
                                      GD_SENSOR2_DATA[3,ID_MATCH_DAY[I_MATCH]],$<span class="comments">;THESE ARE THE VALUES CHANGED FOR RECIPROCAL ANALYSIS</span>
                                      GD_SENSOR2_DATA[2,ID_MATCH_DAY[I_MATCH]]-GD_SENSOR2_DATA[4,ID_MATCH_DAY[I_MATCH]])
  
    ENDFOR<span class="comments">;END OF LOOP ON AMC COMPUTATION </span>

<span class="comments">;---------------------------------------</span>
<span class="comments">; RETAIN ONLY THE BEST ANGULAR MATCH IF </span>
<span class="comments">; THERE ARE SEVERAL MATCHES</span>
    
    MIN_AMC_IDENT = MIN(AMC_IDENT, I_MATCH_IDENT)
    MIN_AMC_RECI  = MIN(AMC_RECI,  I_MATCH_RECI )

    IF MIN_AMC_IDENT LE MIN_AMC_RECI THEN BEGIN
      AMC=MIN_AMC_IDENT
      I_MATCH=I_MATCH_IDENT
      GEO_TYPE=1
    ENDIF ELSE BEGIN
      AMC=MIN_AMC_RECI
      I_MATCH=I_MATCH_RECI
      GEO_TYPE=-1
    ENDELSE

<span class="comments">;---------------------------------------</span>
<span class="comments">; ONLY STORE THE DATA IF CHI IS BELOW </span>
<span class="comments">; THRESHOLD VALUE, ED=Extracted Doublet</span>

    IF AMC LT AMC_THRESHOLD THEN BEGIN <span class="comments">;5 FOR ANGLES AND TIME, 12 FOR AUX DATA, NUM BANDS * 2 PLUS CHI,geotype,pix,auto,man</span>
        TT = 2*NUM_BANDS1+NUM_NON_REF
        ED_SENSOR1_SENSOR2[0:TT-1,I_DAY]  = GD_SENSOR1_DATA[0:TT-1,I_DAY]       
        ED_SENSOR1_SENSOR2[TT+0,I_DAY] = GD_AUX1[I_DAY,0]
        ED_SENSOR1_SENSOR2[TT+1,I_DAY] = GD_AUX1[I_DAY,1]
        ED_SENSOR1_SENSOR2[TT+2,I_DAY] = GD_AUX1[I_DAY,2]
        ED_SENSOR1_SENSOR2[TT+3,I_DAY] = GEO_TYPE
        ED_SENSOR1_SENSOR2[TT+4,I_DAY] = AMC
 
        TT = 2*NUM_BANDS2+NUM_NON_REF
        ED_SENSOR2_SENSOR1[0:TT-1,I_DAY]  = GD_SENSOR2_DATA[0:TT-1,ID_MATCH_DAY[I_MATCH]]       
        ED_SENSOR2_SENSOR1[TT+0,I_DAY] = GD_AUX2[ID_MATCH_DAY[I_MATCH],0]
        ED_SENSOR2_SENSOR1[TT+1,I_DAY] = GD_AUX2[ID_MATCH_DAY[I_MATCH],1]
        ED_SENSOR2_SENSOR1[TT+2,I_DAY] = GD_AUX2[ID_MATCH_DAY[I_MATCH],2]
        ED_SENSOR2_SENSOR1[TT+3,I_DAY] = GEO_TYPE
        ED_SENSOR2_SENSOR1[TT+4,I_DAY] = AMC
              
        ED_NO_DATA = 1
    ENDIF
    NEXT_DAY: <span class="comments">;IF NO MATCH WITHIN DAY_OFFSET</span>

  ENDFOR <span class="comments">;END OF LOOP ON SENSOR1 DECIMAL DATE (DAYS)</span>

  IF ED_NO_DATA EQ 0 THEN BEGIN
    PRINT,'DOUBLET_EXTRACTION: ERROR, NO VALUES BELOW AMC THRESHOLD RETRIEVED'
    RETURN,-1
  ENDIF

<span class="comments">;----------------------------------------</span>
<span class="comments">; SAVE ONLY DATA WHERE MATCHES WERE FOUND</span>

  IF KEYWORD_SET(VERBOSE) THEN PRINT,'DOUBLET_EXTRACTION: SAVING AND RETURNING ONLY THE GOOD DATA'
  ED_SENSOR1_SENSOR2=ED_SENSOR1_SENSOR2[*, WHERE(ED_SENSOR1_SENSOR2[0,*])]
  ED_SENSOR2_SENSOR1=ED_SENSOR2_SENSOR1[*, WHERE(ED_SENSOR2_SENSOR1[0,*])]
  SAVE,ED_SENSOR1_SENSOR2, FILENAME= S1_OFILE
  SAVE,ED_SENSOR2_SENSOR1, FILENAME= S2_OFILE
  
<span class="comments">;----------------------------------------</span>
<span class="comments">; REFORM THE ARRAYS IF REQUIRED   </span>
  
  IF N_ELEMENTS(ED_SENSOR1_SENSOR2) EQ 2*NUM_BANDS1+NUM_NON_REF+1 THEN BEGIN
    ED_SENSOR1_SENSOR2 = REFORM(ED_SENSOR1_SENSOR2,2*NUM_BANDS1+NUM_NON_REF+1,1)
    ED_SENSOR2_SENSOR1 = REFORM(ED_SENSOR2_SENSOR1,2*NUM_BANDS2+NUM_NON_REF+1,1)
  ENDIF
  
<span class="comments">;---------------------------------------- </span>
<span class="comments">; CREATE AN OUTPUT CSV FILE CONTAINING ALL DATA </span>
  
  IF KEYWORD_SET(VERBOSE) THEN PRINT,'DOUBLET_EXTRACTION: SAVING DATA AS A CSV FILE'
  NTIME = N_ELEMENTS(ED_SENSOR1_SENSOR2[0,*])
  HEADER = ['REGION','SENSOR','PROCESSING_VERSION','PARAMETER']
  TMP_HD = ['TIME','VZA','VAA','SZA','SAA','OZONE_MU','OZONE_SD','PRESSURE_MU','PRESSURE_SD','HUMIDITY_MU','HUMIDITY_SD', $
            'WIND_ZONAL_MU','WIND_ZONAL_SD','WIND_MERID_MU','WIND_MERID_SD','WVAP_MU','WVAP_SD'                           ]
  TMP_AUX = ['NUM_ROI_PIX','AUTO_CS','MANUAL_CS']
  IF NTIME EQ 1 THEN FORMAT = STRING('(4(A,1H;),1(F20.10))') $
  ELSE FORMAT = STRING('(4(A,1H;),'+STRTRIM(STRING(NTIME-1),2)+'(F20.10,1H;),(F20.10))')
  
  OPENW,OUTF,CSV_OFILE,/GET_LUN
  PRINTF,OUTF,FORMAT=FORMAT,HEADER,ED_SENSOR1_SENSOR2[0,*]

<span class="comments">;------------------------------------------------</span>
<span class="comments">; SETUP WINDOW PROPERTIES</span>

  MACHINE_WINDOW = !D.NAME
  YMIN = 0.
  YMAX = 1.
  SET_PLOT, 'Z'
  DEVICE, SET_RESOLUTION=[CFIG_DATA.(1)[0],CFIG_DATA.(1)[1]],SET_PIXEL_DEPTH=24
  DEVICE, DECOMPOSED = 0
  ERASE  
  LOADCT, 39
  PLOT_FILES = [OUT_PLOT_REF,OUT_PLOT_CAL]

  IF KEYWORD_SET(VERBOSE) THEN PRINT,'DOUBLET_EXTRACTION: STARTING LOOP TO OUTPUT SENSOR DATA TO CSV'  
  FOR EDS=0,1 DO BEGIN
    IF EDS EQ 0 THEN BEGIN
      DATA = ED_SENSOR1_SENSOR2  
      TMP_BANDS = NUM_BANDS1
      PRINTF,OUTF,FORMAT=FORMAT,ED_REGION,'NULL','NULL','GEO_TYPE',DATA[N_ELEMENTS(DATA[*,0])-2,*]
      PRINTF,OUTF,FORMAT=FORMAT,ED_REGION,'NULL','NULL','AMC',DATA[N_ELEMENTS(DATA[*,0])-1,*]
    ENDIF ELSE BEGIN
      DATA = ED_SENSOR2_SENSOR1
      TMP_BANDS = NUM_BANDS2
    ENDELSE
    MCOUNTER = 0
    SCOUNTER = 0
    LBANDS = STRARR(TMP_BANDS)    
    LCOLOR = INTARR(TMP_BANDS)

    ERASE
    PLOT,DATA[0,*],DATA[1,*],/NODATA,$
      COLOR = 0, BACKGROUND = 255,$
      YTITLE = SENS[EDS]+' DOUBLET TOA REFLECTANCE (DL)',$
      XTITLE = 'DECIMAL YEAR',$
      YRANGE = [YMIN,YMAX],$
      XRANGE = [FLOOR(min(DATA[0,*])),CEIL(max(DATA[0,*]))+1]
      XTICKFORMAT='((F8.3))'

    FOR DBEI=0,2*TMP_BANDS+NUM_NON_REF-1 DO BEGIN
      IF DBEI LE NUM_NON_REF-1 THEN PRINTF,OUTF,FORMAT=FORMAT,ED_REGION,SENS[EDS],PVER[EDS],TMP_HD[DBEI],DATA[DBEI,*] 
      IF (DBEI GT NUM_NON_REF-1) AND (DBEI LE TMP_BANDS+NUM_NON_REF-1) THEN BEGIN
        <span class="comments">;TBAND = CONVERT_INDEX_TO_WAVELENGTH(MCOUNTER,ED_SENS[EDS])</span>
        TBAND = GET_SENSOR_BAND_NAME(SENS[EDS],MCOUNTER)
        IF tband ne 'ERROR' then begin
        PRINTF,OUTF,FORMAT=FORMAT,ED_REGION,SENS[EDS],PVER[EDS],'TOA_REF_'+TBAND,DATA[NUM_NON_REF+MCOUNTER,*] 
        LBANDS[MCOUNTER] = TBAND
        LCOLOR[MCOUNTER] = 250.*MCOUNTER/TMP_BANDS
        TT = WHERE(DATA[NUM_NON_REF+MCOUNTER,*] GT 0.0 AND DATA[NUM_NON_REF+MCOUNTER,*] LT 1.0,TCOUNT)
          IF TCOUNT GT 0 THEN begin
            OPLOT, DATA[0,*],DATA[NUM_NON_REF+MCOUNTER,TT],COLOR = LCOLOR[MCOUNTER]
            XYOUTS,0.88,0.9-0.035*MCOUNTER,'- '+LBANDS[MCOUNTER],COLOR=LCOLOR[mCOUNTER],/normal
          ENDIF
        endif
        MCOUNTER++
      ENDIF
      IF DBEI GT TMP_BANDS+NUM_NON_REF-1 THEN BEGIN
        <span class="comments">;TBAND = CONVERT_INDEX_TO_WAVELENGTH(SCOUNTER,ED_SENS[EDS])</span>
        TBAND = GET_SENSOR_BAND_NAME(SENS[EDS],SCOUNTER)
        if tband ne 'ERROR' then PRINTF,OUTF,FORMAT=FORMAT,ED_REGION,SENS[EDS],PVER[EDS],'TOA_REF_STD_'+TBAND,DATA[NUM_NON_REF+TMP_BANDS+SCOUNTER,*] 
        SCOUNTER++    
      ENDIF
    ENDFOR

      PRINTF,OUTF,FORMAT=FORMAT,ED_REGION,SENS[EDS],PVER[EDS],tmp_aux[0],DATA[N_ELEMENTS(DATA[*,0])-5,*]
      PRINTF,OUTF,FORMAT=FORMAT,ED_REGION,SENS[EDS],PVER[EDS],tmp_aux[1],DATA[N_ELEMENTS(DATA[*,0])-4,*]
      PRINTF,OUTF,FORMAT=FORMAT,ED_REGION,SENS[EDS],PVER[EDS],tmp_aux[2],DATA[N_ELEMENTS(DATA[*,0])-3,*]
      
   <span class="comments">; LEGEND,LBANDS,COLOR=LCOLOR,/RIGHT</span>

    TEMP = TVRD(TRUE=1)
    WRITE_JPEG,PLOT_FILES[EDS],TEMP,TRUE=1,QUALITY=100
    ERASE

  ENDFOR 
  
<span class="comments">;------------------------------------------------ </span>
<span class="comments">; RESET WINDOW PROPERTIES AND CLOSE OUTPUT</span>
  
  SET_PLOT, MACHINE_WINDOW
  FREE_LUN,OUTF
  RETURN,1

END
</code>
    </div>
  </body>
</html>