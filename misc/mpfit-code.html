<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Tue Jul  2 12:51:01 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>mpfit.pro (Documentation for /home/marrabld/projects/DIMITRI_2.0/Source/)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="mpfit.pro (Documentation for /home/marrabld/projects/DIMITRI_2.0/Source/)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;   MPFIT</span>
<span class="comments">;</span>
<span class="comments">; AUTHOR:</span>
<span class="comments">;   Craig B. Markwardt, NASA/GSFC Code 662, Greenbelt, MD 20770</span>
<span class="comments">;   craigm@lheamail.gsfc.nasa.gov</span>
<span class="comments">;   UPDATED VERSIONs can be found on my WEB PAGE: </span>
<span class="comments">;      http://cow.physics.wisc.edu/~craigm/idl/idl.html</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;   Perform Levenberg-Marquardt least-squares minimization (MINPACK-1)</span>
<span class="comments">;</span>
<span class="comments">; MAJOR TOPICS:</span>
<span class="comments">;   Curve and Surface Fitting</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;   parms = MPFIT(MYFUNCT, start_parms, FUNCTARGS=fcnargs, NFEV=nfev,</span>
<span class="comments">;                 MAXITER=maxiter, ERRMSG=errmsg, NPRINT=nprint, QUIET=quiet, </span>
<span class="comments">;                 FTOL=ftol, XTOL=xtol, GTOL=gtol, NITER=niter, </span>
<span class="comments">;                 STATUS=status, ITERPROC=iterproc, ITERARGS=iterargs,</span>
<span class="comments">;                 COVAR=covar, PERROR=perror, BESTNORM=bestnorm,</span>
<span class="comments">;                 PARINFO=parinfo)</span>
<span class="comments">;</span>
<span class="comments">; DESCRIPTION:</span>
<span class="comments">;</span>
<span class="comments">;  MPFIT uses the Levenberg-Marquardt technique to solve the</span>
<span class="comments">;  least-squares problem.  In its typical use, MPFIT will be used to</span>
<span class="comments">;  fit a user-supplied function (the "model") to user-supplied data</span>
<span class="comments">;  points (the "data") by adjusting a set of parameters.  MPFIT is</span>
<span class="comments">;  based upon MINPACK-1 (LMDIF.F) by More' and collaborators.</span>
<span class="comments">;</span>
<span class="comments">;  For example, a researcher may think that a set of observed data</span>
<span class="comments">;  points is best modelled with a Gaussian curve.  A Gaussian curve is</span>
<span class="comments">;  parameterized by its mean, standard deviation and normalization.</span>
<span class="comments">;  MPFIT will, within certain constraints, find the set of parameters</span>
<span class="comments">;  which best fits the data.  The fit is "best" in the least-squares</span>
<span class="comments">;  sense; that is, the sum of the weighted squared differences between</span>
<span class="comments">;  the model and data is minimized.</span>
<span class="comments">;</span>
<span class="comments">;  The Levenberg-Marquardt technique is a particular strategy for</span>
<span class="comments">;  iteratively searching for the best fit.  This particular</span>
<span class="comments">;  implementation is drawn from MINPACK-1 (see NETLIB), and seems to</span>
<span class="comments">;  be more robust than routines provided with IDL.  This version</span>
<span class="comments">;  allows upper and lower bounding constraints to be placed on each</span>
<span class="comments">;  parameter, or the parameter can be held fixed.</span>
<span class="comments">;</span>
<span class="comments">;  The IDL user-supplied function should return an array of weighted</span>
<span class="comments">;  deviations between model and data.  In a typical scientific problem</span>
<span class="comments">;  the residuals should be weighted so that each deviate has a</span>
<span class="comments">;  gaussian sigma of 1.0.  If X represents values of the independent</span>
<span class="comments">;  variable, Y represents a measurement for each value of X, and ERR</span>
<span class="comments">;  represents the error in the measurements, then the deviates could</span>
<span class="comments">;  be calculated as follows:</span>
<span class="comments">;</span>
<span class="comments">;    DEVIATES = (Y - F(X)) / ERR</span>
<span class="comments">;</span>
<span class="comments">;  where F is the function representing the model.  You are</span>
<span class="comments">;  recommended to use the convenience functions MPFITFUN and</span>
<span class="comments">;  MPFITEXPR, which are driver functions that calculate the deviates</span>
<span class="comments">;  for you.  If ERR are the 1-sigma uncertainties in Y, then</span>
<span class="comments">;</span>
<span class="comments">;    TOTAL( DEVIATES^2 ) </span>
<span class="comments">;</span>
<span class="comments">;  will be the total chi-squared value.  MPFIT will minimize the</span>
<span class="comments">;  chi-square value.  The values of X, Y and ERR are passed through</span>
<span class="comments">;  MPFIT to the user-supplied function via the FUNCTARGS keyword.</span>
<span class="comments">;</span>
<span class="comments">;  Simple constraints can be placed on parameter values by using the</span>
<span class="comments">;  PARINFO keyword to MPFIT.  See below for a description of this</span>
<span class="comments">;  keyword.</span>
<span class="comments">;</span>
<span class="comments">;  MPFIT does not perform more general optimization tasks.  See TNMIN</span>
<span class="comments">;  instead.  MPFIT is customized, based on MINPACK-1, to the</span>
<span class="comments">;  least-squares minimization problem.</span>
<span class="comments">;</span>
<span class="comments">; USER FUNCTION</span>
<span class="comments">;</span>
<span class="comments">;  The user must define a function which returns the appropriate</span>
<span class="comments">;  values as specified above.  The function should return the weighted</span>
<span class="comments">;  deviations between the model and the data.  For applications which</span>
<span class="comments">;  use finite-difference derivatives -- the default -- the user</span>
<span class="comments">;  function should be declared in the following way:</span>
<span class="comments">;</span>
<span class="comments">;    FUNCTION MYFUNCT, p, X=x, Y=y, ERR=err</span>
<span class="comments">;     ; Parameter values are passed in "p"</span>
<span class="comments">;     model = F(x, p)</span>
<span class="comments">;     return, (y-model)/err</span>
<span class="comments">;    END</span>
<span class="comments">;</span>
<span class="comments">;  See below for applications with explicit derivatives.</span>
<span class="comments">;</span>
<span class="comments">;  The keyword parameters X, Y, and ERR in the example above are</span>
<span class="comments">;  suggestive but not required.  Any parameters can be passed to</span>
<span class="comments">;  MYFUNCT by using the FUNCTARGS keyword to MPFIT.  Use MPFITFUN and</span>
<span class="comments">;  MPFITEXPR if you need ideas on how to do that.  The function *must*</span>
<span class="comments">;  accept a parameter list, P.</span>
<span class="comments">;  </span>
<span class="comments">;  In general there are no restrictions on the number of dimensions in</span>
<span class="comments">;  X, Y or ERR.  However the deviates *must* be returned in a</span>
<span class="comments">;  one-dimensional array, and must have the same type (float or</span>
<span class="comments">;  double) as the input arrays.</span>
<span class="comments">;</span>
<span class="comments">;  See below for error reporting mechanisms.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CHECKING STATUS AND HANNDLING ERRORS</span>
<span class="comments">;</span>
<span class="comments">;  Upon return, MPFIT will report the status of the fitting operation</span>
<span class="comments">;  in the STATUS and ERRMSG keywords.  The STATUS keyword will contain</span>
<span class="comments">;  a numerical code which indicates the success or failure status.</span>
<span class="comments">;  Generally speaking, any value 1 or greater indicates success, while</span>
<span class="comments">;  a value of 0 or less indicates a possible failure.  The ERRMSG</span>
<span class="comments">;  keyword will contain a text string which should describe the error</span>
<span class="comments">;  condition more fully.</span>
<span class="comments">;</span>
<span class="comments">;  By default, MPFIT will trap fatal errors and report them to the</span>
<span class="comments">;  caller gracefully.  However, during the debugging process, it is</span>
<span class="comments">;  often useful to halt execution where the error occurred.  When you</span>
<span class="comments">;  set the NOCATCH keyword, MPFIT will not do any special error</span>
<span class="comments">;  trapping, and execution will stop where ever the error occurred.</span>
<span class="comments">;</span>
<span class="comments">;  MPFIT does not explicitly change the !ERROR_STATE variable</span>
<span class="comments">;  (although it may be changed implicitly if MPFIT calls MESSAGE).  It</span>
<span class="comments">;  is the caller's responsibility to call MESSAGE, /RESET to ensure</span>
<span class="comments">;  that the error state is initialized before calling MPFIT.</span>
<span class="comments">;</span>
<span class="comments">;  User functions may also indicate non-fatal error conditions using</span>
<span class="comments">;  the ERROR_CODE common block variable, as described below under the</span>
<span class="comments">;  MPFIT_ERROR common block definition (by setting ERROR_CODE to a</span>
<span class="comments">;  number between -15 and -1).  When the user function sets an error</span>
<span class="comments">;  condition via ERROR_CODE, MPFIT will gracefully exit immediately</span>
<span class="comments">;  and report this condition to the caller.  The ERROR_CODE is</span>
<span class="comments">;  returned in the STATUS keyword in that case.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; EXPLICIT DERIVATIVES</span>
<span class="comments">; </span>
<span class="comments">;  In the search for the best-fit solution, MPFIT by default</span>
<span class="comments">;  calculates derivatives numerically via a finite difference</span>
<span class="comments">;  approximation.  The user-supplied function need not calculate the</span>
<span class="comments">;  derivatives explicitly.  However, the user function *may* calculate</span>
<span class="comments">;  the derivatives if desired, but only if the model function is</span>
<span class="comments">;  declared with an additional position parameter, DP, as described</span>
<span class="comments">;  below.  If the user function does not accept this additional</span>
<span class="comments">;  parameter, MPFIT will report an error.  As a practical matter, it</span>
<span class="comments">;  is often sufficient and even faster to allow MPFIT to calculate the</span>
<span class="comments">;  derivatives numerically, but this option is available for users who</span>
<span class="comments">;  wish more control over the fitting process.</span>
<span class="comments">;</span>
<span class="comments">;  There are two ways to enable explicit derivatives.  First, the user</span>
<span class="comments">;  can set the keyword AUTODERIVATIVE=0, which is a global switch for</span>
<span class="comments">;  all parameters.  In this case, MPFIT will request explicit</span>
<span class="comments">;  derivatives for every free parameter.  </span>
<span class="comments">;</span>
<span class="comments">;  Second, the user may request explicit derivatives for specifically</span>
<span class="comments">;  selected parameters using the PARINFO.MPSIDE=3 (see "CONSTRAINING</span>
<span class="comments">;  PARAMETER VALUES WITH THE PARINFO KEYWORD" below).  In this</span>
<span class="comments">;  strategy, the user picks and chooses which parameter derivatives</span>
<span class="comments">;  are computed explicitly versus numerically.  When PARINFO[i].MPSIDE</span>
<span class="comments">;  EQ 3, then the ith parameter derivative is computed explicitly.</span>
<span class="comments">;</span>
<span class="comments">;  The keyword setting AUTODERIVATIVE=0 always globally overrides the</span>
<span class="comments">;  individual values of PARINFO.MPSIDE.  Setting AUTODERIVATIVE=0 is</span>
<span class="comments">;  equivalent to resetting PARINFO.MPSIDE=3 for all parameters.</span>
<span class="comments">;</span>
<span class="comments">;  However, be aware that even if the user requests explicit</span>
<span class="comments">;  derivatives for some or all parameters, MPFIT will not always</span>
<span class="comments">;  request explicit derivatives on ever user function call.</span>
<span class="comments">;</span>
<span class="comments">; EXPLICIT DERIVATIVES - CALLING INTERFACE</span>
<span class="comments">;</span>
<span class="comments">;  When AUTODERIVATIVE=0, the user function is responsible for</span>
<span class="comments">;  calculating the derivatives of the *residuals* with respect to each</span>
<span class="comments">;  parameter.  The user function should be declared as follows:</span>
<span class="comments">;</span>
<span class="comments">;    ;</span>
<span class="comments">;    ; MYFUNCT - example user function</span>
<span class="comments">;    ;   P - input parameter values (N-element array)</span>
<span class="comments">;    ;   DP - upon input, an N-vector indicating which parameters</span>
<span class="comments">;    ;          to compute derivatives for; </span>
<span class="comments">;    ;        upon output, the user function must return</span>
<span class="comments">;    ;          an ARRAY(M,N) of derivatives in this keyword</span>
<span class="comments">;    ;   (keywords) - any other keywords specified by FUNCTARGS</span>
<span class="comments">;    ; RETURNS - residual values</span>
<span class="comments">;    ;</span>
<span class="comments">;    FUNCTION MYFUNCT, p, dp, X=x, Y=y, ERR=err</span>
<span class="comments">;     model = F(x, p)         ;; Model function</span>
<span class="comments">;     resid = (y - model)/err ;; Residual calculation (for example)</span>
<span class="comments">;     </span>
<span class="comments">;     if n_params() GT 1 then begin</span>
<span class="comments">;       ; Create derivative and compute derivative array</span>
<span class="comments">;       requested = dp   ; Save original value of DP</span>
<span class="comments">;       dp = make_array(n_elements(x), n_elements(p), value=x[0]*0)</span>
<span class="comments">;</span>
<span class="comments">;       ; Compute derivative if requested by caller</span>
<span class="comments">;       for i = 0, n_elements(p)-1 do if requested(i) NE 0 then $</span>
<span class="comments">;         dp(*,i) = FGRAD(x, p, i) / err</span>
<span class="comments">;     endif</span>
<span class="comments">;    </span>
<span class="comments">;     return, resid</span>
<span class="comments">;    END</span>
<span class="comments">;</span>
<span class="comments">;  where FGRAD(x, p, i) is a model function which computes the</span>
<span class="comments">;  derivative of the model F(x,p) with respect to parameter P(i) at X.</span>
<span class="comments">;</span>
<span class="comments">;  A quirk in the implementation leaves a stray negative sign in the</span>
<span class="comments">;  definition of DP.  The derivative of the *residual* should be</span>
<span class="comments">;  "-FGRAD(x,p,i) / err" because of how the residual is defined</span>
<span class="comments">;  ("resid = (data - model) / err").  **HOWEVER** because of the</span>
<span class="comments">;  implementation quirk, MPFIT expects FGRAD(x,p,i)/err instead,</span>
<span class="comments">;  i.e. the opposite sign of the gradient of RESID.</span>
<span class="comments">;</span>
<span class="comments">;  Derivatives should be returned in the DP array. DP should be an</span>
<span class="comments">;  ARRAY(m,n) array, where m is the number of data points and n is the</span>
<span class="comments">;  number of parameters.  -DP[i,j] is the derivative of the ith</span>
<span class="comments">;  residual with respect to the jth parameter (note the minus sign</span>
<span class="comments">;  due to the quirk described above).</span>
<span class="comments">;</span>
<span class="comments">;  As noted above, MPFIT may not always request derivatives from the</span>
<span class="comments">;  user function.  In those cases, the parameter DP is not passed.</span>
<span class="comments">;  Therefore functions can use N_PARAMS() to indicate whether they</span>
<span class="comments">;  must compute the derivatives or not.</span>
<span class="comments">;  </span>
<span class="comments">;  The derivatives with respect to fixed parameters are ignored; zero</span>
<span class="comments">;  is an appropriate value to insert for those derivatives.  Upon</span>
<span class="comments">;  input to the user function, DP is set to a vector with the same</span>
<span class="comments">;  length as P, with a value of 1 for a parameter which is free, and a</span>
<span class="comments">;  value of zero for a parameter which is fixed (and hence no</span>
<span class="comments">;  derivative needs to be calculated).  This input vector may be</span>
<span class="comments">;  overwritten as needed.  In the example above, the original DP</span>
<span class="comments">;  vector is saved to a variable called REQUESTED, and used as a mask</span>
<span class="comments">;  to calculate only those derivatives that are required.</span>
<span class="comments">;</span>
<span class="comments">;  If the data is higher than one dimensional, then the *last*</span>
<span class="comments">;  dimension should be the parameter dimension.  Example: fitting a</span>
<span class="comments">;  50x50 image, "dp" should be 50x50xNPAR.</span>
<span class="comments">;</span>
<span class="comments">; EXPLICIT DERIVATIVES - TESTING and DEBUGGING</span>
<span class="comments">;</span>
<span class="comments">;  For reasonably complicated user functions, the calculation of</span>
<span class="comments">;  explicit derivatives of the correct sign and magnitude can be</span>
<span class="comments">;  difficult to get right.  A simple sign error can cause MPFIT to be</span>
<span class="comments">;  confused.  MPFIT has a derivative debugging mode which will compute</span>
<span class="comments">;  the derivatives *both* numerically and explicitly, and compare the</span>
<span class="comments">;  results.</span>
<span class="comments">;</span>
<span class="comments">;  It is expected that during production usage, derivative debugging</span>
<span class="comments">;  should be disabled for all parameters.</span>
<span class="comments">;</span>
<span class="comments">;  In order to enable derivative debugging mode, set the following</span>
<span class="comments">;  PARINFO members for the ith parameter.</span>
<span class="comments">;      PARINFO[i].MPSIDE = 3          ; Enable explicit derivatives</span>
<span class="comments">;      PARINFO[i].MPDERIV_DEBUG = 1   ; Enable derivative debugging mode</span>
<span class="comments">;      PARINFO[i].MPDERIV_RELTOL = ?? ; Relative tolerance for comparison</span>
<span class="comments">;      PARINFO[i].MPDERIV_ABSTOL = ?? ; Absolute tolerance for comparison</span>
<span class="comments">;  Note that these settings are maintained on a parameter-by-parameter</span>
<span class="comments">;  basis using PARINFO, so the user can choose which parameters</span>
<span class="comments">;  derivatives will be tested.</span>
<span class="comments">;</span>
<span class="comments">;  When .MPDERIV_DEBUG is set, then MPFIT first computes the</span>
<span class="comments">;  derivative explicitly by requesting them from the user function.</span>
<span class="comments">;  Then, it computes the derivatives numerically via finite</span>
<span class="comments">;  differencing, and compares the two values.  If the difference</span>
<span class="comments">;  exceeds a tolerance threshold, then the values are printed out to </span>
<span class="comments">;  alert the user.  The tolerance level threshold contains both a</span>
<span class="comments">;  relative and an absolute component, and is expressed as,</span>
<span class="comments">;</span>
<span class="comments">;     ABS(DERIV_U - DERIV_N) GE (ABSTOL + RELTOL*ABS(DERIV_U))</span>
<span class="comments">;</span>
<span class="comments">;  where DERIV_U and DERIV_N are the derivatives computed explicitly</span>
<span class="comments">;  and numerically, respectively.  Appropriate values</span>
<span class="comments">;  for most users will be: </span>
<span class="comments">;</span>
<span class="comments">;      PARINFO[i].MPDERIV_RELTOL = 1d-3 ;; Suggested relative tolerance </span>
<span class="comments">;      PARINFO[i].MPDERIV_ABSTOL = 1d-7 ;; Suggested absolute tolerance</span>
<span class="comments">;</span>
<span class="comments">;  although these thresholds may have to be adjusted for a particular</span>
<span class="comments">;  problem.  When the threshold is exceeded, users can expect to see a</span>
<span class="comments">;  tabular report like this one:</span>
<span class="comments">;</span>
<span class="comments">;    FJAC DEBUG BEGIN</span>
<span class="comments">;    #        IPNT       FUNC    DERIV_U    DERIV_N   DIFF_ABS   DIFF_REL</span>
<span class="comments">;    FJAC PARM 2</span>
<span class="comments">;               80    -0.7308    0.04233    0.04233 -5.543E-07 -1.309E-05</span>
<span class="comments">;               99      1.370    0.01417    0.01417 -5.518E-07 -3.895E-05</span>
<span class="comments">;              118    0.07187   -0.01400   -0.01400 -5.566E-07  3.977E-05</span>
<span class="comments">;              137      1.844   -0.04216   -0.04216 -5.589E-07  1.326E-05</span>
<span class="comments">;    FJAC DEBUG END</span>
<span class="comments">;</span>
<span class="comments">;  The report will be bracketed by FJAC DEBUG BEGIN/END statements.</span>
<span class="comments">;  Each parameter will be delimited by the statement FJAC PARM n,</span>
<span class="comments">;  where n is the parameter number.  The columns are,</span>
<span class="comments">;</span>
<span class="comments">;      IPNT - data point number  (0 ... M-1)</span>
<span class="comments">;      FUNC - function value at that point</span>
<span class="comments">;      DERIV_U - explicit derivative value at that point</span>
<span class="comments">;      DERIV_N - numerical derivative estimate at that point</span>
<span class="comments">;      DIFF_ABS - absolute difference = (DERIV_U - DERIV_N)</span>
<span class="comments">;      DIFF_REL - relative difference = (DIFF_ABS)/(DERIV_U)</span>
<span class="comments">;</span>
<span class="comments">;  When prints appear in this report, it is most important to check</span>
<span class="comments">;  that the derivatives computed in two different ways have the same</span>
<span class="comments">;  numerical sign and the same order of magnitude, since these are the</span>
<span class="comments">;  most common programming mistakes.</span>
<span class="comments">;    </span>
<span class="comments">;  </span>
<span class="comments">; CONSTRAINING PARAMETER VALUES WITH THE PARINFO KEYWORD</span>
<span class="comments">;</span>
<span class="comments">;  The behavior of MPFIT can be modified with respect to each</span>
<span class="comments">;  parameter to be fitted.  A parameter value can be fixed; simple</span>
<span class="comments">;  boundary constraints can be imposed; limitations on the parameter</span>
<span class="comments">;  changes can be imposed; properties of the automatic derivative can</span>
<span class="comments">;  be modified; and parameters can be tied to one another.</span>
<span class="comments">;</span>
<span class="comments">;  These properties are governed by the PARINFO structure, which is</span>
<span class="comments">;  passed as a keyword parameter to MPFIT.</span>
<span class="comments">;</span>
<span class="comments">;  PARINFO should be an array of structures, one for each parameter.</span>
<span class="comments">;  Each parameter is associated with one element of the array, in</span>
<span class="comments">;  numerical order.  The structure can have the following entries</span>
<span class="comments">;  (none are required):</span>
<span class="comments">;  </span>
<span class="comments">;     .VALUE - the starting parameter value (but see the START_PARAMS</span>
<span class="comments">;              parameter for more information).</span>
<span class="comments">;  </span>
<span class="comments">;     .FIXED - a boolean value, whether the parameter is to be held</span>
<span class="comments">;              fixed or not.  Fixed parameters are not varied by</span>
<span class="comments">;              MPFIT, but are passed on to MYFUNCT for evaluation.</span>
<span class="comments">;  </span>
<span class="comments">;     .LIMITED - a two-element boolean array.  If the first/second</span>
<span class="comments">;                element is set, then the parameter is bounded on the</span>
<span class="comments">;                lower/upper side.  A parameter can be bounded on both</span>
<span class="comments">;                sides.  Both LIMITED and LIMITS must be given</span>
<span class="comments">;                together.</span>
<span class="comments">;  </span>
<span class="comments">;     .LIMITS - a two-element float or double array.  Gives the</span>
<span class="comments">;               parameter limits on the lower and upper sides,</span>
<span class="comments">;               respectively.  Zero, one or two of these values can be</span>
<span class="comments">;               set, depending on the values of LIMITED.  Both LIMITED</span>
<span class="comments">;               and LIMITS must be given together.</span>
<span class="comments">;  </span>
<span class="comments">;     .PARNAME - a string, giving the name of the parameter.  The</span>
<span class="comments">;                fitting code of MPFIT does not use this tag in any</span>
<span class="comments">;                way.  However, the default ITERPROC will print the</span>
<span class="comments">;                parameter name if available.</span>
<span class="comments">;  </span>
<span class="comments">;     .STEP - the step size to be used in calculating the numerical</span>
<span class="comments">;             derivatives.  If set to zero, then the step size is</span>
<span class="comments">;             computed automatically.  Ignored when AUTODERIVATIVE=0.</span>
<span class="comments">;             This value is superceded by the RELSTEP value.</span>
<span class="comments">;</span>
<span class="comments">;     .RELSTEP - the *relative* step size to be used in calculating</span>
<span class="comments">;                the numerical derivatives.  This number is the</span>
<span class="comments">;                fractional size of the step, compared to the</span>
<span class="comments">;                parameter value.  This value supercedes the STEP</span>
<span class="comments">;                setting.  If the parameter is zero, then a default</span>
<span class="comments">;                step size is chosen.</span>
<span class="comments">;</span>
<span class="comments">;     .MPSIDE - selector for type of derivative calculation. This</span>
<span class="comments">;               field can take one of five possible values:</span>
<span class="comments">;</span>
<span class="comments">;                  0 - one-sided derivative computed automatically</span>
<span class="comments">;                  1 - one-sided derivative (f(x+h) - f(x)  )/h</span>
<span class="comments">;                 -1 - one-sided derivative (f(x)   - f(x-h))/h</span>
<span class="comments">;                  2 - two-sided derivative (f(x+h) - f(x-h))/(2*h)</span>
<span class="comments">;                  3 - explicit derivative used for this parameter</span>
<span class="comments">;</span>
<span class="comments">;              In the first four cases, the derivative is approximated</span>
<span class="comments">;              numerically by finite difference, with step size</span>
<span class="comments">;              H=STEP, where the STEP parameter is defined above.  The</span>
<span class="comments">;              last case, MPSIDE=3, indicates to allow the user</span>
<span class="comments">;              function to compute the derivative explicitly (see</span>
<span class="comments">;              section on "EXPLICIT DERIVATIVES").  AUTODERIVATIVE=0</span>
<span class="comments">;              overrides this setting for all parameters, and is</span>
<span class="comments">;              equivalent to MPSIDE=3 for all parameters.  For</span>
<span class="comments">;              MPSIDE=0, the "automatic" one-sided derivative method</span>
<span class="comments">;              will chose a direction for the finite difference which</span>
<span class="comments">;              does not violate any constraints.  The other methods</span>
<span class="comments">;              (MPSIDE=-1 or MPSIDE=1) do not perform this check.  The</span>
<span class="comments">;              two-sided method is in principle more precise, but</span>
<span class="comments">;              requires twice as many function evaluations.  Default:</span>
<span class="comments">;              0.</span>
<span class="comments">;</span>
<span class="comments">;     .MPDERIV_DEBUG - set this value to 1 to enable debugging of</span>
<span class="comments">;              user-supplied explicit derivatives (see "TESTING and</span>
<span class="comments">;              DEBUGGING" section above).  In addition, the</span>
<span class="comments">;              user must enable calculation of explicit derivatives by</span>
<span class="comments">;              either setting AUTODERIVATIVE=0, or MPSIDE=3 for the</span>
<span class="comments">;              desired parameters.  When this option is enabled, a</span>
<span class="comments">;              report may be printed to the console, depending on the</span>
<span class="comments">;              MPDERIV_ABSTOL and MPDERIV_RELTOL settings.</span>
<span class="comments">;              Default: 0 (no debugging)</span>
<span class="comments">;</span>
<span class="comments">;     </span>
<span class="comments">;     .MPDERIV_ABSTOL, .MPDERIV_RELTOL - tolerance settings for</span>
<span class="comments">;              print-out of debugging information, for each parameter</span>
<span class="comments">;              where debugging is enabled.  See "TESTING and</span>
<span class="comments">;              DEBUGGING" section above for the meanings of these two</span>
<span class="comments">;              fields.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">;     .MPMAXSTEP - the maximum change to be made in the parameter</span>
<span class="comments">;                  value.  During the fitting process, the parameter</span>
<span class="comments">;                  will never be changed by more than this value in</span>
<span class="comments">;                  one iteration.</span>
<span class="comments">;</span>
<span class="comments">;                  A value of 0 indicates no maximum.  Default: 0.</span>
<span class="comments">;  </span>
<span class="comments">;     .TIED - a string expression which "ties" the parameter to other</span>
<span class="comments">;             free or fixed parameters as an equality constraint.  Any</span>
<span class="comments">;             expression involving constants and the parameter array P</span>
<span class="comments">;             are permitted.</span>
<span class="comments">;             Example: if parameter 2 is always to be twice parameter</span>
<span class="comments">;             1 then use the following: parinfo[2].tied = '2 * P[1]'.</span>
<span class="comments">;             Since they are totally constrained, tied parameters are</span>
<span class="comments">;             considered to be fixed; no errors are computed for them,</span>
<span class="comments">;             and any LIMITS are not obeyed.</span>
<span class="comments">;             [ NOTE: the PARNAME can't be used in a TIED expression. ]</span>
<span class="comments">;</span>
<span class="comments">;     .MPPRINT - if set to 1, then the default ITERPROC will print the</span>
<span class="comments">;                parameter value.  If set to 0, the parameter value</span>
<span class="comments">;                will not be printed.  This tag can be used to</span>
<span class="comments">;                selectively print only a few parameter values out of</span>
<span class="comments">;                many.  Default: 1 (all parameters printed)</span>
<span class="comments">;</span>
<span class="comments">;     .MPFORMAT - IDL format string to print the parameter within</span>
<span class="comments">;                 ITERPROC.  Default: '(G20.6)'  (An empty string will</span>
<span class="comments">;                 also use the default.)</span>
<span class="comments">;</span>
<span class="comments">;  Future modifications to the PARINFO structure, if any, will involve</span>
<span class="comments">;  adding structure tags beginning with the two letters "MP".</span>
<span class="comments">;  Therefore programmers are urged to avoid using tags starting with</span>
<span class="comments">;  "MP", but otherwise they are free to include their own fields</span>
<span class="comments">;  within the PARINFO structure, which will be ignored by MPFIT.</span>
<span class="comments">;  </span>
<span class="comments">;  PARINFO Example:</span>
<span class="comments">;  parinfo = replicate({value:0.D, fixed:0, limited:[0,0], $</span>
<span class="comments">;                       limits:[0.D,0]}, 5)</span>
<span class="comments">;  parinfo[0].fixed = 1</span>
<span class="comments">;  parinfo[4].limited[0] = 1</span>
<span class="comments">;  parinfo[4].limits[0]  = 50.D</span>
<span class="comments">;  parinfo[*].value = [5.7D, 2.2, 500., 1.5, 2000.]</span>
<span class="comments">;  </span>
<span class="comments">;  A total of 5 parameters, with starting values of 5.7,</span>
<span class="comments">;  2.2, 500, 1.5, and 2000 are given.  The first parameter</span>
<span class="comments">;  is fixed at a value of 5.7, and the last parameter is</span>
<span class="comments">;  constrained to be above 50.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; COMPATIBILITY</span>
<span class="comments">;</span>
<span class="comments">;  This function is designed to work with IDL 5.0 or greater.</span>
<span class="comments">;  </span>
<span class="comments">;  Because TIED parameters and the "(EXTERNAL)" user-model feature use</span>
<span class="comments">;  the EXECUTE() function, they cannot be used with the free version</span>
<span class="comments">;  of the IDL Virtual Machine.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; DETERMINING THE VERSION OF MPFIT</span>
<span class="comments">;</span>
<span class="comments">;  MPFIT is a changing library.  Users of MPFIT may also depend on a</span>
<span class="comments">;  specific version of the library being present.  As of version 1.70</span>
<span class="comments">;  of MPFIT, a VERSION keyword has been added which allows the user to</span>
<span class="comments">;  query which version is present.  The keyword works like this:</span>
<span class="comments">;</span>
<span class="comments">;    RESULT = MPFIT(/query, VERSION=version)</span>
<span class="comments">;</span>
<span class="comments">;  This call uses the /QUERY keyword to query the version number</span>
<span class="comments">;  without performing any computations.  Users of MPFIT can call this</span>
<span class="comments">;  method to determine which version is in the IDL path before</span>
<span class="comments">;  actually using MPFIT to do any numerical work.  Upon return, the</span>
<span class="comments">;  VERSION keyword contains the version number of MPFIT, expressed as</span>
<span class="comments">;  a string of the form 'X.Y' where X and Y are integers.</span>
<span class="comments">;</span>
<span class="comments">;  Users can perform their own version checking, or use the built-in</span>
<span class="comments">;  error checking of MPFIT.  The MIN_VERSION keyword enforces the</span>
<span class="comments">;  requested minimum version number.  For example,</span>
<span class="comments">;</span>
<span class="comments">;    RESULT = MPFIT(/query, VERSION=version, MIN_VERSION='1.70')</span>
<span class="comments">;</span>
<span class="comments">;  will check whether the accessed version is 1.70 or greater, without</span>
<span class="comments">;  performing any numerical processing.</span>
<span class="comments">;</span>
<span class="comments">;  Because the VERSION and MIN_VERSION keywords were added in MPFIT</span>
<span class="comments">;  version 1.70 and later.  If the caller attempts to use the VERSION</span>
<span class="comments">;  or MIN_VERSION keywords, and an *older* version of the code is</span>
<span class="comments">;  present in the caller's path, then IDL will throw an 'unknown</span>
<span class="comments">;  keyword' error.  Therefore, in order to be robust, the caller, must</span>
<span class="comments">;  use exception handling.  Here is an example demanding at least</span>
<span class="comments">;  version 1.70.</span>
<span class="comments">;</span>
<span class="comments">;    MPFIT_OK = 0  & VERSION = '&lt;unknown>'</span>
<span class="comments">;    CATCH, CATCHERR</span>
<span class="comments">;    IF CATCHERR EQ 0 THEN MPFIT_OK = MPFIT(/query, VERSION=version, $</span>
<span class="comments">;                                         MIN_VERSION='1.70')</span>
<span class="comments">;    CATCH, /CANCEL</span>
<span class="comments">;</span>
<span class="comments">;    IF NOT MPFIT_OK THEN $</span>
<span class="comments">;      MESSAGE, 'ERROR: you must have MPFIT version 1.70 or higher in '+$</span>
<span class="comments">;             'your path (found version '+version+')'</span>
<span class="comments">;</span>
<span class="comments">;  Of course, the caller can also do its own version number</span>
<span class="comments">;  requirements checking.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; HARD-TO-COMPUTE FUNCTIONS: "EXTERNAL" EVALUATION</span>
<span class="comments">;</span>
<span class="comments">;  The normal mode of operation for MPFIT is for the user to pass a</span>
<span class="comments">;  function name, and MPFIT will call the user function multiple times</span>
<span class="comments">;  as it iterates toward a solution.</span>
<span class="comments">;</span>
<span class="comments">;  Some user functions are particularly hard to compute using the</span>
<span class="comments">;  standard model of MPFIT.  Usually these are functions that depend</span>
<span class="comments">;  on a large amount of external data, and so it is not feasible, or</span>
<span class="comments">;  at least highly impractical, to have MPFIT call it.  In those cases</span>
<span class="comments">;  it may be possible to use the "(EXTERNAL)" evaluation option.</span>
<span class="comments">;</span>
<span class="comments">;  In this case the user is responsible for making all function *and</span>
<span class="comments">;  derivative* evaluations.  The function and Jacobian data are passed</span>
<span class="comments">;  in through the EXTERNAL_FVEC and EXTERNAL_FJAC keywords,</span>
<span class="comments">;  respectively.  The user indicates the selection of this option by</span>
<span class="comments">;  specifying a function name (MYFUNCT) of "(EXTERNAL)".  No</span>
<span class="comments">;  user-function calls are made when EXTERNAL evaluation is being</span>
<span class="comments">;  used.</span>
<span class="comments">;</span>
<span class="comments">;  ** SPECIAL NOTE ** For the "(EXTERNAL)" case, the quirk noted above</span>
<span class="comments">;     does not apply.  The gradient matrix, EXTERNAL_FJAC, should be</span>
<span class="comments">;     comparable to "-FGRAD(x,p)/err", which is the *opposite* sign of</span>
<span class="comments">;     the DP matrix described above.  In other words, EXTERNAL_FJAC</span>
<span class="comments">;     has the same sign as the derivative of EXTERNAL_FVEC, and the</span>
<span class="comments">;     opposite sign of FGRAD.</span>
<span class="comments">;</span>
<span class="comments">;  At the end of each iteration, control returns to the user, who must</span>
<span class="comments">;  reevaluate the function at its new parameter values.  Users should</span>
<span class="comments">;  check the return value of the STATUS keyword, where a value of 9</span>
<span class="comments">;  indicates the user should supply more data for the next iteration,</span>
<span class="comments">;  and re-call MPFIT.  The user may refrain from calling MPFIT</span>
<span class="comments">;  further; as usual, STATUS will indicate when the solution has</span>
<span class="comments">;  converged and no more iterations are required.</span>
<span class="comments">;</span>
<span class="comments">;  Because MPFIT must maintain its own data structures between calls,</span>
<span class="comments">;  the user must also pass a named variable to the EXTERNAL_STATE</span>
<span class="comments">;  keyword.  This variable must be maintained by the user, but not</span>
<span class="comments">;  changed, throughout the fitting process.  When no more iterations</span>
<span class="comments">;  are desired, the named variable may be discarded.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; INPUTS:</span>
<span class="comments">;   MYFUNCT - a string variable containing the name of the function to</span>
<span class="comments">;             be minimized.  The function should return the weighted</span>
<span class="comments">;             deviations between the model and the data, as described</span>
<span class="comments">;             above.</span>
<span class="comments">;</span>
<span class="comments">;             For EXTERNAL evaluation of functions, this parameter</span>
<span class="comments">;             should be set to a value of "(EXTERNAL)".</span>
<span class="comments">;</span>
<span class="comments">;   START_PARAMS - An one-dimensional array of starting values for each of the</span>
<span class="comments">;                  parameters of the model.  The number of parameters</span>
<span class="comments">;                  should be fewer than the number of measurements.</span>
<span class="comments">;                  Also, the parameters should have the same data type</span>
<span class="comments">;                  as the measurements (double is preferred).</span>
<span class="comments">;</span>
<span class="comments">;                  This parameter is optional if the PARINFO keyword</span>
<span class="comments">;                  is used (but see PARINFO).  The PARINFO keyword</span>
<span class="comments">;                  provides a mechanism to fix or constrain individual</span>
<span class="comments">;                  parameters.  If both START_PARAMS and PARINFO are</span>
<span class="comments">;                  passed, then the starting *value* is taken from</span>
<span class="comments">;                  START_PARAMS, but the *constraints* are taken from</span>
<span class="comments">;                  PARINFO.</span>
<span class="comments">; </span>
<span class="comments">; RETURNS:</span>
<span class="comments">;</span>
<span class="comments">;   Returns the array of best-fit parameters.</span>
<span class="comments">;   Exceptions: </span>
<span class="comments">;      * if /QUERY is set (see QUERY).</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; KEYWORD PARAMETERS:</span>
<span class="comments">;</span>
<span class="comments">;   AUTODERIVATIVE - If this is set, derivatives of the function will</span>
<span class="comments">;                    be computed automatically via a finite</span>
<span class="comments">;                    differencing procedure.  If not set, then MYFUNCT</span>
<span class="comments">;                    must provide the explicit derivatives.</span>
<span class="comments">;                    Default: set (=1) </span>
<span class="comments">;                    NOTE: to supply your own explicit derivatives,</span>
<span class="comments">;                      explicitly pass AUTODERIVATIVE=0</span>
<span class="comments">;</span>
<span class="comments">;   BESTNORM - the value of the summed squared weighted residuals for</span>
<span class="comments">;              the returned parameter values, i.e. TOTAL(DEVIATES^2).</span>
<span class="comments">;</span>
<span class="comments">;   COVAR - the covariance matrix for the set of parameters returned</span>
<span class="comments">;           by MPFIT.  The matrix is NxN where N is the number of</span>
<span class="comments">;           parameters.  The square root of the diagonal elements</span>
<span class="comments">;           gives the formal 1-sigma statistical errors on the</span>
<span class="comments">;           parameters IF errors were treated "properly" in MYFUNC.</span>
<span class="comments">;           Parameter errors are also returned in PERROR.</span>
<span class="comments">;</span>
<span class="comments">;           To compute the correlation matrix, PCOR, use this example:</span>
<span class="comments">;                  PCOR = COV * 0</span>
<span class="comments">;                  FOR i = 0, n-1 DO FOR j = 0, n-1 DO $</span>
<span class="comments">;                    PCOR[i,j] = COV[i,j]/sqrt(COV[i,i]*COV[j,j])</span>
<span class="comments">;           or equivalently, in vector notation,</span>
<span class="comments">;                  PCOR = COV / (PERROR # PERROR)</span>
<span class="comments">;</span>
<span class="comments">;           If NOCOVAR is set or MPFIT terminated abnormally, then</span>
<span class="comments">;           COVAR is set to a scalar with value !VALUES.D_NAN.</span>
<span class="comments">;</span>
<span class="comments">;   DOF - number of degrees of freedom, computed as</span>
<span class="comments">;             DOF = N_ELEMENTS(DEVIATES) - NFREE</span>
<span class="comments">;         Note that this doesn't account for pegged parameters (see</span>
<span class="comments">;         NPEGGED).</span>
<span class="comments">;</span>
<span class="comments">;   ERRMSG - a string error or warning message is returned.</span>
<span class="comments">;</span>
<span class="comments">;   EXTERNAL_FVEC - upon input, the function values, evaluated at</span>
<span class="comments">;                   START_PARAMS.  This should be an M-vector, where M</span>
<span class="comments">;                   is the number of data points.</span>
<span class="comments">;</span>
<span class="comments">;   EXTERNAL_FJAC - upon input, the Jacobian array of partial</span>
<span class="comments">;                   derivative values.  This should be a M x N array,</span>
<span class="comments">;                   where M is the number of data points and N is the</span>
<span class="comments">;                   number of parameters.  NOTE: that all FIXED or</span>
<span class="comments">;                   TIED parameters must *not* be included in this</span>
<span class="comments">;                   array.</span>
<span class="comments">;</span>
<span class="comments">;   EXTERNAL_STATE - a named variable to store MPFIT-related state</span>
<span class="comments">;                    information between iterations (used in input and</span>
<span class="comments">;                    output to MPFIT).  The user must not manipulate</span>
<span class="comments">;                    or discard this data until the final iteration is</span>
<span class="comments">;                    performed.</span>
<span class="comments">;</span>
<span class="comments">;   FASTNORM - set this keyword to select a faster algorithm to</span>
<span class="comments">;              compute sum-of-square values internally.  For systems</span>
<span class="comments">;              with large numbers of data points, the standard</span>
<span class="comments">;              algorithm can become prohibitively slow because it</span>
<span class="comments">;              cannot be vectorized well.  By setting this keyword,</span>
<span class="comments">;              MPFIT will run faster, but it will be more prone to</span>
<span class="comments">;              floating point overflows and underflows.  Thus, setting</span>
<span class="comments">;              this keyword may sacrifice some stability in the</span>
<span class="comments">;              fitting process.</span>
<span class="comments">;              </span>
<span class="comments">;   FTOL - a nonnegative input variable. Termination occurs when both</span>
<span class="comments">;          the actual and predicted relative reductions in the sum of</span>
<span class="comments">;          squares are at most FTOL (and STATUS is accordingly set to</span>
<span class="comments">;          1 or 3).  Therefore, FTOL measures the relative error</span>
<span class="comments">;          desired in the sum of squares.  Default: 1D-10</span>
<span class="comments">;</span>
<span class="comments">;   FUNCTARGS - A structure which contains the parameters to be passed</span>
<span class="comments">;               to the user-supplied function specified by MYFUNCT via</span>
<span class="comments">;               the _EXTRA mechanism.  This is the way you can pass</span>
<span class="comments">;               additional data to your user-supplied function without</span>
<span class="comments">;               using common blocks.</span>
<span class="comments">;</span>
<span class="comments">;               Consider the following example:</span>
<span class="comments">;                if FUNCTARGS = { XVAL:[1.D,2,3], YVAL:[1.D,4,9],</span>
<span class="comments">;                                 ERRVAL:[1.D,1,1] }</span>
<span class="comments">;                then the user supplied function should be declared</span>
<span class="comments">;                like this:</span>
<span class="comments">;                FUNCTION MYFUNCT, P, XVAL=x, YVAL=y, ERRVAL=err</span>
<span class="comments">;</span>
<span class="comments">;               By default, no extra parameters are passed to the</span>
<span class="comments">;               user-supplied function, but your function should</span>
<span class="comments">;               accept *at least* one keyword parameter.  [ This is to</span>
<span class="comments">;               accomodate a limitation in IDL's _EXTRA</span>
<span class="comments">;               parameter-passing mechanism. ]</span>
<span class="comments">;</span>
<span class="comments">;   GTOL - a nonnegative input variable. Termination occurs when the</span>
<span class="comments">;          cosine of the angle between fvec and any column of the</span>
<span class="comments">;          jacobian is at most GTOL in absolute value (and STATUS is</span>
<span class="comments">;          accordingly set to 4). Therefore, GTOL measures the</span>
<span class="comments">;          orthogonality desired between the function vector and the</span>
<span class="comments">;          columns of the jacobian.  Default: 1D-10</span>
<span class="comments">;</span>
<span class="comments">;   ITERARGS - The keyword arguments to be passed to ITERPROC via the</span>
<span class="comments">;              _EXTRA mechanism.  This should be a structure, and is</span>
<span class="comments">;              similar in operation to FUNCTARGS.</span>
<span class="comments">;              Default: no arguments are passed.</span>
<span class="comments">;</span>
<span class="comments">;   ITERPRINT - The name of an IDL procedure, equivalent to PRINT,</span>
<span class="comments">;               that ITERPROC will use to render output.  ITERPRINT</span>
<span class="comments">;               should be able to accept at least four positional</span>
<span class="comments">;               arguments.  In addition, it should be able to accept</span>
<span class="comments">;               the standard FORMAT keyword for output formatting; and</span>
<span class="comments">;               the UNIT keyword, to redirect output to a logical file</span>
<span class="comments">;               unit (default should be UNIT=1, standard output).</span>
<span class="comments">;               These keywords are passed using the ITERARGS keyword</span>
<span class="comments">;               above.  The ITERPRINT procedure must accept the _EXTRA</span>
<span class="comments">;               keyword.  </span>
<span class="comments">;               NOTE: that much formatting can be handled with the </span>
<span class="comments">;                     MPPRINT and MPFORMAT tags.</span>
<span class="comments">;               Default: 'MPFIT_DEFPRINT' (default internal formatter)</span>
<span class="comments">;</span>
<span class="comments">;   ITERPROC - The name of a procedure to be called upon each NPRINT</span>
<span class="comments">;              iteration of the MPFIT routine.  ITERPROC is always</span>
<span class="comments">;              called in the final iteration.  It should be declared</span>
<span class="comments">;              in the following way:</span>
<span class="comments">;</span>
<span class="comments">;              PRO ITERPROC, MYFUNCT, p, iter, fnorm, FUNCTARGS=fcnargs, $</span>
<span class="comments">;                PARINFO=parinfo, QUIET=quiet, DOF=dof, PFORMAT=pformat, $</span>
<span class="comments">;                UNIT=unit, ...</span>
<span class="comments">;                ; perform custom iteration update</span>
<span class="comments">;              END</span>
<span class="comments">;         </span>
<span class="comments">;              ITERPROC must either accept all three keyword</span>
<span class="comments">;              parameters (FUNCTARGS, PARINFO and QUIET), or at least</span>
<span class="comments">;              accept them via the _EXTRA keyword.</span>
<span class="comments">;          </span>
<span class="comments">;              MYFUNCT is the user-supplied function to be minimized,</span>
<span class="comments">;              P is the current set of model parameters, ITER is the</span>
<span class="comments">;              iteration number, and FUNCTARGS are the arguments to be</span>
<span class="comments">;              passed to MYFUNCT.  FNORM should be the chi-squared</span>
<span class="comments">;              value.  QUIET is set when no textual output should be</span>
<span class="comments">;              printed.  DOF is the number of degrees of freedom,</span>
<span class="comments">;              normally the number of points less the number of free</span>
<span class="comments">;              parameters.  See below for documentation of PARINFO.</span>
<span class="comments">;              PFORMAT is the default parameter value format.  UNIT is</span>
<span class="comments">;              passed on to the ITERPRINT procedure, and should</span>
<span class="comments">;              indicate the file unit where log output will be sent</span>
<span class="comments">;              (default: standard output).</span>
<span class="comments">;</span>
<span class="comments">;              In implementation, ITERPROC can perform updates to the</span>
<span class="comments">;              terminal or graphical user interface, to provide</span>
<span class="comments">;              feedback while the fit proceeds.  If the fit is to be</span>
<span class="comments">;              stopped for any reason, then ITERPROC should set the</span>
<span class="comments">;              common block variable ERROR_CODE to negative value</span>
<span class="comments">;              between -15 and -1 (see MPFIT_ERROR common block</span>
<span class="comments">;              below).  In principle, ITERPROC should probably not</span>
<span class="comments">;              modify the parameter values, because it may interfere</span>
<span class="comments">;              with the algorithm's stability.  In practice it is</span>
<span class="comments">;              allowed.</span>
<span class="comments">;</span>
<span class="comments">;              Default: an internal routine is used to print the</span>
<span class="comments">;                       parameter values.</span>
<span class="comments">;</span>
<span class="comments">;   ITERSTOP - Set this keyword if you wish to be able to stop the</span>
<span class="comments">;              fitting by hitting the predefined ITERKEYSTOP key on</span>
<span class="comments">;              the keyboard.  This only works if you use the default</span>
<span class="comments">;              ITERPROC.</span>
<span class="comments">;</span>
<span class="comments">;   ITERKEYSTOP - A keyboard key which will halt the fit (and if</span>
<span class="comments">;                 ITERSTOP is set and the default ITERPROC is used).</span>
<span class="comments">;                 ITERSTOPKEY may either be a one-character string</span>
<span class="comments">;                 with the desired key, or a scalar integer giving the</span>
<span class="comments">;                 ASCII code of the desired key.  </span>
<span class="comments">;                 Default: 7b (control-g)</span>
<span class="comments">;</span>
<span class="comments">;                 NOTE: the default value of ASCI 7 (control-G) cannot</span>
<span class="comments">;                 be read in some windowing environments, so you must</span>
<span class="comments">;                 change to a printable character like 'q'.</span>
<span class="comments">;</span>
<span class="comments">;   MAXITER - The maximum number of iterations to perform.  If the</span>
<span class="comments">;             number is exceeded, then the STATUS value is set to 5</span>
<span class="comments">;             and MPFIT returns.</span>
<span class="comments">;             Default: 200 iterations</span>
<span class="comments">;</span>
<span class="comments">;   MIN_VERSION - The minimum requested version number.  This must be</span>
<span class="comments">;                 a scalar string of the form returned by the VERSION</span>
<span class="comments">;                 keyword.  If the current version of MPFIT does not</span>
<span class="comments">;                 satisfy the minimum requested version number, then,</span>
<span class="comments">;                    MPFIT(/query, min_version='...') returns 0</span>
<span class="comments">;                    MPFIT(...) returns NAN</span>
<span class="comments">;                 Default: no version number check</span>
<span class="comments">;                 NOTE: MIN_VERSION was added in MPFIT version 1.70</span>
<span class="comments">;</span>
<span class="comments">;   NFEV - the number of MYFUNCT function evaluations performed.</span>
<span class="comments">;</span>
<span class="comments">;   NFREE - the number of free parameters in the fit.  This includes</span>
<span class="comments">;           parameters which are not FIXED and not TIED, but it does</span>
<span class="comments">;           include parameters which are pegged at LIMITS.</span>
<span class="comments">;</span>
<span class="comments">;   NITER - the number of iterations completed.</span>
<span class="comments">;</span>
<span class="comments">;   NOCATCH - if set, then MPFIT will not perform any error trapping.</span>
<span class="comments">;             By default (not set), MPFIT will trap errors and report</span>
<span class="comments">;             them to the caller.  This keyword will typically be used</span>
<span class="comments">;             for debugging.</span>
<span class="comments">;</span>
<span class="comments">;   NOCOVAR - set this keyword to prevent the calculation of the</span>
<span class="comments">;             covariance matrix before returning (see COVAR)</span>
<span class="comments">;</span>
<span class="comments">;   NPEGGED - the number of free parameters which are pegged at a</span>
<span class="comments">;             LIMIT.</span>
<span class="comments">;</span>
<span class="comments">;   NPRINT - The frequency with which ITERPROC is called.  A value of</span>
<span class="comments">;            1 indicates that ITERPROC is called with every iteration,</span>
<span class="comments">;            while 2 indicates every other iteration, etc.  Be aware</span>
<span class="comments">;            that several Levenberg-Marquardt attempts can be made in</span>
<span class="comments">;            a single iteration.  Also, the ITERPROC is *always*</span>
<span class="comments">;            called for the final iteration, regardless of the</span>
<span class="comments">;            iteration number.</span>
<span class="comments">;            Default value: 1</span>
<span class="comments">;</span>
<span class="comments">;   PARINFO - A one-dimensional array of structures.</span>
<span class="comments">;             Provides a mechanism for more sophisticated constraints</span>
<span class="comments">;             to be placed on parameter values.  When PARINFO is not</span>
<span class="comments">;             passed, then it is assumed that all parameters are free</span>
<span class="comments">;             and unconstrained.  Values in PARINFO are never </span>
<span class="comments">;             modified during a call to MPFIT.</span>
<span class="comments">;</span>
<span class="comments">;             See description above for the structure of PARINFO.</span>
<span class="comments">;</span>
<span class="comments">;             Default value:  all parameters are free and unconstrained.</span>
<span class="comments">;</span>
<span class="comments">;   PERROR - The formal 1-sigma errors in each parameter, computed</span>
<span class="comments">;            from the covariance matrix.  If a parameter is held</span>
<span class="comments">;            fixed, or if it touches a boundary, then the error is</span>
<span class="comments">;            reported as zero.</span>
<span class="comments">;</span>
<span class="comments">;            If the fit is unweighted (i.e. no errors were given, or</span>
<span class="comments">;            the weights were uniformly set to unity), then PERROR</span>
<span class="comments">;            will probably not represent the true parameter</span>
<span class="comments">;            uncertainties.  </span>
<span class="comments">;</span>
<span class="comments">;            *If* you can assume that the true reduced chi-squared</span>
<span class="comments">;            value is unity -- meaning that the fit is implicitly</span>
<span class="comments">;            assumed to be of good quality -- then the estimated</span>
<span class="comments">;            parameter uncertainties can be computed by scaling PERROR</span>
<span class="comments">;            by the measured chi-squared value.</span>
<span class="comments">;</span>
<span class="comments">;              DOF     = N_ELEMENTS(X) - N_ELEMENTS(PARMS) ; deg of freedom</span>
<span class="comments">;              PCERROR = PERROR * SQRT(BESTNORM / DOF)   ; scaled uncertainties</span>
<span class="comments">;</span>
<span class="comments">;   QUERY - if set, then MPFIT() will return immediately with one of</span>
<span class="comments">;           the following values:</span>
<span class="comments">;                 1 - if MIN_VERSION is not set</span>
<span class="comments">;                 1 - if MIN_VERSION is set and MPFIT satisfies the minimum</span>
<span class="comments">;                 0 - if MIN_VERSION is set and MPFIT does not satisfy it</span>
<span class="comments">;           The VERSION output keyword is always set upon return.</span>
<span class="comments">;           Default: not set.</span>
<span class="comments">;</span>
<span class="comments">;   QUIET - set this keyword when no textual output should be printed</span>
<span class="comments">;           by MPFIT</span>
<span class="comments">;</span>
<span class="comments">;   RESDAMP - a scalar number, indicating the cut-off value of</span>
<span class="comments">;             residuals where "damping" will occur.  Residuals with</span>
<span class="comments">;             magnitudes greater than this number will be replaced by</span>
<span class="comments">;             their logarithm.  This partially mitigates the so-called</span>
<span class="comments">;             large residual problem inherent in least-squares solvers</span>
<span class="comments">;             (as for the test problem CURVI, http://www.maxthis.com/-</span>
<span class="comments">;             curviex.htm).  A value of 0 indicates no damping.</span>
<span class="comments">;             Default: 0</span>
<span class="comments">;</span>
<span class="comments">;             Note: RESDAMP doesn't work with AUTODERIV=0</span>
<span class="comments">;</span>
<span class="comments">;   STATUS - an integer status code is returned.  All values greater</span>
<span class="comments">;            than zero can represent success (however STATUS EQ 5 may</span>
<span class="comments">;            indicate failure to converge).  It can have one of the</span>
<span class="comments">;            following values:</span>
<span class="comments">;</span>
<span class="comments">;        -18  a fatal execution error has occurred.  More information</span>
<span class="comments">;             may be available in the ERRMSG string.</span>
<span class="comments">;</span>
<span class="comments">;        -16  a parameter or function value has become infinite or an</span>
<span class="comments">;             undefined number.  This is usually a consequence of</span>
<span class="comments">;             numerical overflow in the user's model function, which</span>
<span class="comments">;             must be avoided.</span>
<span class="comments">;</span>
<span class="comments">;        -15 to -1 </span>
<span class="comments">;             these are error codes that either MYFUNCT or ITERPROC</span>
<span class="comments">;             may return to terminate the fitting process (see</span>
<span class="comments">;             description of MPFIT_ERROR common below).  If either</span>
<span class="comments">;             MYFUNCT or ITERPROC set ERROR_CODE to a negative number,</span>
<span class="comments">;             then that number is returned in STATUS.  Values from -15</span>
<span class="comments">;             to -1 are reserved for the user functions and will not</span>
<span class="comments">;             clash with MPFIT.</span>
<span class="comments">;</span>
<span class="comments">;	   0  improper input parameters.</span>
<span class="comments">;         </span>
<span class="comments">;	   1  both actual and predicted relative reductions</span>
<span class="comments">;	      in the sum of squares are at most FTOL.</span>
<span class="comments">;         </span>
<span class="comments">;	   2  relative error between two consecutive iterates</span>
<span class="comments">;	      is at most XTOL</span>
<span class="comments">;         </span>
<span class="comments">;	   3  conditions for STATUS = 1 and STATUS = 2 both hold.</span>
<span class="comments">;         </span>
<span class="comments">;	   4  the cosine of the angle between fvec and any</span>
<span class="comments">;	      column of the jacobian is at most GTOL in</span>
<span class="comments">;	      absolute value.</span>
<span class="comments">;         </span>
<span class="comments">;	   5  the maximum number of iterations has been reached</span>
<span class="comments">;         </span>
<span class="comments">;	   6  FTOL is too small. no further reduction in</span>
<span class="comments">;	      the sum of squares is possible.</span>
<span class="comments">;         </span>
<span class="comments">;	   7  XTOL is too small. no further improvement in</span>
<span class="comments">;	      the approximate solution x is possible.</span>
<span class="comments">;         </span>
<span class="comments">;	   8  GTOL is too small. fvec is orthogonal to the</span>
<span class="comments">;	      columns of the jacobian to machine precision.</span>
<span class="comments">;</span>
<span class="comments">;          9  A successful single iteration has been completed, and</span>
<span class="comments">;             the user must supply another "EXTERNAL" evaluation of</span>
<span class="comments">;             the function and its derivatives.  This status indicator</span>
<span class="comments">;             is neither an error nor a convergence indicator.</span>
<span class="comments">;</span>
<span class="comments">;   VERSION - upon return, VERSION will be set to the MPFIT internal</span>
<span class="comments">;             version number.  The version number will be a string of</span>
<span class="comments">;             the form "X.Y" where X is a major revision number and Y</span>
<span class="comments">;             is a minor revision number.</span>
<span class="comments">;             NOTE: the VERSION keyword was not present before </span>
<span class="comments">;               MPFIT version number 1.70, therefore, callers must </span>
<span class="comments">;               use exception handling when using this keyword.</span>
<span class="comments">;</span>
<span class="comments">;   XTOL - a nonnegative input variable. Termination occurs when the</span>
<span class="comments">;          relative error between two consecutive iterates is at most</span>
<span class="comments">;          XTOL (and STATUS is accordingly set to 2 or 3).  Therefore,</span>
<span class="comments">;          XTOL measures the relative error desired in the approximate</span>
<span class="comments">;          solution.  Default: 1D-10</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; EXAMPLE:</span>
<span class="comments">;</span>
<span class="comments">;   p0 = [5.7D, 2.2, 500., 1.5, 2000.]</span>
<span class="comments">;   fa = {X:x, Y:y, ERR:err}</span>
<span class="comments">;   p = mpfit('MYFUNCT', p0, functargs=fa)</span>
<span class="comments">;</span>
<span class="comments">;   Minimizes sum of squares of MYFUNCT.  MYFUNCT is called with the X,</span>
<span class="comments">;   Y, and ERR keyword parameters that are given by FUNCTARGS.  The</span>
<span class="comments">;   resulting parameter values are returned in p.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; COMMON BLOCKS:</span>
<span class="comments">;</span>
<span class="comments">;   COMMON MPFIT_ERROR, ERROR_CODE</span>
<span class="comments">;</span>
<span class="comments">;     User routines may stop the fitting process at any time by</span>
<span class="comments">;     setting an error condition.  This condition may be set in either</span>
<span class="comments">;     the user's model computation routine (MYFUNCT), or in the</span>
<span class="comments">;     iteration procedure (ITERPROC).</span>
<span class="comments">;</span>
<span class="comments">;     To stop the fitting, the above common block must be declared,</span>
<span class="comments">;     and ERROR_CODE must be set to a negative number.  After the user</span>
<span class="comments">;     procedure or function returns, MPFIT checks the value of this</span>
<span class="comments">;     common block variable and exits immediately if the error</span>
<span class="comments">;     condition has been set.  This value is also returned in the</span>
<span class="comments">;     STATUS keyword: values of -1 through -15 are reserved error</span>
<span class="comments">;     codes for the user routines.  By default the value of ERROR_CODE</span>
<span class="comments">;     is zero, indicating a successful function/procedure call.</span>
<span class="comments">;</span>
<span class="comments">;   COMMON MPFIT_PROFILE</span>
<span class="comments">;   COMMON MPFIT_MACHAR</span>
<span class="comments">;   COMMON MPFIT_CONFIG</span>
<span class="comments">;</span>
<span class="comments">;     These are undocumented common blocks are used internally by</span>
<span class="comments">;     MPFIT and may change in future implementations.</span>
<span class="comments">;</span>
<span class="comments">; THEORY OF OPERATION:</span>
<span class="comments">;</span>
<span class="comments">;   There are many specific strategies for function minimization.  One</span>
<span class="comments">;   very popular technique is to use function gradient information to</span>
<span class="comments">;   realize the local structure of the function.  Near a local minimum</span>
<span class="comments">;   the function value can be taylor expanded about x0 as follows:</span>
<span class="comments">;</span>
<span class="comments">;      f(x) = f(x0) + f'(x0) . (x-x0) + (1/2) (x-x0) . f''(x0) . (x-x0)</span>
<span class="comments">;             -----   ---------------   -------------------------------  (1)</span>
<span class="comments">;     Order    0th          1st                      2nd</span>
<span class="comments">;</span>
<span class="comments">;   Here f'(x) is the gradient vector of f at x, and f''(x) is the</span>
<span class="comments">;   Hessian matrix of second derivatives of f at x.  The vector x is</span>
<span class="comments">;   the set of function parameters, not the measured data vector.  One</span>
<span class="comments">;   can find the minimum of f, f(xm) using Newton's method, and</span>
<span class="comments">;   arrives at the following linear equation:</span>
<span class="comments">;</span>
<span class="comments">;      f''(x0) . (xm-x0) = - f'(x0)                            (2)</span>
<span class="comments">;</span>
<span class="comments">;   If an inverse can be found for f''(x0) then one can solve for</span>
<span class="comments">;   (xm-x0), the step vector from the current position x0 to the new</span>
<span class="comments">;   projected minimum.  Here the problem has been linearized (ie, the</span>
<span class="comments">;   gradient information is known to first order).  f''(x0) is</span>
<span class="comments">;   symmetric n x n matrix, and should be positive definite.</span>
<span class="comments">;</span>
<span class="comments">;   The Levenberg - Marquardt technique is a variation on this theme.</span>
<span class="comments">;   It adds an additional diagonal term to the equation which may aid the</span>
<span class="comments">;   convergence properties:</span>
<span class="comments">;</span>
<span class="comments">;      (f''(x0) + nu I) . (xm-x0) = -f'(x0)                  (2a)</span>
<span class="comments">;</span>
<span class="comments">;   where I is the identity matrix.  When nu is large, the overall</span>
<span class="comments">;   matrix is diagonally dominant, and the iterations follow steepest</span>
<span class="comments">;   descent.  When nu is small, the iterations are quadratically</span>
<span class="comments">;   convergent.</span>
<span class="comments">;</span>
<span class="comments">;   In principle, if f''(x0) and f'(x0) are known then xm-x0 can be</span>
<span class="comments">;   determined.  However the Hessian matrix is often difficult or</span>
<span class="comments">;   impossible to compute.  The gradient f'(x0) may be easier to</span>
<span class="comments">;   compute, if even by finite difference techniques.  So-called</span>
<span class="comments">;   quasi-Newton techniques attempt to successively estimate f''(x0)</span>
<span class="comments">;   by building up gradient information as the iterations proceed.</span>
<span class="comments">;</span>
<span class="comments">;   In the least squares problem there are further simplifications</span>
<span class="comments">;   which assist in solving eqn (2).  The function to be minimized is</span>
<span class="comments">;   a sum of squares:</span>
<span class="comments">;</span>
<span class="comments">;       f = Sum(hi^2)                                         (3)</span>
<span class="comments">;</span>
<span class="comments">;   where hi is the ith residual out of m residuals as described</span>
<span class="comments">;   above.  This can be substituted back into eqn (2) after computing</span>
<span class="comments">;   the derivatives:</span>
<span class="comments">;</span>
<span class="comments">;       f'  = 2 Sum(hi  hi')     </span>
<span class="comments">;       f'' = 2 Sum(hi' hj') + 2 Sum(hi hi'')                (4)</span>
<span class="comments">;</span>
<span class="comments">;   If one assumes that the parameters are already close enough to a</span>
<span class="comments">;   minimum, then one typically finds that the second term in f'' is</span>
<span class="comments">;   negligible [or, in any case, is too difficult to compute].  Thus,</span>
<span class="comments">;   equation (2) can be solved, at least approximately, using only</span>
<span class="comments">;   gradient information.</span>
<span class="comments">;</span>
<span class="comments">;   In matrix notation, the combination of eqns (2) and (4) becomes:</span>
<span class="comments">;</span>
<span class="comments">;        hT' . h' . dx = - hT' . h                          (5)</span>
<span class="comments">;</span>
<span class="comments">;   Where h is the residual vector (length m), hT is its transpose, h'</span>
<span class="comments">;   is the Jacobian matrix (dimensions n x m), and dx is (xm-x0).  The</span>
<span class="comments">;   user function supplies the residual vector h, and in some cases h'</span>
<span class="comments">;   when it is not found by finite differences (see MPFIT_FDJAC2,</span>
<span class="comments">;   which finds h and hT').  Even if dx is not the best absolute step</span>
<span class="comments">;   to take, it does provide a good estimate of the best *direction*,</span>
<span class="comments">;   so often a line minimization will occur along the dx vector</span>
<span class="comments">;   direction.</span>
<span class="comments">;</span>
<span class="comments">;   The method of solution employed by MINPACK is to form the Q . R</span>
<span class="comments">;   factorization of h', where Q is an orthogonal matrix such that QT .</span>
<span class="comments">;   Q = I, and R is upper right triangular.  Using h' = Q . R and the</span>
<span class="comments">;   ortogonality of Q, eqn (5) becomes</span>
<span class="comments">;</span>
<span class="comments">;        (RT . QT) . (Q . R) . dx = - (RT . QT) . h</span>
<span class="comments">;                     RT . R . dx = - RT . QT . h         (6)</span>
<span class="comments">;                          R . dx = - QT . h</span>
<span class="comments">;</span>
<span class="comments">;   where the last statement follows because R is upper triangular.</span>
<span class="comments">;   Here, R, QT and h are known so this is a matter of solving for dx.</span>
<span class="comments">;   The routine MPFIT_QRFAC provides the QR factorization of h, with</span>
<span class="comments">;   pivoting, and MPFIT_QRSOL;V provides the solution for dx.</span>
<span class="comments">;   </span>
<span class="comments">; REFERENCES:</span>
<span class="comments">;</span>
<span class="comments">;   Markwardt, C. B. 2008, "Non-Linear Least Squares Fitting in IDL</span>
<span class="comments">;     with MPFIT," in proc. Astronomical Data Analysis Software and</span>
<span class="comments">;     Systems XVIII, Quebec, Canada, ASP Conference Series, Vol. XXX, eds.</span>
<span class="comments">;     D. Bohlender, P. Dowler & D. Durand (Astronomical Society of the</span>
<span class="comments">;     Pacific: San Francisco), p. 251-254 (ISBN: 978-1-58381-702-5)</span>
<span class="comments">;       http://arxiv.org/abs/0902.2850</span>
<span class="comments">;       Link to NASA ADS: http://adsabs.harvard.edu/abs/2009ASPC..411..251M</span>
<span class="comments">;       Link to ASP: http://aspbooks.org/a/volumes/table_of_contents/411</span>
<span class="comments">;</span>
<span class="comments">;   Refer to the MPFIT website as:</span>
<span class="comments">;       http://purl.com/net/mpfit</span>
<span class="comments">;</span>
<span class="comments">;   MINPACK-1 software, by Jorge More' et al, available from netlib.</span>
<span class="comments">;     http://www.netlib.org/</span>
<span class="comments">;</span>
<span class="comments">;   "Optimization Software Guide," Jorge More' and Stephen Wright, </span>
<span class="comments">;     SIAM, *Frontiers in Applied Mathematics*, Number 14.</span>
<span class="comments">;     (ISBN: 978-0-898713-22-0)</span>
<span class="comments">;</span>
<span class="comments">;   More', J. 1978, "The Levenberg-Marquardt Algorithm: Implementation</span>
<span class="comments">;     and Theory," in Numerical Analysis, vol. 630, ed. G. A. Watson</span>
<span class="comments">;     (Springer-Verlag: Berlin), p. 105 (DOI: 10.1007/BFb0067690 )</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">;   Translated from MINPACK-1 in FORTRAN, Apr-Jul 1998, CM</span>
<span class="comments">;   Fixed bug in parameter limits (x vs xnew), 04 Aug 1998, CM</span>
<span class="comments">;   Added PERROR keyword, 04 Aug 1998, CM</span>
<span class="comments">;   Added COVAR keyword, 20 Aug 1998, CM</span>
<span class="comments">;   Added NITER output keyword, 05 Oct 1998</span>
<span class="comments">;      D.L Windt, Bell Labs, windt@bell-labs.com;</span>
<span class="comments">;   Made each PARINFO component optional, 05 Oct 1998 CM</span>
<span class="comments">;   Analytical derivatives allowed via AUTODERIVATIVE keyword, 09 Nov 1998</span>
<span class="comments">;   Parameter values can be tied to others, 09 Nov 1998</span>
<span class="comments">;   Fixed small bugs (Wayne Landsman), 24 Nov 1998</span>
<span class="comments">;   Added better exception error reporting, 24 Nov 1998 CM</span>
<span class="comments">;   Cosmetic documentation changes, 02 Jan 1999 CM</span>
<span class="comments">;   Changed definition of ITERPROC to be consistent with TNMIN, 19 Jan 1999 CM</span>
<span class="comments">;   Fixed bug when AUTDERIVATIVE=0.  Incorrect sign, 02 Feb 1999 CM</span>
<span class="comments">;   Added keyboard stop to MPFIT_DEFITER, 28 Feb 1999 CM</span>
<span class="comments">;   Cosmetic documentation changes, 14 May 1999 CM</span>
<span class="comments">;   IDL optimizations for speed & FASTNORM keyword, 15 May 1999 CM</span>
<span class="comments">;   Tried a faster version of mpfit_enorm, 30 May 1999 CM</span>
<span class="comments">;   Changed web address to cow.physics.wisc.edu, 14 Jun 1999 CM</span>
<span class="comments">;   Found malformation of FDJAC in MPFIT for 1 parm, 03 Aug 1999 CM</span>
<span class="comments">;   Factored out user-function call into MPFIT_CALL.  It is possible,</span>
<span class="comments">;     but currently disabled, to call procedures.  The calling format</span>
<span class="comments">;     is similar to CURVEFIT, 25 Sep 1999, CM</span>
<span class="comments">;   Slightly changed mpfit_tie to be less intrusive, 25 Sep 1999, CM</span>
<span class="comments">;   Fixed some bugs associated with tied parameters in mpfit_fdjac, 25</span>
<span class="comments">;     Sep 1999, CM</span>
<span class="comments">;   Reordered documentation; now alphabetical, 02 Oct 1999, CM</span>
<span class="comments">;   Added QUERY keyword for more robust error detection in drivers, 29</span>
<span class="comments">;     Oct 1999, CM</span>
<span class="comments">;   Documented PERROR for unweighted fits, 03 Nov 1999, CM</span>
<span class="comments">;   Split out MPFIT_RESETPROF to aid in profiling, 03 Nov 1999, CM</span>
<span class="comments">;   Some profiling and speed optimization, 03 Nov 1999, CM</span>
<span class="comments">;     Worst offenders, in order: fdjac2, qrfac, qrsolv, enorm.</span>
<span class="comments">;     fdjac2 depends on user function, qrfac and enorm seem to be</span>
<span class="comments">;     fully optimized.  qrsolv probably could be tweaked a little, but</span>
<span class="comments">;     is still &lt;10% of total compute time.</span>
<span class="comments">;   Made sure that !err was set to 0 in MPFIT_DEFITER, 10 Jan 2000, CM</span>
<span class="comments">;   Fixed small inconsistency in setting of QANYLIM, 28 Jan 2000, CM</span>
<span class="comments">;   Added PARINFO field RELSTEP, 28 Jan 2000, CM</span>
<span class="comments">;   Converted to MPFIT_ERROR common block for indicating error</span>
<span class="comments">;     conditions, 28 Jan 2000, CM</span>
<span class="comments">;   Corrected scope of MPFIT_ERROR common block, CM, 07 Mar 2000</span>
<span class="comments">;   Minor speed improvement in MPFIT_ENORM, CM 26 Mar 2000</span>
<span class="comments">;   Corrected case where ITERPROC changed parameter values and</span>
<span class="comments">;     parameter values were TIED, CM 26 Mar 2000</span>
<span class="comments">;   Changed MPFIT_CALL to modify NFEV automatically, and to support</span>
<span class="comments">;     user procedures more, CM 26 Mar 2000</span>
<span class="comments">;   Copying permission terms have been liberalized, 26 Mar 2000, CM</span>
<span class="comments">;   Catch zero value of zero a(j,lj) in MPFIT_QRFAC, 20 Jul 2000, CM</span>
<span class="comments">;      (thanks to David Schlegel &lt;schlegel@astro.princeton.edu>)</span>
<span class="comments">;   MPFIT_SETMACHAR is called only once at init; only one common block</span>
<span class="comments">;     is created (MPFIT_MACHAR); it is now a structure; removed almost</span>
<span class="comments">;     all CHECK_MATH calls for compatibility with IDL5 and !EXCEPT;</span>
<span class="comments">;     profiling data is now in a structure too; noted some</span>
<span class="comments">;     mathematical discrepancies in Linux IDL5.0, 17 Nov 2000, CM</span>
<span class="comments">;   Some significant changes.  New PARINFO fields: MPSIDE, MPMINSTEP,</span>
<span class="comments">;     MPMAXSTEP.  Improved documentation.  Now PTIED constraints are</span>
<span class="comments">;     maintained in the MPCONFIG common block.  A new procedure to</span>
<span class="comments">;     parse PARINFO fields.  FDJAC2 now computes a larger variety of</span>
<span class="comments">;     one-sided and two-sided finite difference derivatives.  NFEV is</span>
<span class="comments">;     stored in the MPCONFIG common now.  17 Dec 2000, CM</span>
<span class="comments">;   Added check that PARINFO and XALL have same size, 29 Dec 2000 CM</span>
<span class="comments">;   Don't call function in TERMINATE when there is an error, 05 Jan</span>
<span class="comments">;     2000</span>
<span class="comments">;   Check for float vs. double discrepancies; corrected implementation</span>
<span class="comments">;     of MIN/MAXSTEP, which I still am not sure of, but now at least</span>
<span class="comments">;     the correct behavior occurs *without* it, CM 08 Jan 2001</span>
<span class="comments">;   Added SCALE_FCN keyword, to allow for scaling, as for the CASH</span>
<span class="comments">;     statistic; added documentation about the theory of operation,</span>
<span class="comments">;     and under the QR factorization; slowly I'm beginning to</span>
<span class="comments">;     understand the bowels of this algorithm, CM 10 Jan 2001</span>
<span class="comments">;   Remove MPMINSTEP field of PARINFO, for now at least, CM 11 Jan</span>
<span class="comments">;     2001</span>
<span class="comments">;   Added RESDAMP keyword, CM, 14 Jan 2001</span>
<span class="comments">;   Tried to improve the DAMP handling a little, CM, 13 Mar 2001</span>
<span class="comments">;   Corrected .PARNAME behavior in _DEFITER, CM, 19 Mar 2001</span>
<span class="comments">;   Added checks for parameter and function overflow; a new STATUS</span>
<span class="comments">;     value to reflect this; STATUS values of -15 to -1 are reserved</span>
<span class="comments">;     for user function errors, CM, 03 Apr 2001</span>
<span class="comments">;   DAMP keyword is now a TANH, CM, 03 Apr 2001</span>
<span class="comments">;   Added more error checking of float vs. double, CM, 07 Apr 2001</span>
<span class="comments">;   Fixed bug in handling of parameter lower limits; moved overflow</span>
<span class="comments">;     checking to end of loop, CM, 20 Apr 2001</span>
<span class="comments">;   Failure using GOTO, TERMINATE more graceful if FNORM1 not defined,</span>
<span class="comments">;     CM, 13 Aug 2001</span>
<span class="comments">;   Add MPPRINT tag to PARINFO, CM, 19 Nov 2001</span>
<span class="comments">;   Add DOF keyword to DEFITER procedure, and print degrees of</span>
<span class="comments">;     freedom, CM, 28 Nov 2001</span>
<span class="comments">;   Add check to be sure MYFUNCT is a scalar string, CM, 14 Jan 2002</span>
<span class="comments">;   Addition of EXTERNAL_FJAC, EXTERNAL_FVEC keywords; ability to save</span>
<span class="comments">;     fitter's state from one call to the next; allow '(EXTERNAL)'</span>
<span class="comments">;     function name, which implies that user will supply function and</span>
<span class="comments">;     Jacobian at each iteration, CM, 10 Mar 2002</span>
<span class="comments">;   Documented EXTERNAL evaluation code, CM, 10 Mar 2002</span>
<span class="comments">;   Corrected signficant bug in the way that the STEP parameter, and</span>
<span class="comments">;     FIXED parameters interacted (Thanks Andrew Steffl), CM, 02 Apr</span>
<span class="comments">;     2002</span>
<span class="comments">;   Allow COVAR and PERROR keywords to be computed, even in case of</span>
<span class="comments">;     '(EXTERNAL)' function, 26 May 2002</span>
<span class="comments">;   Add NFREE and NPEGGED keywords; compute NPEGGED; compute DOF using</span>
<span class="comments">;     NFREE instead of n_elements(X), thanks to Kristian Kjaer, CM 11</span>
<span class="comments">;     Sep 2002</span>
<span class="comments">;   Hopefully PERROR is all positive now, CM 13 Sep 2002</span>
<span class="comments">;   Documented RELSTEP field of PARINFO (!!), CM, 25 Oct 2002</span>
<span class="comments">;   Error checking to detect missing start pars, CM 12 Apr 2003</span>
<span class="comments">;   Add DOF keyword to return degrees of freedom, CM, 30 June 2003</span>
<span class="comments">;   Always call ITERPROC in the final iteration; add ITERKEYSTOP</span>
<span class="comments">;     keyword, CM, 30 June 2003</span>
<span class="comments">;   Correct bug in MPFIT_LMPAR of singularity handling, which might</span>
<span class="comments">;     likely be fatal for one-parameter fits, CM, 21 Nov 2003</span>
<span class="comments">;     (with thanks to Peter Tuthill for the proper test case)</span>
<span class="comments">;   Minor documentation adjustment, 03 Feb 2004, CM</span>
<span class="comments">;   Correct small error in QR factorization when pivoting; document</span>
<span class="comments">;     the return values of QRFAC when pivoting, 21 May 2004, CM</span>
<span class="comments">;   Add MPFORMAT field to PARINFO, and correct behavior of interaction</span>
<span class="comments">;     between MPPRINT and PARNAME in MPFIT_DEFITERPROC (thanks to Tim</span>
<span class="comments">;     Robishaw), 23 May 2004, CM</span>
<span class="comments">;   Add the ITERPRINT keyword to allow redirecting output, 26 Sep</span>
<span class="comments">;     2004, CM</span>
<span class="comments">;   Correct MAXSTEP behavior in case of a negative parameter, 26 Sep</span>
<span class="comments">;     2004, CM</span>
<span class="comments">;   Fix bug in the parsing of MINSTEP/MAXSTEP, 10 Apr 2005, CM</span>
<span class="comments">;   Fix bug in the handling of upper/lower limits when the limit was</span>
<span class="comments">;     negative (the fitting code would never "stick" to the lower</span>
<span class="comments">;     limit), 29 Jun 2005, CM</span>
<span class="comments">;   Small documentation update for the TIED field, 05 Sep 2005, CM</span>
<span class="comments">;   Convert to IDL 5 array syntax (!), 16 Jul 2006, CM</span>
<span class="comments">;   If MAXITER equals zero, then do the basic parameter checking and</span>
<span class="comments">;     uncertainty analysis, but do not adjust the parameters, 15 Aug</span>
<span class="comments">;     2006, CM</span>
<span class="comments">;   Added documentation, 18 Sep 2006, CM</span>
<span class="comments">;   A few more IDL 5 array syntax changes, 25 Sep 2006, CM</span>
<span class="comments">;   Move STRICTARR compile option inside each function/procedure, 9 Oct 2006</span>
<span class="comments">;   Bug fix for case of MPMAXSTEP and fixed parameters, thanks</span>
<span class="comments">;     to Huib Intema (who found it from the Python translation!), 05 Feb 2007</span>
<span class="comments">;   Similar fix for MPFIT_FDJAC2 and the MPSIDE sidedness of</span>
<span class="comments">;     derivatives, also thanks to Huib Intema, 07 Feb 2007</span>
<span class="comments">;   Clarify documentation on user-function, derivatives, and PARINFO,</span>
<span class="comments">;     27 May 2007</span>
<span class="comments">;   Change the wording of "Analytic Derivatives" to "Explicit </span>
<span class="comments">;     Derivatives" in the documentation, CM, 03 Sep 2007</span>
<span class="comments">;   Further documentation tweaks, CM, 13 Dec 2007</span>
<span class="comments">;   Add COMPATIBILITY section and add credits to copyright, CM, 13 Dec</span>
<span class="comments">;      2007</span>
<span class="comments">;   Document and enforce that START_PARMS and PARINFO are 1-d arrays,</span>
<span class="comments">;      CM, 29 Mar 2008</span>
<span class="comments">;   Previous change for 1-D arrays wasn't correct for</span>
<span class="comments">;      PARINFO.LIMITED/.LIMITS; now fixed, CM, 03 May 2008</span>
<span class="comments">;   Documentation adjustments, CM, 20 Aug 2008</span>
<span class="comments">;   Change some minor FOR-loop variables to type-long, CM, 03 Sep 2008</span>
<span class="comments">;   Change error handling slightly, document NOCATCH keyword,</span>
<span class="comments">;      document error handling in general, CM, 01 Oct 2008</span>
<span class="comments">;   Special case: when either LIMITS is zero, and a parameter pushes</span>
<span class="comments">;      against that limit, the coded that 'pegged' it there would not</span>
<span class="comments">;      work since it was a relative condition; now zero is handled</span>
<span class="comments">;      properly, CM, 08 Nov 2008</span>
<span class="comments">;   Documentation of how TIED interacts with LIMITS, CM, 21 Dec 2008</span>
<span class="comments">;   Better documentation of references, CM, 27 Feb 2009</span>
<span class="comments">;   If MAXITER=0, then be sure to set STATUS=5, which permits the</span>
<span class="comments">;      the covariance matrix to be computed, CM, 14 Apr 2009</span>
<span class="comments">;   Avoid numerical underflow while solving for the LM parameter,</span>
<span class="comments">;      (thanks to Sergey Koposov) CM, 14 Apr 2009</span>
<span class="comments">;   Use individual functions for all possible MPFIT_CALL permutations,</span>
<span class="comments">;      (and make sure the syntax is right) CM, 01 Sep 2009</span>
<span class="comments">;   Correct behavior of MPMAXSTEP when some parameters are frozen,</span>
<span class="comments">;      thanks to Josh Destree, CM, 22 Nov 2009</span>
<span class="comments">;   Update the references section, CM, 22 Nov 2009</span>
<span class="comments">;   1.70 - Add the VERSION and MIN_VERSION keywords, CM, 22 Nov 2009</span>
<span class="comments">;   1.71 - Store pre-calculated revision in common, CM, 23 Nov 2009</span>
<span class="comments">;   1.72-1.74 - Documented alternate method to compute correlation matrix,</span>
<span class="comments">;          CM, 05 Feb 2010</span>
<span class="comments">;   1.75 - Enforce TIED constraints when preparing to terminate the</span>
<span class="comments">;          routine, CM, 2010-06-22</span>
<span class="comments">;</span>
<span class="comments">;  $Id: mpfit.pro,v 1.75 2010/06/22 06:43:35 craigm Exp $</span>
<span class="comments">;-</span>
<span class="comments">; Original MINPACK by More' Garbow and Hillstrom, translated with permission</span>
<span class="comments">; Modifications and enhancements are:</span>
<span class="comments">; Copyright (C) 1997-2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, Craig Markwardt</span>
<span class="comments">; This software is provided as is without any warranty whatsoever.</span>
<span class="comments">; Permission to use, copy, modify, and distribute modified or</span>
<span class="comments">; unmodified copies is granted, provided this copyright and disclaimer</span>
<span class="comments">; are included unchanged.</span>
<span class="comments">;-</span>

<a id="mpfit_dummy:source"></a>pro mpfit_dummy
  <span class="comments">;; Enclose in a procedure so these are not defined in the main level</span>
  COMPILE_OPT strictarr
  FORWARD_FUNCTION mpfit_fdjac2, mpfit_enorm, mpfit_lmpar, mpfit_covar, $
    mpfit, mpfit_call

  COMMON mpfit_error, error_code  <span class="comments">;; For error passing to user function</span>
  COMMON mpfit_config, mpconfig   <span class="comments">;; For internal error configrations</span>
end

<span class="comments">;; Reset profiling registers for another run.  By default, and when</span>
<span class="comments">;; uncommented, the profiling registers simply accumulate.</span>

<a id="mpfit_resetprof:source"></a>pro mpfit_resetprof
  COMPILE_OPT strictarr
  common mpfit_profile, mpfit_profile_vals

  mpfit_profile_vals = { status: 1L, fdjac2: 0D, lmpar: 0D, mpfit: 0D, $
                         qrfac: 0D,  qrsolv: 0D, enorm: 0D}
  return
end

<span class="comments">;; Following are machine constants that can be loaded once.  I have</span>
<span class="comments">;; found that bizarre underflow messages can be produced in each call</span>
<span class="comments">;; to MACHAR(), so this structure minimizes the number of calls to</span>
<span class="comments">;; one.</span>

<a id="mpfit_setmachar:source"></a>pro mpfit_setmachar, double=isdouble
  COMPILE_OPT strictarr
  common mpfit_profile, profvals
  if n_elements(profvals) EQ 0 then mpfit_resetprof

  common mpfit_machar, mpfit_machar_vals

  <span class="comments">;; In earlier versions of IDL, MACHAR itself could produce a load of</span>
  <span class="comments">;; error messages.  We try to mask some of that out here.</span>
  if (!version.release) LT 5 then dummy = check_math(1, 1)

  mch = 0.
  mch = machar(double=keyword_set(isdouble))
  dmachep = mch.eps
  dmaxnum = mch.xmax
  dminnum = mch.xmin
  dmaxlog = alog(mch.xmax)
  dminlog = alog(mch.xmin)
  if keyword_set(isdouble) then $
    dmaxgam = 171.624376956302725D $
  else $
    dmaxgam = 171.624376956302725
  drdwarf = sqrt(dminnum*1.5) * 10
  drgiant = sqrt(dmaxnum) * 0.1

  mpfit_machar_vals = {machep: dmachep, maxnum: dmaxnum, minnum: dminnum, $
                       maxlog: dmaxlog, minlog: dminlog, maxgam: dmaxgam, $
                       rdwarf: drdwarf, rgiant: drgiant}

  if (!version.release) LT 5 then dummy = check_math(0, 0)

  return
end


<span class="comments">; Call user function with no _EXTRA parameters</span>
<a id="mpfit_call_func_noextra:source"></a>function mpfit_call_func_noextra, fcn, x, fjac, _EXTRA=extra
  if n_params() EQ 2 then begin
     return, call_function(fcn, x)
  endif else begin
     return, call_function(fcn, x, fjac)
  endelse
end

<span class="comments">; Call user function with _EXTRA parameters</span>
<a id="mpfit_call_func_extra:source"></a>function mpfit_call_func_extra, fcn, x, fjac, _EXTRA=extra
  if n_params() EQ 2 then begin
     return, call_function(fcn, x, _EXTRA=extra)
  endif else begin
     return, call_function(fcn, x, fjac, _EXTRA=extra)
  endelse
end

<span class="comments">; Call user procedure with no _EXTRA parameters</span>
<a id="mpfit_call_pro_noextra:source"></a>function mpfit_call_pro_noextra, fcn, x, fjac, _EXTRA=extra
  if n_params() EQ 2 then begin
     call_procedure, fcn, x, f
  endif else begin
     call_procedure, fcn, x, f, fjac
  endelse
  return, f
end

<span class="comments">; Call user procedure with _EXTRA parameters</span>
<a id="mpfit_call_pro_extra:source"></a>function mpfit_call_pro_extra, fcn, x, fjac, _EXTRA=extra
  if n_params() EQ 2 then begin
     call_procedure, fcn, x, f, _EXTRA=extra
  endif else begin
     call_procedure, fcn, x, f, fjac, _EXTRA=extra
  endelse
  return, f
end


<span class="comments">;; Call user function or procedure, with _EXTRA or not, with</span>
<span class="comments">;; derivatives or not.</span>
<a id="mpfit_call:source"></a>function mpfit_call, fcn, x, fjac, _EXTRA=extra

  COMPILE_OPT strictarr
  common mpfit_config, mpconfig

  if keyword_set(mpconfig.qanytied) then mpfit_tie, x, mpconfig.ptied

  <span class="comments">;; Decide whether we are calling a procedure or function, and </span>
  <span class="comments">;; with/without FUNCTARGS</span>
  proname = 'MPFIT_CALL'
  proname = proname + ((mpconfig.proc) ? '_PRO' : '_FUNC')
  proname = proname + ((n_elements(extra) GT 0) ? '_EXTRA' : '_NOEXTRA')

  if n_params() EQ 2 then begin
     f = call_function(proname, fcn, x, _EXTRA=extra)
  endif else begin
     f = call_function(proname, fcn, x, fjac, _EXTRA=extra)
  endelse
  mpconfig.nfev = mpconfig.nfev + 1

  if n_params() EQ 2 AND mpconfig.damp GT 0 then begin
      damp = mpconfig.damp[0]
      
      <span class="comments">;; Apply the damping if requested.  This replaces the residuals</span>
      <span class="comments">;; with their hyperbolic tangent.  Thus residuals larger than</span>
      <span class="comments">;; DAMP are essentially clipped.</span>
      f = tanh(f/damp)
  endif

  return, f
end

<a id="mpfit_fdjac2:source"></a>function mpfit_fdjac2, fcn, x, fvec, step, ulimited, ulimit, dside, $
                 iflag=iflag, epsfcn=epsfcn, autoderiv=autoderiv, $
                 FUNCTARGS=fcnargs, xall=xall, ifree=ifree, dstep=dstep, $
                 deriv_debug=ddebug, deriv_reltol=ddrtol, deriv_abstol=ddatol

  COMPILE_OPT strictarr
  common mpfit_machar, machvals
  common mpfit_profile, profvals
  common mpfit_error, mperr

<span class="comments">;  prof_start = systime(1)</span>
  MACHEP0 = machvals.machep
  DWARF   = machvals.minnum

  if n_elements(epsfcn) EQ 0 then epsfcn = MACHEP0
  if n_elements(xall)   EQ 0 then xall = x
  if n_elements(ifree)  EQ 0 then ifree = lindgen(n_elements(xall))
  if n_elements(step)   EQ 0 then step = x * 0.
  if n_elements(ddebug) EQ 0 then ddebug = intarr(n_elements(xall))
  if n_elements(ddrtol) EQ 0 then ddrtol = x * 0.
  if n_elements(ddatol) EQ 0 then ddatol = x * 0.
  has_debug_deriv = max(ddebug)

  if keyword_set(has_debug_deriv) then begin
      <span class="comments">;; Header for debugging</span>
      print, 'FJAC DEBUG BEGIN'
      print, "IPNT", "FUNC", "DERIV_U", "DERIV_N", "DIFF_ABS", "DIFF_REL", $
        format='("#  ",A10," ",A10," ",A10," ",A10," ",A10," ",A10)'
  endif

  nall = n_elements(xall)

  eps = sqrt(max([epsfcn, MACHEP0]))<span class="comments">;</span>
  m = n_elements(fvec)
  n = n_elements(x)

  <span class="comments">;; Compute analytical derivative if requested</span>
  <span class="comments">;; Two ways to enable computation of explicit derivatives:</span>
  <span class="comments">;;   1. AUTODERIVATIVE=0</span>
  <span class="comments">;;   2. AUTODERIVATIVE=1, but P[i].MPSIDE EQ 3</span>

  if keyword_set(autoderiv) EQ 0 OR max(dside[ifree] EQ 3) EQ 1 then begin
      fjac = intarr(nall)
      <span class="comments">;; Specify which parameters need derivatives</span>
      <span class="comments">;;            ---- Case 2 ------     ----- Case 1 -----</span>
      fjac[ifree] = (dside[ifree] EQ 3) OR (keyword_set(autoderiv) EQ 0)
      if has_debug_deriv then print, fjac, format='("# FJAC_MASK = ",100000(I0," ",:))'

      mperr = 0
      fp = mpfit_call(fcn, xall, fjac, _EXTRA=fcnargs)
      iflag = mperr

      if n_elements(fjac) NE m*nall then begin
          message, /cont, 'ERROR: Derivative matrix was not computed properly.'
          iflag = 1
<span class="comments">;          profvals.fdjac2 = profvals.fdjac2 + (systime(1) - prof_start)</span>
          return, 0
      endif

      <span class="comments">;; This definition is consistent with CURVEFIT (WRONG, see below)</span>
      <span class="comments">;; Sign error found (thanks Jesus Fernandez &lt;fernande@irm.chu-caen.fr>)</span>

      <span class="comments">;; ... and now I regret doing this sign flip since it's not</span>
      <span class="comments">;; strictly correct.  The definition should be RESID =</span>
      <span class="comments">;; (Y-F)/SIGMA, so d(RESID)/dP should be -dF/dP.  My response to</span>
      <span class="comments">;; Fernandez was unfounded because he was trying to supply</span>
      <span class="comments">;; dF/dP.  Sigh. (CM 31 Aug 2007)</span>

      fjac = reform(-temporary(fjac), m, nall, /overwrite)

      <span class="comments">;; Select only the free parameters</span>
      if n_elements(ifree) LT nall then $
        fjac = reform(fjac[*,ifree], m, n, /overwrite)

      <span class="comments">;; If there are no more free parameters to analyze, then</span>
      <span class="comments">;; return now, (but not if we are debugging the derivatives)</span>
      if ((keyword_set(autoderiv) EQ 0) OR $
          (min(dside[ifree]) EQ 1) OR $
          (has_debug_deriv EQ 0)) then return, fjac
  endif

  <span class="comments">;; Final output array, if it was not already created above</span>
  if n_elements(fjac) EQ 0 then begin
      fjac = make_array(m, n, value=fvec[0]*0.)
      fjac = reform(fjac, m, n, /overwrite)
  endif

  h = eps * abs(x)

  <span class="comments">;; if STEP is given, use that</span>
  <span class="comments">;; STEP includes the fixed parameters</span>
  if n_elements(step) GT 0 then begin
      stepi = step[ifree]
      wh = where(stepi GT 0, ct)
      if ct GT 0 then h[wh] = stepi[wh]
  endif

  <span class="comments">;; if relative step is given, use that</span>
  <span class="comments">;; DSTEP includes the fixed parameters</span>
  if n_elements(dstep) GT 0 then begin
      dstepi = dstep[ifree]
      wh = where(dstepi GT 0, ct)
      if ct GT 0 then h[wh] = abs(dstepi[wh]*x[wh])
  endif

  <span class="comments">;; In case any of the step values are zero</span>
  wh = where(h EQ 0, ct)
  if ct GT 0 then h[wh] = eps

  <span class="comments">;; Reverse the sign of the step if we are up against the parameter</span>
  <span class="comments">;; limit, or if the user requested it.</span>
  <span class="comments">;; DSIDE includes the fixed parameters (ULIMITED/ULIMIT have only</span>
  <span class="comments">;; varying ones)</span>
  mask = dside[ifree] EQ -1
  if n_elements(ulimited) GT 0 AND n_elements(ulimit) GT 0 then $
    mask = mask OR (ulimited AND (x GT ulimit-h))
  wh = where(mask, ct)
  if ct GT 0 then h[wh] = -h[wh]

  <span class="comments">;; Loop through parameters, computing the derivative for each</span>
  for j=0L, n-1 do begin
      dsidej = dside[ifree[j]]
      ddebugj = ddebug[ifree[j]]

      <span class="comments">;; Skip this parameter if we already computed its derivative</span>
      <span class="comments">;; explicitly, and we are not debugging.</span>
      if (dsidej EQ 3) AND (ddebugj EQ 0) then continue
      if (dsidej EQ 3) AND (ddebugj EQ 1) then $
        print, ifree[j], format='("FJAC PARM ",I0)'

      xp = xall
      xp[ifree[j]] = xp[ifree[j]] + h[j]
      
      mperr = 0
      fp = mpfit_call(fcn, xp, _EXTRA=fcnargs)
      
      iflag = mperr
      if iflag LT 0 then return, !values.d_nan

      if ((dsidej GE -1) AND (dsidej LE 1)) OR (dsidej EQ 3) then begin
          <span class="comments">;; COMPUTE THE ONE-SIDED DERIVATIVE</span>
          <span class="comments">;; Note optimization fjac(0:*,j)</span>
          fjacj = (fp-fvec)/h[j]

      endif else begin
          <span class="comments">;; COMPUTE THE TWO-SIDED DERIVATIVE</span>
          xp[ifree[j]] = xall[ifree[j]] - h[j]

          mperr = 0
          fm = mpfit_call(fcn, xp, _EXTRA=fcnargs)
          
          iflag = mperr
          if iflag LT 0 then return, !values.d_nan
          
          <span class="comments">;; Note optimization fjac(0:*,j)</span>
          fjacj = (fp-fm)/(2*h[j])
      endelse          
      
      <span class="comments">;; Debugging of explicit derivatives</span>
      if (dsidej EQ 3) AND (ddebugj EQ 1) then begin
          <span class="comments">;; Relative and absolute tolerances</span>
          dr = ddrtol[ifree[j]] & da = ddatol[ifree[j]]

          <span class="comments">;; Explicitly calculated</span>
          fjaco = fjac[*,j]
          
          <span class="comments">;; If tolerances are zero, then any value for deriv triggers print...</span>
          if (da EQ 0 AND dr EQ 0) then $
            diffj = (fjaco NE 0 OR fjacj NE 0)
          <span class="comments">;; ... otherwise the difference must be a greater than tolerance</span>
          if (da NE 0 OR dr NE 0) then $
            diffj = (abs(fjaco-fjacj) GT (da+abs(fjaco)*dr))

          for k = 0L, m-1 do if diffj[k] then begin
              print, k, fvec[k], fjaco[k], fjacj[k], fjaco[k]-fjacj[k], $
                (fjaco[k] EQ 0)?(0):((fjaco[k]-fjacj[k])/fjaco[k]), $
                format='("   ",I10," ",G10.4," ",G10.4," ",G10.4," ",G10.4," ",G10.4)'
          endif
      endif

      <span class="comments">;; Store final results in output array</span>
      fjac[0,j] = fjacj
          
  endfor

  if has_debug_deriv then print, 'FJAC DEBUG END'

<span class="comments">;  profvals.fdjac2 = profvals.fdjac2 + (systime(1) - prof_start)</span>
  return, fjac
end

<a id="mpfit_enorm:source"></a>function mpfit_enorm, vec

  COMPILE_OPT strictarr
  <span class="comments">;; NOTE: it turns out that, for systems that have a lot of data</span>
  <span class="comments">;; points, this routine is a big computing bottleneck.  The extended</span>
  <span class="comments">;; computations that need to be done cannot be effectively</span>
  <span class="comments">;; vectorized.  The introduction of the FASTNORM configuration</span>
  <span class="comments">;; parameter allows the user to select a faster routine, which is </span>
  <span class="comments">;; based on TOTAL() alone.</span>
  common mpfit_profile, profvals
<span class="comments">;  prof_start = systime(1)</span>

  common mpfit_config, mpconfig
<span class="comments">; Very simple-minded sum-of-squares</span>
  if n_elements(mpconfig) GT 0 then if mpconfig.fastnorm then begin
      ans = sqrt(total(vec^2))
      goto, TERMINATE
  endif

  common mpfit_machar, machvals

  agiant = machvals.rgiant / n_elements(vec)
  adwarf = machvals.rdwarf * n_elements(vec)

  <span class="comments">;; This is hopefully a compromise between speed and robustness.</span>
  <span class="comments">;; Need to do this because of the possibility of over- or underflow.</span>
  mx = max(vec, min=mn)
  mx = max(abs([mx,mn]))
  if mx EQ 0 then return, vec[0]*0.

  if mx GT agiant OR mx LT adwarf then ans = mx * sqrt(total((vec/mx)^2))$
  else                                 ans = sqrt( total(vec^2) )

  TERMINATE:
<span class="comments">;  profvals.enorm = profvals.enorm + (systime(1) - prof_start)</span>
  return, ans
end

<span class="comments">;     **********</span>
<span class="comments">;</span>
<span class="comments">;     subroutine qrfac</span>
<span class="comments">;</span>
<span class="comments">;     this subroutine uses householder transformations with column</span>
<span class="comments">;     pivoting (optional) to compute a qr factorization of the</span>
<span class="comments">;     m by n matrix a. that is, qrfac determines an orthogonal</span>
<span class="comments">;     matrix q, a permutation matrix p, and an upper trapezoidal</span>
<span class="comments">;     matrix r with diagonal elements of nonincreasing magnitude,</span>
<span class="comments">;     such that a*p = q*r. the householder transformation for</span>
<span class="comments">;     column k, k = 1,2,...,min(m,n), is of the form</span>
<span class="comments">;</span>
<span class="comments">;			    t</span>
<span class="comments">;	    i - (1/u(k))*u*u</span>
<span class="comments">;</span>
<span class="comments">;     where u has zeros in the first k-1 positions. the form of</span>
<span class="comments">;     this transformation and the method of pivoting first</span>
<span class="comments">;     appeared in the corresponding linpack subroutine.</span>
<span class="comments">;</span>
<span class="comments">;     the subroutine statement is</span>
<span class="comments">;</span>
<span class="comments">;	subroutine qrfac(m,n,a,lda,pivot,ipvt,lipvt,rdiag,acnorm,wa)</span>
<span class="comments">;</span>
<span class="comments">;     where</span>
<span class="comments">;</span>
<span class="comments">;	m is a positive integer input variable set to the number</span>
<span class="comments">;	  of rows of a.</span>
<span class="comments">;</span>
<span class="comments">;	n is a positive integer input variable set to the number</span>
<span class="comments">;	  of columns of a.</span>
<span class="comments">;</span>
<span class="comments">;	a is an m by n array. on input a contains the matrix for</span>
<span class="comments">;	  which the qr factorization is to be computed. on output</span>
<span class="comments">;	  the strict upper trapezoidal part of a contains the strict</span>
<span class="comments">;	  upper trapezoidal part of r, and the lower trapezoidal</span>
<span class="comments">;	  part of a contains a factored form of q (the non-trivial</span>
<span class="comments">;	  elements of the u vectors described above).</span>
<span class="comments">;</span>
<span class="comments">;	lda is a positive integer input variable not less than m</span>
<span class="comments">;	  which specifies the leading dimension of the array a.</span>
<span class="comments">;</span>
<span class="comments">;	pivot is a logical input variable. if pivot is set true,</span>
<span class="comments">;	  then column pivoting is enforced. if pivot is set false,</span>
<span class="comments">;	  then no column pivoting is done.</span>
<span class="comments">;</span>
<span class="comments">;	ipvt is an integer output array of length lipvt. ipvt</span>
<span class="comments">;	  defines the permutation matrix p such that a*p = q*r.</span>
<span class="comments">;	  column j of p is column ipvt(j) of the identity matrix.</span>
<span class="comments">;	  if pivot is false, ipvt is not referenced.</span>
<span class="comments">;</span>
<span class="comments">;	lipvt is a positive integer input variable. if pivot is false,</span>
<span class="comments">;	  then lipvt may be as small as 1. if pivot is true, then</span>
<span class="comments">;	  lipvt must be at least n.</span>
<span class="comments">;</span>
<span class="comments">;	rdiag is an output array of length n which contains the</span>
<span class="comments">;	  diagonal elements of r.</span>
<span class="comments">;</span>
<span class="comments">;	acnorm is an output array of length n which contains the</span>
<span class="comments">;	  norms of the corresponding columns of the input matrix a.</span>
<span class="comments">;	  if this information is not needed, then acnorm can coincide</span>
<span class="comments">;	  with rdiag.</span>
<span class="comments">;</span>
<span class="comments">;	wa is a work array of length n. if pivot is false, then wa</span>
<span class="comments">;	  can coincide with rdiag.</span>
<span class="comments">;</span>
<span class="comments">;     subprograms called</span>
<span class="comments">;</span>
<span class="comments">;	minpack-supplied ... dpmpar,enorm</span>
<span class="comments">;</span>
<span class="comments">;	fortran-supplied ... dmax1,dsqrt,min0</span>
<span class="comments">;</span>
<span class="comments">;     argonne national laboratory. minpack project. march 1980.</span>
<span class="comments">;     burton s. garbow, kenneth e. hillstrom, jorge j. more</span>
<span class="comments">;</span>
<span class="comments">;     **********</span>
<span class="comments">;</span>
<span class="comments">; PIVOTING / PERMUTING:</span>
<span class="comments">;</span>
<span class="comments">; Upon return, A(*,*) is in standard parameter order, A(*,IPVT) is in</span>
<span class="comments">; permuted order.</span>
<span class="comments">;</span>
<span class="comments">; RDIAG is in permuted order.</span>
<span class="comments">;</span>
<span class="comments">; ACNORM is in standard parameter order.</span>
<span class="comments">;</span>
<span class="comments">; NOTE: in IDL the factors appear slightly differently than described</span>
<span class="comments">; above.  The matrix A is still m x n where m >= n.  </span>
<span class="comments">;</span>
<span class="comments">; The "upper" triangular matrix R is actually stored in the strict</span>
<span class="comments">; lower left triangle of A under the standard notation of IDL.</span>
<span class="comments">;</span>
<span class="comments">; The reflectors that generate Q are in the upper trapezoid of A upon</span>
<span class="comments">; output.</span>
<span class="comments">;</span>
<span class="comments">;  EXAMPLE:  decompose the matrix [[9.,2.,6.],[4.,8.,7.]]</span>
<span class="comments">;    aa = [[9.,2.,6.],[4.,8.,7.]]</span>
<span class="comments">;    mpfit_qrfac, aa, aapvt, rdiag, aanorm</span>
<span class="comments">;     IDL> print, aa</span>
<span class="comments">;          1.81818*     0.181818*     0.545455*</span>
<span class="comments">;         -8.54545+      1.90160*     0.432573*</span>
<span class="comments">;     IDL> print, rdiag</span>
<span class="comments">;         -11.0000+     -7.48166+</span>
<span class="comments">;</span>
<span class="comments">; The components marked with a * are the components of the</span>
<span class="comments">; reflectors, and those marked with a + are components of R.</span>
<span class="comments">;</span>
<span class="comments">; To reconstruct Q and R we proceed as follows.  First R.</span>
<span class="comments">;    r = fltarr(m, n)</span>
<span class="comments">;    for i = 0, n-1 do r(0:i,i) = aa(0:i,i)  ; fill in lower diag</span>
<span class="comments">;    r(lindgen(n)*(m+1)) = rdiag</span>
<span class="comments">;</span>
<span class="comments">; Next, Q, which are composed from the reflectors.  Each reflector v</span>
<span class="comments">; is taken from the upper trapezoid of aa, and converted to a matrix</span>
<span class="comments">; via (I - 2 vT . v / (v . vT)).</span>
<span class="comments">;</span>
<span class="comments">;   hh = ident                                    ;; identity matrix</span>
<span class="comments">;   for i = 0, n-1 do begin</span>
<span class="comments">;    v = aa(*,i) & if i GT 0 then v(0:i-1) = 0    ;; extract reflector</span>
<span class="comments">;    hh = hh ## (ident - 2*(v # v)/total(v * v))  ;; generate matrix</span>
<span class="comments">;   endfor</span>
<span class="comments">;</span>
<span class="comments">; Test the result:</span>
<span class="comments">;    IDL> print, hh ## transpose(r)</span>
<span class="comments">;          9.00000      4.00000</span>
<span class="comments">;          2.00000      8.00000</span>
<span class="comments">;          6.00000      7.00000</span>
<span class="comments">;</span>
<span class="comments">; Note that it is usually never necessary to form the Q matrix</span>
<span class="comments">; explicitly, and MPFIT does not.</span>

<a id="mpfit_qrfac:source"></a>pro mpfit_qrfac, a, ipvt, rdiag, acnorm, pivot=pivot

  COMPILE_OPT strictarr
  sz = size(a)
  m = sz[1]
  n = sz[2]

  common mpfit_machar, machvals
  common mpfit_profile, profvals
<span class="comments">;  prof_start = systime(1)</span>

  MACHEP0 = machvals.machep
  DWARF   = machvals.minnum
  
  <span class="comments">;; Compute the initial column norms and initialize arrays</span>
  acnorm = make_array(n, value=a[0]*0.)
  for j = 0L, n-1 do $
    acnorm[j] = mpfit_enorm(a[*,j])
  rdiag = acnorm
  wa = rdiag
  ipvt = lindgen(n)

  <span class="comments">;; Reduce a to r with householder transformations</span>
  minmn = min([m,n])
  for j = 0L, minmn-1 do begin
      if NOT keyword_set(pivot) then goto, HOUSE1
      
      <span class="comments">;; Bring the column of largest norm into the pivot position</span>
      rmax = max(rdiag[j:*])
      kmax = where(rdiag[j:*] EQ rmax, ct) + j
      if ct LE 0 then goto, HOUSE1
      kmax = kmax[0]
      
      <span class="comments">;; Exchange rows via the pivot only.  Avoid actually exchanging</span>
      <span class="comments">;; the rows, in case there is lots of memory transfer.  The</span>
      <span class="comments">;; exchange occurs later, within the body of MPFIT, after the</span>
      <span class="comments">;; extraneous columns of the matrix have been shed.</span>
      if kmax NE j then begin
          temp     = ipvt[j]   & ipvt[j]    = ipvt[kmax] & ipvt[kmax]  = temp
          rdiag[kmax] = rdiag[j]
          wa[kmax]    = wa[j]
      endif
      
      HOUSE1:

      <span class="comments">;; Compute the householder transformation to reduce the jth</span>
      <span class="comments">;; column of A to a multiple of the jth unit vector</span>
      lj     = ipvt[j]
      ajj    = a[j:*,lj]
      ajnorm = mpfit_enorm(ajj)
      if ajnorm EQ 0 then goto, NEXT_ROW
      if a[j,lj] LT 0 then ajnorm = -ajnorm
      
      ajj     = ajj / ajnorm
      ajj[0]  = ajj[0] + 1
      <span class="comments">;; *** Note optimization a(j:*,j)</span>
      a[j,lj] = ajj
      
      <span class="comments">;; Apply the transformation to the remaining columns</span>
      <span class="comments">;; and update the norms</span>

      <span class="comments">;; NOTE to SELF: tried to optimize this by removing the loop,</span>
      <span class="comments">;; but it actually got slower.  Reverted to "for" loop to keep</span>
      <span class="comments">;; it simple.</span>
      if j+1 LT n then begin
          for k=j+1, n-1 do begin
              lk = ipvt[k]
              ajk = a[j:*,lk]
              <span class="comments">;; *** Note optimization a(j:*,lk) </span>
              <span class="comments">;; (corrected 20 Jul 2000)</span>
              if a[j,lj] NE 0 then $
                a[j,lk] = ajk - ajj * total(ajk*ajj)/a[j,lj]

              if keyword_set(pivot) AND rdiag[k] NE 0 then begin
                  temp = a[j,lk]/rdiag[k]
                  rdiag[k] = rdiag[k] * sqrt((1.-temp^2) > 0)
                  temp = rdiag[k]/wa[k]
                  if 0.05D*temp*temp LE MACHEP0 then begin
                      rdiag[k] = mpfit_enorm(a[j+1:*,lk])
                      wa[k] = rdiag[k]
                  endif
              endif
          endfor
      endif

      NEXT_ROW:
      rdiag[j] = -ajnorm
  endfor

<span class="comments">;  profvals.qrfac = profvals.qrfac + (systime(1) - prof_start)</span>
  return
end

<span class="comments">;     **********</span>
<span class="comments">;</span>
<span class="comments">;     subroutine qrsolv</span>
<span class="comments">;</span>
<span class="comments">;     given an m by n matrix a, an n by n diagonal matrix d,</span>
<span class="comments">;     and an m-vector b, the problem is to determine an x which</span>
<span class="comments">;     solves the system</span>
<span class="comments">;</span>
<span class="comments">;           a*x = b ,     d*x = 0 ,</span>
<span class="comments">;</span>
<span class="comments">;     in the least squares sense.</span>
<span class="comments">;</span>
<span class="comments">;     this subroutine completes the solution of the problem</span>
<span class="comments">;     if it is provided with the necessary information from the</span>
<span class="comments">;     qr factorization, with column pivoting, of a. that is, if</span>
<span class="comments">;     a*p = q*r, where p is a permutation matrix, q has orthogonal</span>
<span class="comments">;     columns, and r is an upper triangular matrix with diagonal</span>
<span class="comments">;     elements of nonincreasing magnitude, then qrsolv expects</span>
<span class="comments">;     the full upper triangle of r, the permutation matrix p,</span>
<span class="comments">;     and the first n components of (q transpose)*b. the system</span>
<span class="comments">;     a*x = b, d*x = 0, is then equivalent to</span>
<span class="comments">;</span>
<span class="comments">;                  t       t</span>
<span class="comments">;           r*z = q *b ,  p *d*p*z = 0 ,</span>
<span class="comments">;</span>
<span class="comments">;     where x = p*z. if this system does not have full rank,</span>
<span class="comments">;     then a least squares solution is obtained. on output qrsolv</span>
<span class="comments">;     also provides an upper triangular matrix s such that</span>
<span class="comments">;</span>
<span class="comments">;            t   t               t</span>
<span class="comments">;           p *(a *a + d*d)*p = s *s .</span>
<span class="comments">;</span>
<span class="comments">;     s is computed within qrsolv and may be of separate interest.</span>
<span class="comments">;</span>
<span class="comments">;     the subroutine statement is</span>
<span class="comments">;</span>
<span class="comments">;       subroutine qrsolv(n,r,ldr,ipvt,diag,qtb,x,sdiag,wa)</span>
<span class="comments">;</span>
<span class="comments">;     where</span>
<span class="comments">;</span>
<span class="comments">;       n is a positive integer input variable set to the order of r.</span>
<span class="comments">;</span>
<span class="comments">;       r is an n by n array. on input the full upper triangle</span>
<span class="comments">;         must contain the full upper triangle of the matrix r.</span>
<span class="comments">;         on output the full upper triangle is unaltered, and the</span>
<span class="comments">;         strict lower triangle contains the strict upper triangle</span>
<span class="comments">;         (transposed) of the upper triangular matrix s.</span>
<span class="comments">;</span>
<span class="comments">;       ldr is a positive integer input variable not less than n</span>
<span class="comments">;         which specifies the leading dimension of the array r.</span>
<span class="comments">;</span>
<span class="comments">;       ipvt is an integer input array of length n which defines the</span>
<span class="comments">;         permutation matrix p such that a*p = q*r. column j of p</span>
<span class="comments">;         is column ipvt(j) of the identity matrix.</span>
<span class="comments">;</span>
<span class="comments">;       diag is an input array of length n which must contain the</span>
<span class="comments">;         diagonal elements of the matrix d.</span>
<span class="comments">;</span>
<span class="comments">;       qtb is an input array of length n which must contain the first</span>
<span class="comments">;         n elements of the vector (q transpose)*b.</span>
<span class="comments">;</span>
<span class="comments">;       x is an output array of length n which contains the least</span>
<span class="comments">;         squares solution of the system a*x = b, d*x = 0.</span>
<span class="comments">;</span>
<span class="comments">;       sdiag is an output array of length n which contains the</span>
<span class="comments">;         diagonal elements of the upper triangular matrix s.</span>
<span class="comments">;</span>
<span class="comments">;       wa is a work array of length n.</span>
<span class="comments">;</span>
<span class="comments">;     subprograms called</span>
<span class="comments">;</span>
<span class="comments">;       fortran-supplied ... dabs,dsqrt</span>
<span class="comments">;</span>
<span class="comments">;     argonne national laboratory. minpack project. march 1980.</span>
<span class="comments">;     burton s. garbow, kenneth e. hillstrom, jorge j. more</span>
<span class="comments">;</span>
<a id="mpfit_qrsolv:source"></a>pro mpfit_qrsolv, r, ipvt, diag, qtb, x, sdiag

  COMPILE_OPT strictarr
  sz = size(r)
  m = sz[1]
  n = sz[2]
  delm = lindgen(n) * (m+1) <span class="comments">;; Diagonal elements of r</span>

  common mpfit_profile, profvals
<span class="comments">;  prof_start = systime(1)</span>

  <span class="comments">;; copy r and (q transpose)*b to preserve input and initialize s.</span>
  <span class="comments">;; in particular, save the diagonal elements of r in x.</span>

  for j = 0L, n-1 do $
    r[j:n-1,j] = r[j,j:n-1]
  x = r[delm]
  wa = qtb
  <span class="comments">;; Below may look strange, but it's so we can keep the right precision</span>
  zero = qtb[0]*0.
  half = zero + 0.5
  quart = zero + 0.25

  <span class="comments">;; Eliminate the diagonal matrix d using a givens rotation</span>
  for j = 0L, n-1 do begin
      l = ipvt[j]
      if diag[l] EQ 0 then goto, STORE_RESTORE
      sdiag[j:*] = 0
      sdiag[j] = diag[l]

      <span class="comments">;; The transformations to eliminate the row of d modify only a</span>
      <span class="comments">;; single element of (q transpose)*b beyond the first n, which</span>
      <span class="comments">;; is initially zero.</span>

      qtbpj = zero
      for k = j, n-1 do begin
          if sdiag[k] EQ 0 then goto, ELIM_NEXT_LOOP
          if abs(r[k,k]) LT abs(sdiag[k]) then begin
              cotan  = r[k,k]/sdiag[k]
              sine   = half/sqrt(quart + quart*cotan*cotan)
              cosine = sine*cotan
          endif else begin
              tang   = sdiag[k]/r[k,k]
              cosine = half/sqrt(quart + quart*tang*tang)
              sine   = cosine*tang
          endelse
          
          <span class="comments">;; Compute the modified diagonal element of r and the</span>
          <span class="comments">;; modified element of ((q transpose)*b,0).</span>
          r[k,k] = cosine*r[k,k] + sine*sdiag[k]
          temp = cosine*wa[k] + sine*qtbpj
          qtbpj = -sine*wa[k] + cosine*qtbpj
          wa[k] = temp

          <span class="comments">;; Accumulate the transformation in the row of s</span>
          if n GT k+1 then begin
              temp = cosine*r[k+1:n-1,k] + sine*sdiag[k+1:n-1]
              sdiag[k+1:n-1] = -sine*r[k+1:n-1,k] + cosine*sdiag[k+1:n-1]
              r[k+1:n-1,k] = temp
          endif
ELIM_NEXT_LOOP:
      endfor

STORE_RESTORE:
      sdiag[j] = r[j,j]
      r[j,j] = x[j]
  endfor

  <span class="comments">;; Solve the triangular system for z.  If the system is singular</span>
  <span class="comments">;; then obtain a least squares solution</span>
  nsing = n
  wh = where(sdiag EQ 0, ct)
  if ct GT 0 then begin
      nsing = wh[0]
      wa[nsing:*] = 0
  endif

  if nsing GE 1 then begin
      wa[nsing-1] = wa[nsing-1]/sdiag[nsing-1] <span class="comments">;; Degenerate case</span>
      <span class="comments">;; *** Reverse loop ***</span>
      for j=nsing-2,0,-1 do begin  
          sum = total(r[j+1:nsing-1,j]*wa[j+1:nsing-1])
          wa[j] = (wa[j]-sum)/sdiag[j]
      endfor
  endif

  <span class="comments">;; Permute the components of z back to components of x</span>
  x[ipvt] = wa

<span class="comments">;  profvals.qrsolv = profvals.qrsolv + (systime(1) - prof_start)</span>
  return
end
      
  
<span class="comments">;</span>
<span class="comments">;     subroutine lmpar</span>
<span class="comments">;</span>
<span class="comments">;     given an m by n matrix a, an n by n nonsingular diagonal</span>
<span class="comments">;     matrix d, an m-vector b, and a positive number delta,</span>
<span class="comments">;     the problem is to determine a value for the parameter</span>
<span class="comments">;     par such that if x solves the system</span>
<span class="comments">;</span>
<span class="comments">;	    a*x = b ,	  sqrt(par)*d*x = 0 ,</span>
<span class="comments">;</span>
<span class="comments">;     in the least squares sense, and dxnorm is the euclidean</span>
<span class="comments">;     norm of d*x, then either par is zero and</span>
<span class="comments">;</span>
<span class="comments">;	    (dxnorm-delta) .le. 0.1*delta ,</span>
<span class="comments">;</span>
<span class="comments">;     or par is positive and</span>
<span class="comments">;</span>
<span class="comments">;	    abs(dxnorm-delta) .le. 0.1*delta .</span>
<span class="comments">;</span>
<span class="comments">;     this subroutine completes the solution of the problem</span>
<span class="comments">;     if it is provided with the necessary information from the</span>
<span class="comments">;     qr factorization, with column pivoting, of a. that is, if</span>
<span class="comments">;     a*p = q*r, where p is a permutation matrix, q has orthogonal</span>
<span class="comments">;     columns, and r is an upper triangular matrix with diagonal</span>
<span class="comments">;     elements of nonincreasing magnitude, then lmpar expects</span>
<span class="comments">;     the full upper triangle of r, the permutation matrix p,</span>
<span class="comments">;     and the first n components of (q transpose)*b. on output</span>
<span class="comments">;     lmpar also provides an upper triangular matrix s such that</span>
<span class="comments">;</span>
<span class="comments">;	     t	 t		     t</span>
<span class="comments">;	    p *(a *a + par*d*d)*p = s *s .</span>
<span class="comments">;</span>
<span class="comments">;     s is employed within lmpar and may be of separate interest.</span>
<span class="comments">;</span>
<span class="comments">;     only a few iterations are generally needed for convergence</span>
<span class="comments">;     of the algorithm. if, however, the limit of 10 iterations</span>
<span class="comments">;     is reached, then the output par will contain the best</span>
<span class="comments">;     value obtained so far.</span>
<span class="comments">;</span>
<span class="comments">;     the subroutine statement is</span>
<span class="comments">;</span>
<span class="comments">;	subroutine lmpar(n,r,ldr,ipvt,diag,qtb,delta,par,x,sdiag,</span>
<span class="comments">;			 wa1,wa2)</span>
<span class="comments">;</span>
<span class="comments">;     where</span>
<span class="comments">;</span>
<span class="comments">;	n is a positive integer input variable set to the order of r.</span>
<span class="comments">;</span>
<span class="comments">;	r is an n by n array. on input the full upper triangle</span>
<span class="comments">;	  must contain the full upper triangle of the matrix r.</span>
<span class="comments">;	  on output the full upper triangle is unaltered, and the</span>
<span class="comments">;	  strict lower triangle contains the strict upper triangle</span>
<span class="comments">;	  (transposed) of the upper triangular matrix s.</span>
<span class="comments">;</span>
<span class="comments">;	ldr is a positive integer input variable not less than n</span>
<span class="comments">;	  which specifies the leading dimension of the array r.</span>
<span class="comments">;</span>
<span class="comments">;	ipvt is an integer input array of length n which defines the</span>
<span class="comments">;	  permutation matrix p such that a*p = q*r. column j of p</span>
<span class="comments">;	  is column ipvt(j) of the identity matrix.</span>
<span class="comments">;</span>
<span class="comments">;	diag is an input array of length n which must contain the</span>
<span class="comments">;	  diagonal elements of the matrix d.</span>
<span class="comments">;</span>
<span class="comments">;	qtb is an input array of length n which must contain the first</span>
<span class="comments">;	  n elements of the vector (q transpose)*b.</span>
<span class="comments">;</span>
<span class="comments">;	delta is a positive input variable which specifies an upper</span>
<span class="comments">;	  bound on the euclidean norm of d*x.</span>
<span class="comments">;</span>
<span class="comments">;	par is a nonnegative variable. on input par contains an</span>
<span class="comments">;	  initial estimate of the levenberg-marquardt parameter.</span>
<span class="comments">;	  on output par contains the final estimate.</span>
<span class="comments">;</span>
<span class="comments">;	x is an output array of length n which contains the least</span>
<span class="comments">;	  squares solution of the system a*x = b, sqrt(par)*d*x = 0,</span>
<span class="comments">;	  for the output par.</span>
<span class="comments">;</span>
<span class="comments">;	sdiag is an output array of length n which contains the</span>
<span class="comments">;	  diagonal elements of the upper triangular matrix s.</span>
<span class="comments">;</span>
<span class="comments">;	wa1 and wa2 are work arrays of length n.</span>
<span class="comments">;</span>
<span class="comments">;     subprograms called</span>
<span class="comments">;</span>
<span class="comments">;	minpack-supplied ... dpmpar,enorm,qrsolv</span>
<span class="comments">;</span>
<span class="comments">;	fortran-supplied ... dabs,dmax1,dmin1,dsqrt</span>
<span class="comments">;</span>
<span class="comments">;     argonne national laboratory. minpack project. march 1980.</span>
<span class="comments">;     burton s. garbow, kenneth e. hillstrom, jorge j. more</span>
<span class="comments">;</span>
<a id="mpfit_lmpar:source"></a>function mpfit_lmpar, r, ipvt, diag, qtb, delta, x, sdiag, par=par

  COMPILE_OPT strictarr
  common mpfit_machar, machvals
  common mpfit_profile, profvals
<span class="comments">;  prof_start = systime(1)</span>

  MACHEP0 = machvals.machep
  DWARF   = machvals.minnum

  sz = size(r)
  m = sz[1]
  n = sz[2]
  delm = lindgen(n) * (m+1) <span class="comments">;; Diagonal elements of r</span>

  <span class="comments">;; Compute and store in x the gauss-newton direction.  If the</span>
  <span class="comments">;; jacobian is rank-deficient, obtain a least-squares solution</span>
  nsing = n
  wa1 = qtb
  rthresh = max(abs(r[delm]))*MACHEP0
  wh = where(abs(r[delm]) LT rthresh, ct)
  if ct GT 0 then begin
      nsing = wh[0]
      wa1[wh[0]:*] = 0
  endif

  if nsing GE 1 then begin
      <span class="comments">;; *** Reverse loop ***</span>
      for j=nsing-1,0,-1 do begin  
          wa1[j] = wa1[j]/r[j,j]
          if (j-1 GE 0) then $
            wa1[0:(j-1)] = wa1[0:(j-1)] - r[0:(j-1),j]*wa1[j]
      endfor
  endif

  <span class="comments">;; Note: ipvt here is a permutation array</span>
  x[ipvt] = wa1

  <span class="comments">;; Initialize the iteration counter.  Evaluate the function at the</span>
  <span class="comments">;; origin, and test for acceptance of the gauss-newton direction</span>
  iter = 0L
  wa2 = diag * x
  dxnorm = mpfit_enorm(wa2)
  fp = dxnorm - delta
  if fp LE 0.1*delta then goto, TERMINATE

  <span class="comments">;; If the jacobian is not rank deficient, the newton step provides a</span>
  <span class="comments">;; lower bound, parl, for the zero of the function.  Otherwise set</span>
  <span class="comments">;; this bound to zero.</span>
  
  zero = wa2[0]*0.
  parl = zero
  if nsing GE n then begin
      wa1 = diag[ipvt]*wa2[ipvt]/dxnorm

      wa1[0] = wa1[0] / r[0,0] <span class="comments">;; Degenerate case </span>
      for j=1L, n-1 do begin   <span class="comments">;; Note "1" here, not zero</span>
          sum = total(r[0:(j-1),j]*wa1[0:(j-1)])
          wa1[j] = (wa1[j] - sum)/r[j,j]
      endfor

      temp = mpfit_enorm(wa1)
      parl = ((fp/delta)/temp)/temp
  endif

  <span class="comments">;; Calculate an upper bound, paru, for the zero of the function</span>
  for j=0L, n-1 do begin
      sum = total(r[0:j,j]*qtb[0:j])
      wa1[j] = sum/diag[ipvt[j]]
  endfor
  gnorm = mpfit_enorm(wa1)
  paru  = gnorm/delta
  if paru EQ 0 then paru = DWARF/min([delta,0.1])

  <span class="comments">;; If the input par lies outside of the interval (parl,paru), set</span>
  <span class="comments">;; par to the closer endpoint</span>

  par = max([par,parl])
  par = min([par,paru])
  if par EQ 0 then par = gnorm/dxnorm

  <span class="comments">;; Beginning of an interation</span>
  ITERATION:
  iter = iter + 1
  
  <span class="comments">;; Evaluate the function at the current value of par</span>
  if par EQ 0 then par = max([DWARF, paru*0.001])
  temp = sqrt(par)
  wa1 = temp * diag
  mpfit_qrsolv, r, ipvt, wa1, qtb, x, sdiag
  wa2 = diag*x
  dxnorm = mpfit_enorm(wa2)
  temp = fp
  fp = dxnorm - delta

  if (abs(fp) LE 0.1D*delta) $
    OR ((parl EQ 0) AND (fp LE temp) AND (temp LT 0)) $
    OR (iter EQ 10) then goto, TERMINATE

  <span class="comments">;; Compute the newton correction</span>
  wa1 = diag[ipvt]*wa2[ipvt]/dxnorm

  for j=0L,n-2 do begin
      wa1[j] = wa1[j]/sdiag[j]
      wa1[j+1:n-1] = wa1[j+1:n-1] - r[j+1:n-1,j]*wa1[j]
  endfor
  wa1[n-1] = wa1[n-1]/sdiag[n-1] <span class="comments">;; Degenerate case</span>

  temp = mpfit_enorm(wa1)
  parc = ((fp/delta)/temp)/temp

  <span class="comments">;; Depending on the sign of the function, update parl or paru</span>
  if fp GT 0 then parl = max([parl,par])
  if fp LT 0 then paru = min([paru,par])

  <span class="comments">;; Compute an improved estimate for par</span>
  par = max([parl, par+parc])

  <span class="comments">;; End of an iteration</span>
  goto, ITERATION
  
TERMINATE:
  <span class="comments">;; Termination</span>
<span class="comments">;  profvals.lmpar = profvals.lmpar + (systime(1) - prof_start)</span>
  if iter EQ 0 then return, par[0]*0.
  return, par
end

<span class="comments">;; Procedure to tie one parameter to another.</span>
<a id="mpfit_tie:source"></a>pro mpfit_tie, p, _ptied
  COMPILE_OPT strictarr
  if n_elements(_ptied) EQ 0 then return
  if n_elements(_ptied) EQ 1 then if _ptied[0] EQ '' then return
  for _i = 0L, n_elements(_ptied)-1 do begin
      if _ptied[_i] EQ '' then goto, NEXT_TIE
      _cmd = 'p['+strtrim(_i,2)+'] = '+_ptied[_i]
      _err = execute(_cmd)
      if _err EQ 0 then begin
          message, 'ERROR: Tied expression "'+_cmd+'" failed.'
          return
      endif
      NEXT_TIE:
  endfor
end

<span class="comments">;; Default print procedure</span>
<a id="mpfit_defprint:source"></a>pro mpfit_defprint, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, $
                    p11, p12, p13, p14, p15, p16, p17, p18, $
                    format=format, unit=unit0, _EXTRA=extra

  COMPILE_OPT strictarr
  if n_elements(unit0) EQ 0 then unit = -1 else unit = round(unit0[0])
  if n_params() EQ 0 then printf, unit, '' $
  else if n_params() EQ 1 then printf, unit, p1, format=format $
  else if n_params() EQ 2 then printf, unit, p1, p2, format=format $
  else if n_params() EQ 3 then printf, unit, p1, p2, p3, format=format $
  else if n_params() EQ 4 then printf, unit, p1, p2, p4, format=format 

  return
end


<span class="comments">;; Default procedure to be called every iteration.  It simply prints</span>
<span class="comments">;; the parameter values.</span>
<a id="mpfit_defiter:source"></a>pro mpfit_defiter, fcn, x, iter, fnorm, FUNCTARGS=fcnargs, $
                   quiet=quiet, iterstop=iterstop, iterkeybyte=iterkeybyte, $
                   parinfo=parinfo, iterprint=iterprint0, $
                   format=fmt, pformat=pformat, dof=dof0, _EXTRA=iterargs

  COMPILE_OPT strictarr
  common mpfit_error, mperr
  mperr = 0

  if keyword_set(quiet) then goto, DO_ITERSTOP
  if n_params() EQ 3 then begin
      fvec = mpfit_call(fcn, x, _EXTRA=fcnargs)
      fnorm = mpfit_enorm(fvec)^2
  endif

  <span class="comments">;; Determine which parameters to print</span>
  nprint = n_elements(x)
  iprint = lindgen(nprint)

  if n_elements(iterprint0) EQ 0 then iterprint = 'MPFIT_DEFPRINT' $
  else iterprint = strtrim(iterprint0[0],2)

  if n_elements(dof0) EQ 0 then dof = 1L else dof = floor(dof0[0])
  call_procedure, iterprint, iter, fnorm, dof, $
    format='("Iter ",I6,"   CHI-SQUARE = ",G15.8,"          DOF = ",I0)', $
    _EXTRA=iterargs
  if n_elements(fmt) GT 0 then begin
      call_procedure, iterprint, x, format=fmt, _EXTRA=iterargs
  endif else begin
      if n_elements(pformat) EQ 0 then pformat = '(G20.6)'
      parname = 'P('+strtrim(iprint,2)+')'
      pformats = strarr(nprint) + pformat

      if n_elements(parinfo) GT 0 then begin
          parinfo_tags = tag_names(parinfo)
          wh = where(parinfo_tags EQ 'PARNAME', ct)
          if ct EQ 1 then begin
              wh = where(parinfo.parname NE '', ct)
              if ct GT 0 then $
                parname[wh] = strmid(parinfo[wh].parname,0,25)
          endif
          wh = where(parinfo_tags EQ 'MPPRINT', ct)
          if ct EQ 1 then begin
              iprint = where(parinfo.mpprint EQ 1, nprint)
              if nprint EQ 0 then goto, DO_ITERSTOP
          endif
          wh = where(parinfo_tags EQ 'MPFORMAT', ct)
          if ct EQ 1 then begin
              wh = where(parinfo.mpformat NE '', ct)
              if ct GT 0 then pformats[wh] = parinfo[wh].mpformat
          endif
      endif

      for i = 0L, nprint-1 do begin
          call_procedure, iterprint, parname[iprint[i]], x[iprint[i]], $
            format='("    ",A0," = ",'+pformats[iprint[i]]+')', $
            _EXTRA=iterargs
      endfor
  endelse

  DO_ITERSTOP:
  if n_elements(iterkeybyte) EQ 0 then iterkeybyte = 7b
  if keyword_set(iterstop) then begin
      k = get_kbrd(0)
      if k EQ string(iterkeybyte[0]) then begin
          message, 'WARNING: minimization not complete', /info
          print, 'Do you want to terminate this procedure? (y/n)', $
            format='(A,$)'
          k = ''
          read, k
          if strupcase(strmid(k,0,1)) EQ 'Y' then begin
              message, 'WARNING: Procedure is terminating.', /info
              mperr = -1
          endif
      endif
  endif

  return
end

<span class="comments">;; Procedure to parse the parameter values in PARINFO</span>
<a id="mpfit_parinfo:source"></a>pro mpfit_parinfo, parinfo, tnames, tag, values, default=def, status=status, $
                   n_param=n

  COMPILE_OPT strictarr
  status = 0
  if n_elements(n) EQ 0 then n = n_elements(parinfo)

  if n EQ 0 then begin
      if n_elements(def) EQ 0 then return
      values = def
      status = 1
      return
  endif

  if n_elements(parinfo) EQ 0 then goto, DO_DEFAULT
  if n_elements(tnames) EQ 0 then tnames = tag_names(parinfo)
  wh = where(tnames EQ tag, ct)

  if ct EQ 0 then begin
      DO_DEFAULT:
      if n_elements(def) EQ 0 then return
      values = make_array(n, value=def[0])
      values[0] = def
  endif else begin
      values = parinfo.(wh[0])
      np = n_elements(parinfo)
      nv = n_elements(values)
      values = reform(values[*], nv/np, np)
  endelse

  status = 1
  return
end


<span class="comments">;     **********</span>
<span class="comments">;</span>
<span class="comments">;     subroutine covar</span>
<span class="comments">;</span>
<span class="comments">;     given an m by n matrix a, the problem is to determine</span>
<span class="comments">;     the covariance matrix corresponding to a, defined as</span>
<span class="comments">;</span>
<span class="comments">;                    t</span>
<span class="comments">;           inverse(a *a) .</span>
<span class="comments">;</span>
<span class="comments">;     this subroutine completes the solution of the problem</span>
<span class="comments">;     if it is provided with the necessary information from the</span>
<span class="comments">;     qr factorization, with column pivoting, of a. that is, if</span>
<span class="comments">;     a*p = q*r, where p is a permutation matrix, q has orthogonal</span>
<span class="comments">;     columns, and r is an upper triangular matrix with diagonal</span>
<span class="comments">;     elements of nonincreasing magnitude, then covar expects</span>
<span class="comments">;     the full upper triangle of r and the permutation matrix p.</span>
<span class="comments">;     the covariance matrix is then computed as</span>
<span class="comments">;</span>
<span class="comments">;                      t     t</span>
<span class="comments">;           p*inverse(r *r)*p  .</span>
<span class="comments">;</span>
<span class="comments">;     if a is nearly rank deficient, it may be desirable to compute</span>
<span class="comments">;     the covariance matrix corresponding to the linearly independent</span>
<span class="comments">;     columns of a. to define the numerical rank of a, covar uses</span>
<span class="comments">;     the tolerance tol. if l is the largest integer such that</span>
<span class="comments">;</span>
<span class="comments">;           abs(r(l,l)) .gt. tol*abs(r(1,1)) ,</span>
<span class="comments">;</span>
<span class="comments">;     then covar computes the covariance matrix corresponding to</span>
<span class="comments">;     the first l columns of r. for k greater than l, column</span>
<span class="comments">;     and row ipvt(k) of the covariance matrix are set to zero.</span>
<span class="comments">;</span>
<span class="comments">;     the subroutine statement is</span>
<span class="comments">;</span>
<span class="comments">;       subroutine covar(n,r,ldr,ipvt,tol,wa)</span>
<span class="comments">;</span>
<span class="comments">;     where</span>
<span class="comments">;</span>
<span class="comments">;       n is a positive integer input variable set to the order of r.</span>
<span class="comments">;</span>
<span class="comments">;       r is an n by n array. on input the full upper triangle must</span>
<span class="comments">;         contain the full upper triangle of the matrix r. on output</span>
<span class="comments">;         r contains the square symmetric covariance matrix.</span>
<span class="comments">;</span>
<span class="comments">;       ldr is a positive integer input variable not less than n</span>
<span class="comments">;         which specifies the leading dimension of the array r.</span>
<span class="comments">;</span>
<span class="comments">;       ipvt is an integer input array of length n which defines the</span>
<span class="comments">;         permutation matrix p such that a*p = q*r. column j of p</span>
<span class="comments">;         is column ipvt(j) of the identity matrix.</span>
<span class="comments">;</span>
<span class="comments">;       tol is a nonnegative input variable used to define the</span>
<span class="comments">;         numerical rank of a in the manner described above.</span>
<span class="comments">;</span>
<span class="comments">;       wa is a work array of length n.</span>
<span class="comments">;</span>
<span class="comments">;     subprograms called</span>
<span class="comments">;</span>
<span class="comments">;       fortran-supplied ... dabs</span>
<span class="comments">;</span>
<span class="comments">;     argonne national laboratory. minpack project. august 1980.</span>
<span class="comments">;     burton s. garbow, kenneth e. hillstrom, jorge j. more</span>
<span class="comments">;</span>
<span class="comments">;     **********</span>
<a id="mpfit_covar:source"></a>function mpfit_covar, rr, ipvt, tol=tol

  COMPILE_OPT strictarr
  sz = size(rr)
  if sz[0] NE 2 then begin
      message, 'ERROR: r must be a two-dimensional matrix'
      return, -1L
  endif
  n = sz[1]
  if n NE sz[2] then begin
      message, 'ERROR: r must be a square matrix'
      return, -1L
  endif

  zero = rr[0] * 0.
  one  = zero  + 1.
  if n_elements(ipvt) EQ 0 then ipvt = lindgen(n)
  r = rr
  r = reform(rr, n, n, /overwrite)
  
  <span class="comments">;; Form the inverse of r in the full upper triangle of r</span>
  l = -1L
  if n_elements(tol) EQ 0 then tol = one*1.E-14
  tolr = tol * abs(r[0,0])
  for k = 0L, n-1 do begin
      if abs(r[k,k]) LE tolr then goto, INV_END_LOOP
      r[k,k] = one/r[k,k]
      for j = 0L, k-1 do begin
          temp = r[k,k] * r[j,k]
          r[j,k] = zero
          r[0,k] = r[0:j,k] - temp*r[0:j,j]
      endfor
      l = k
  endfor
  INV_END_LOOP:

  <span class="comments">;; Form the full upper triangle of the inverse of (r transpose)*r</span>
  <span class="comments">;; in the full upper triangle of r</span>
  if l GE 0 then $
    for k = 0L, l do begin
      for j = 0L, k-1 do begin
          temp = r[j,k]
          r[0,j] = r[0:j,j] + temp*r[0:j,k]
      endfor
      temp = r[k,k]
      r[0,k] = temp * r[0:k,k]
  endfor

  <span class="comments">;; Form the full lower triangle of the covariance matrix</span>
  <span class="comments">;; in the strict lower triangle of r and in wa</span>
  wa = replicate(r[0,0], n)
  for j = 0L, n-1 do begin
      jj = ipvt[j]
      sing = j GT l
      for i = 0L, j do begin
          if sing then r[i,j] = zero
          ii = ipvt[i]
          if ii GT jj then r[ii,jj] = r[i,j]
          if ii LT jj then r[jj,ii] = r[i,j]
      endfor
      wa[jj] = r[j,j]
  endfor

  <span class="comments">;; Symmetrize the covariance matrix in r</span>
  for j = 0L, n-1 do begin
      r[0:j,j] = r[j,0:j]
      r[j,j] = wa[j]
  endfor

  return, r
end

<span class="comments">;; Parse the RCSID revision number</span>
<a id="mpfit_revision:source"></a>function mpfit_revision
  <span class="comments">;; NOTE: this string is changed every time an RCS check-in occurs</span>
  revision = '$Revision: 1.75 $'

  <span class="comments">;; Parse just the version number portion</span>
  revision = stregex(revision,'\$'+'Revision: *([0-9.]+) *'+'\$',/extract,/sub)
  revision = revision[1]
  return, revision
end

<span class="comments">;; Parse version numbers of the form 'X.Y'</span>
<a id="mpfit_parse_version:source"></a>function mpfit_parse_version, version
  sz = size(version)
  if sz[sz[0]+1] NE 7 then return, 0

  s = stregex(version[0], '^([0-9]+)\.([0-9]+)$', /extract,/sub) 
  if s[0] NE version[0] then return, 0
  return, long(s[1:2])
end

<span class="comments">;; Enforce a minimum version number</span>
<a id="mpfit_min_version:source"></a>function mpfit_min_version, version, min_version
  mv = mpfit_parse_version(min_version)
  if mv[0] EQ 0 then return, 0
  v  = mpfit_parse_version(version)

  <span class="comments">;; Compare version components</span>
  if v[0] LT mv[0] then return, 0
  if v[1] LT mv[1] then return, 0
  return, 1
end

<span class="comments">;     **********</span>
<span class="comments">;</span>
<span class="comments">;     subroutine lmdif</span>
<span class="comments">;</span>
<span class="comments">;     the purpose of lmdif is to minimize the sum of the squares of</span>
<span class="comments">;     m nonlinear functions in n variables by a modification of</span>
<span class="comments">;     the levenberg-marquardt algorithm. the user must provide a</span>
<span class="comments">;     subroutine which calculates the functions. the jacobian is</span>
<span class="comments">;     then calculated by a forward-difference approximation.</span>
<span class="comments">;</span>
<span class="comments">;     the subroutine statement is</span>
<span class="comments">;</span>
<span class="comments">;	subroutine lmdif(fcn,m,n,x,fvec,ftol,xtol,gtol,maxfev,epsfcn,</span>
<span class="comments">;			 diag,mode,factor,nprint,info,nfev,fjac,</span>
<span class="comments">;			 ldfjac,ipvt,qtf,wa1,wa2,wa3,wa4)</span>
<span class="comments">;</span>
<span class="comments">;     where</span>
<span class="comments">;</span>
<span class="comments">;	fcn is the name of the user-supplied subroutine which</span>
<span class="comments">;	  calculates the functions. fcn must be declared</span>
<span class="comments">;	  in an external statement in the user calling</span>
<span class="comments">;	  program, and should be written as follows.</span>
<span class="comments">;</span>
<span class="comments">;	  subroutine fcn(m,n,x,fvec,iflag)</span>
<span class="comments">;	  integer m,n,iflag</span>
<span class="comments">;	  double precision x(n),fvec(m)</span>
<span class="comments">;	  ----------</span>
<span class="comments">;	  calculate the functions at x and</span>
<span class="comments">;	  return this vector in fvec.</span>
<span class="comments">;	  ----------</span>
<span class="comments">;	  return</span>
<span class="comments">;	  end</span>
<span class="comments">;</span>
<span class="comments">;	  the value of iflag should not be changed by fcn unless</span>
<span class="comments">;	  the user wants to terminate execution of lmdif.</span>
<span class="comments">;	  in this case set iflag to a negative integer.</span>
<span class="comments">;</span>
<span class="comments">;	m is a positive integer input variable set to the number</span>
<span class="comments">;	  of functions.</span>
<span class="comments">;</span>
<span class="comments">;	n is a positive integer input variable set to the number</span>
<span class="comments">;	  of variables. n must not exceed m.</span>
<span class="comments">;</span>
<span class="comments">;	x is an array of length n. on input x must contain</span>
<span class="comments">;	  an initial estimate of the solution vector. on output x</span>
<span class="comments">;	  contains the final estimate of the solution vector.</span>
<span class="comments">;</span>
<span class="comments">;	fvec is an output array of length m which contains</span>
<span class="comments">;	  the functions evaluated at the output x.</span>
<span class="comments">;</span>
<span class="comments">;	ftol is a nonnegative input variable. termination</span>
<span class="comments">;	  occurs when both the actual and predicted relative</span>
<span class="comments">;	  reductions in the sum of squares are at most ftol.</span>
<span class="comments">;	  therefore, ftol measures the relative error desired</span>
<span class="comments">;	  in the sum of squares.</span>
<span class="comments">;</span>
<span class="comments">;	xtol is a nonnegative input variable. termination</span>
<span class="comments">;	  occurs when the relative error between two consecutive</span>
<span class="comments">;	  iterates is at most xtol. therefore, xtol measures the</span>
<span class="comments">;	  relative error desired in the approximate solution.</span>
<span class="comments">;</span>
<span class="comments">;	gtol is a nonnegative input variable. termination</span>
<span class="comments">;	  occurs when the cosine of the angle between fvec and</span>
<span class="comments">;	  any column of the jacobian is at most gtol in absolute</span>
<span class="comments">;	  value. therefore, gtol measures the orthogonality</span>
<span class="comments">;	  desired between the function vector and the columns</span>
<span class="comments">;	  of the jacobian.</span>
<span class="comments">;</span>
<span class="comments">;	maxfev is a positive integer input variable. termination</span>
<span class="comments">;	  occurs when the number of calls to fcn is at least</span>
<span class="comments">;	  maxfev by the end of an iteration.</span>
<span class="comments">;</span>
<span class="comments">;	epsfcn is an input variable used in determining a suitable</span>
<span class="comments">;	  step length for the forward-difference approximation. this</span>
<span class="comments">;	  approximation assumes that the relative errors in the</span>
<span class="comments">;	  functions are of the order of epsfcn. if epsfcn is less</span>
<span class="comments">;	  than the machine precision, it is assumed that the relative</span>
<span class="comments">;	  errors in the functions are of the order of the machine</span>
<span class="comments">;	  precision.</span>
<span class="comments">;</span>
<span class="comments">;	diag is an array of length n. if mode = 1 (see</span>
<span class="comments">;	  below), diag is internally set. if mode = 2, diag</span>
<span class="comments">;	  must contain positive entries that serve as</span>
<span class="comments">;	  multiplicative scale factors for the variables.</span>
<span class="comments">;</span>
<span class="comments">;	mode is an integer input variable. if mode = 1, the</span>
<span class="comments">;	  variables will be scaled internally. if mode = 2,</span>
<span class="comments">;	  the scaling is specified by the input diag. other</span>
<span class="comments">;	  values of mode are equivalent to mode = 1.</span>
<span class="comments">;</span>
<span class="comments">;	factor is a positive input variable used in determining the</span>
<span class="comments">;	  initial step bound. this bound is set to the product of</span>
<span class="comments">;	  factor and the euclidean norm of diag*x if nonzero, or else</span>
<span class="comments">;	  to factor itself. in most cases factor should lie in the</span>
<span class="comments">;	  interval (.1,100.). 100. is a generally recommended value.</span>
<span class="comments">;</span>
<span class="comments">;	nprint is an integer input variable that enables controlled</span>
<span class="comments">;	  printing of iterates if it is positive. in this case,</span>
<span class="comments">;	  fcn is called with iflag = 0 at the beginning of the first</span>
<span class="comments">;	  iteration and every nprint iterations thereafter and</span>
<span class="comments">;	  immediately prior to return, with x and fvec available</span>
<span class="comments">;	  for printing. if nprint is not positive, no special calls</span>
<span class="comments">;	  of fcn with iflag = 0 are made.</span>
<span class="comments">;</span>
<span class="comments">;	info is an integer output variable. if the user has</span>
<span class="comments">;	  terminated execution, info is set to the (negative)</span>
<span class="comments">;	  value of iflag. see description of fcn. otherwise,</span>
<span class="comments">;	  info is set as follows.</span>
<span class="comments">;</span>
<span class="comments">;	  info = 0  improper input parameters.</span>
<span class="comments">;</span>
<span class="comments">;	  info = 1  both actual and predicted relative reductions</span>
<span class="comments">;		    in the sum of squares are at most ftol.</span>
<span class="comments">;</span>
<span class="comments">;	  info = 2  relative error between two consecutive iterates</span>
<span class="comments">;		    is at most xtol.</span>
<span class="comments">;</span>
<span class="comments">;	  info = 3  conditions for info = 1 and info = 2 both hold.</span>
<span class="comments">;</span>
<span class="comments">;	  info = 4  the cosine of the angle between fvec and any</span>
<span class="comments">;		    column of the jacobian is at most gtol in</span>
<span class="comments">;		    absolute value.</span>
<span class="comments">;</span>
<span class="comments">;	  info = 5  number of calls to fcn has reached or</span>
<span class="comments">;		    exceeded maxfev.</span>
<span class="comments">;</span>
<span class="comments">;	  info = 6  ftol is too small. no further reduction in</span>
<span class="comments">;		    the sum of squares is possible.</span>
<span class="comments">;</span>
<span class="comments">;	  info = 7  xtol is too small. no further improvement in</span>
<span class="comments">;		    the approximate solution x is possible.</span>
<span class="comments">;</span>
<span class="comments">;	  info = 8  gtol is too small. fvec is orthogonal to the</span>
<span class="comments">;		    columns of the jacobian to machine precision.</span>
<span class="comments">;</span>
<span class="comments">;	nfev is an integer output variable set to the number of</span>
<span class="comments">;	  calls to fcn.</span>
<span class="comments">;</span>
<span class="comments">;	fjac is an output m by n array. the upper n by n submatrix</span>
<span class="comments">;	  of fjac contains an upper triangular matrix r with</span>
<span class="comments">;	  diagonal elements of nonincreasing magnitude such that</span>
<span class="comments">;</span>
<span class="comments">;		 t     t	   t</span>
<span class="comments">;		p *(jac *jac)*p = r *r,</span>
<span class="comments">;</span>
<span class="comments">;	  where p is a permutation matrix and jac is the final</span>
<span class="comments">;	  calculated jacobian. column j of p is column ipvt(j)</span>
<span class="comments">;	  (see below) of the identity matrix. the lower trapezoidal</span>
<span class="comments">;	  part of fjac contains information generated during</span>
<span class="comments">;	  the computation of r.</span>
<span class="comments">;</span>
<span class="comments">;	ldfjac is a positive integer input variable not less than m</span>
<span class="comments">;	  which specifies the leading dimension of the array fjac.</span>
<span class="comments">;</span>
<span class="comments">;	ipvt is an integer output array of length n. ipvt</span>
<span class="comments">;	  defines a permutation matrix p such that jac*p = q*r,</span>
<span class="comments">;	  where jac is the final calculated jacobian, q is</span>
<span class="comments">;	  orthogonal (not stored), and r is upper triangular</span>
<span class="comments">;	  with diagonal elements of nonincreasing magnitude.</span>
<span class="comments">;	  column j of p is column ipvt(j) of the identity matrix.</span>
<span class="comments">;</span>
<span class="comments">;	qtf is an output array of length n which contains</span>
<span class="comments">;	  the first n elements of the vector (q transpose)*fvec.</span>
<span class="comments">;</span>
<span class="comments">;	wa1, wa2, and wa3 are work arrays of length n.</span>
<span class="comments">;</span>
<span class="comments">;	wa4 is a work array of length m.</span>
<span class="comments">;</span>
<span class="comments">;     subprograms called</span>
<span class="comments">;</span>
<span class="comments">;	user-supplied ...... fcn</span>
<span class="comments">;</span>
<span class="comments">;	minpack-supplied ... dpmpar,enorm,fdjac2,lmpar,qrfac</span>
<span class="comments">;</span>
<span class="comments">;	fortran-supplied ... dabs,dmax1,dmin1,dsqrt,mod</span>
<span class="comments">;</span>
<span class="comments">;     argonne national laboratory. minpack project. march 1980.</span>
<span class="comments">;     burton s. garbow, kenneth e. hillstrom, jorge j. more</span>
<span class="comments">;</span>
<span class="comments">;     **********</span>
<a id="mpfit:source"></a>function mpfit, fcn, xall, FUNCTARGS=fcnargs, SCALE_FCN=scalfcn, $
                ftol=ftol, xtol=xtol, gtol=gtol, epsfcn=epsfcn, resdamp=damp, $
                nfev=nfev, maxiter=maxiter, errmsg=errmsg, $
                factor=factor, nprint=nprint, STATUS=info, $
                iterproc=iterproc, iterargs=iterargs, iterstop=ss,$
                iterkeystop=iterkeystop, $
                niter=iter, nfree=nfree, npegged=npegged, dof=dof, $
                diag=diag, rescale=rescale, autoderivative=autoderiv, $
                perror=perror, covar=covar, nocovar=nocovar, bestnorm=fnorm, $
                parinfo=parinfo, quiet=quiet, nocatch=nocatch, $
                fastnorm=fastnorm, proc=proc, query=query, $
                external_state=state, external_init=extinit, $
                external_fvec=efvec, external_fjac=efjac, $
                version=version, min_version=min_version0

  COMPILE_OPT strictarr
  info = 0L
  errmsg = ''

  <span class="comments">;; Compute the revision number, to be returned in the VERSION and</span>
  <span class="comments">;; QUERY keywords.</span>
  common mpfit_revision_common, mpfit_revision_str
  if n_elements(mpfit_revision_str) EQ 0 then $
     mpfit_revision_str = mpfit_revision()
  version = mpfit_revision_str

  if keyword_set(query) then begin
     if n_elements(min_version0) GT 0 then $
        if mpfit_min_version(version, min_version0[0]) EQ 0 then $
           return, 0
     return, 1
  endif

  if n_elements(min_version0) GT 0 then $
     if mpfit_min_version(version, min_version0[0]) EQ 0 then begin
     message, 'ERROR: minimum required version '+min_version0[0]+' not satisfied', /info
     return, !values.d_nan
  endif

  if n_params() EQ 0 then begin
      message, "USAGE: PARMS = MPFIT('MYFUNCT', START_PARAMS, ... )", /info
      return, !values.d_nan
  endif
  
  <span class="comments">;; Use of double here not a problem since f/x/gtol are all only used</span>
  <span class="comments">;; in comparisons</span>
  if n_elements(ftol) EQ 0 then ftol = 1.D-10
  if n_elements(xtol) EQ 0 then xtol = 1.D-10
  if n_elements(gtol) EQ 0 then gtol = 1.D-10
  if n_elements(factor) EQ 0 then factor = 100.
  if n_elements(nprint) EQ 0 then nprint = 1
  if n_elements(iterproc) EQ 0 then iterproc = 'MPFIT_DEFITER'
  if n_elements(autoderiv) EQ 0 then autoderiv = 1
  if n_elements(fastnorm) EQ 0 then fastnorm = 0
  if n_elements(damp) EQ 0 then damp = 0 else damp = damp[0]

  <span class="comments">;; These are special configuration parameters that can't be easily</span>
  <span class="comments">;; passed by MPFIT directly.</span>
  <span class="comments">;;  FASTNORM - decide on which sum-of-squares technique to use (1)</span>
  <span class="comments">;;             is fast, (0) is slower</span>
  <span class="comments">;;  PROC - user routine is a procedure (1) or function (0)</span>
  <span class="comments">;;  QANYTIED - set to 1 if any parameters are TIED, zero if none</span>
  <span class="comments">;;  PTIED - array of strings, one for each parameter</span>
  common mpfit_config, mpconfig
  mpconfig = {fastnorm: keyword_set(fastnorm), proc: 0, nfev: 0L, damp: damp}
  common mpfit_machar, machvals

  iflag = 0L
  catch_msg = 'in MPFIT'
  nfree = 0L
  npegged = 0L
  dof = 0L

  <span class="comments">;; Parameter damping doesn't work when user is providing their own</span>
  <span class="comments">;; gradients.</span>
  if damp NE 0 AND NOT keyword_set(autoderiv) then begin
      errmsg = 'ERROR: keywords DAMP and AUTODERIV are mutually exclusive'
      goto, TERMINATE
  endif      
  
  <span class="comments">;; Process the ITERSTOP and ITERKEYSTOP keywords, and turn this into</span>
  <span class="comments">;; a set of keywords to pass to MPFIT_DEFITER.</span>
  if strupcase(iterproc) EQ 'MPFIT_DEFITER' AND n_elements(iterargs) EQ 0 $
    AND keyword_set(ss) then begin
      if n_elements(iterkeystop) GT 0 then begin
          sz = size(iterkeystop)
          tp = sz[sz[0]+1]
          if tp EQ 7 then begin
              <span class="comments">;; String - convert first char to byte</span>
              iterkeybyte = (byte(iterkeystop[0]))[0]
          endif
          if (tp GE 1 AND tp LE 3) OR (tp GE 12 AND tp LE 15) then begin
              <span class="comments">;; Integer - convert to byte</span>
              iterkeybyte = byte(iterkeystop[0])
          endif
          if n_elements(iterkeybyte) EQ 0 then begin
              errmsg = 'ERROR: ITERKEYSTOP must be either a BYTE or STRING'
              goto, TERMINATE
          endif

          iterargs = {iterstop: 1, iterkeybyte: iterkeybyte}
      endif else begin
          iterargs = {iterstop: 1, iterkeybyte: 7b}
      endelse
  endif


  <span class="comments">;; Handle error conditions gracefully</span>
  if NOT keyword_set(nocatch) then begin
      catch, catcherror
      if catcherror NE 0 then begin
          catch, /cancel
          err_string = ''+!error_state.msg
          message, /cont, 'Error detected while '+catch_msg+':'
          message, /cont,    err_string
          message, /cont, 'Error condition detected. Returning to MAIN level.'
          if errmsg EQ '' then $
            errmsg = 'Error detected while '+catch_msg+': '+err_string
          if info EQ 0 then info = -18
          return, !values.d_nan
      endif
  endif
  mpconfig = create_struct(mpconfig, 'NOCATCH', keyword_set(nocatch))

  <span class="comments">;; Parse FCN function name - be sure it is a scalar string</span>
  sz = size(fcn)
  if sz[0] NE 0 then begin
      FCN_NAME:
      errmsg = 'ERROR: MYFUNCT must be a scalar string'
      goto, TERMINATE
  endif
  if sz[sz[0]+1] NE 7 then goto, FCN_NAME

  isext = 0
  if fcn EQ '(EXTERNAL)' then begin
      if n_elements(efvec) EQ 0 OR n_elements(efjac) EQ 0 then begin
          errmsg = 'ERROR: when using EXTERNAL function, EXTERNAL_FVEC '+$
            'and EXTERNAL_FJAC must be defined'
          goto, TERMINATE
      endif
      nv = n_elements(efvec)
      nj = n_elements(efjac)
      if (nj MOD nv) NE 0 then begin
          errmsg = 'ERROR: the number of values in EXTERNAL_FJAC must be '+ $
            'a multiple of the number of values in EXTERNAL_FVEC'
          goto, TERMINATE
      endif
      isext = 1
  endif

  <span class="comments">;; Parinfo:</span>
  <span class="comments">;; --------------- STARTING/CONFIG INFO (passed in to routine, not changed)</span>
  <span class="comments">;; .value   - starting value for parameter</span>
  <span class="comments">;; .fixed   - parameter is fixed</span>
  <span class="comments">;; .limited - a two-element array, if parameter is bounded on</span>
  <span class="comments">;;            lower/upper side</span>
  <span class="comments">;; .limits - a two-element array, lower/upper parameter bounds, if</span>
  <span class="comments">;;           limited vale is set</span>
  <span class="comments">;; .step   - step size in Jacobian calc, if greater than zero</span>

  catch_msg = 'parsing input parameters'
  <span class="comments">;; Parameters can either be stored in parinfo, or x.  Parinfo takes</span>
  <span class="comments">;; precedence if it exists.</span>
  if n_elements(xall) EQ 0 AND n_elements(parinfo) EQ 0 then begin
      errmsg = 'ERROR: must pass parameters in P or PARINFO'
      goto, TERMINATE
  endif

  <span class="comments">;; Be sure that PARINFO is of the right type</span>
  if n_elements(parinfo) GT 0 then begin
      <span class="comments">;; Make sure the array is 1-D</span>
      parinfo = parinfo[*]
      parinfo_size = size(parinfo)
      if parinfo_size[parinfo_size[0]+1] NE 8 then begin
          errmsg = 'ERROR: PARINFO must be a structure.'
          goto, TERMINATE
      endif
      if n_elements(xall) GT 0 AND n_elements(xall) NE n_elements(parinfo) $
        then begin
          errmsg = 'ERROR: number of elements in PARINFO and P must agree'
          goto, TERMINATE
      endif
  endif

  <span class="comments">;; If the parameters were not specified at the command line, then</span>
  <span class="comments">;; extract them from PARINFO</span>
  if n_elements(xall) EQ 0 then begin
      mpfit_parinfo, parinfo, tagnames, 'VALUE', xall, status=status
      if status EQ 0 then begin
          errmsg = 'ERROR: either P or PARINFO[*].VALUE must be supplied.'
          goto, TERMINATE
      endif

      sz = size(xall)
      <span class="comments">;; Convert to double if parameters are not float or double</span>
      if sz[sz[0]+1] NE 4 AND sz[sz[0]+1] NE 5 then $
        xall = double(xall)
  endif
  xall = xall[*]   <span class="comments">;; Make sure the array is 1-D</span>
  npar = n_elements(xall)
  zero = xall[0] * 0.
  one  = zero    + 1.
  fnorm  = -one
  fnorm1 = -one

  <span class="comments">;; TIED parameters?</span>
  mpfit_parinfo, parinfo, tagnames, 'TIED', ptied, default='', n=npar
  ptied = strtrim(ptied, 2)
  wh = where(ptied NE '', qanytied) 
  qanytied = qanytied GT 0
  mpconfig = create_struct(mpconfig, 'QANYTIED', qanytied, 'PTIED', ptied)

  <span class="comments">;; FIXED parameters ?</span>
  mpfit_parinfo, parinfo, tagnames, 'FIXED', pfixed, default=0, n=npar
  pfixed = pfixed EQ 1
  pfixed = pfixed OR (ptied NE '')<span class="comments">;; Tied parameters are also effectively fixed</span>
  
  <span class="comments">;; Finite differencing step, absolute and relative, and sidedness of deriv.</span>
  mpfit_parinfo, parinfo, tagnames, 'STEP',     step, default=zero, n=npar
  mpfit_parinfo, parinfo, tagnames, 'RELSTEP', dstep, default=zero, n=npar
  mpfit_parinfo, parinfo, tagnames, 'MPSIDE',  dside, default=0,    n=npar
  <span class="comments">;; Debugging parameters</span>
  mpfit_parinfo, parinfo, tagnames, 'MPDERIV_DEBUG',  ddebug, default=0, n=npar
  mpfit_parinfo, parinfo, tagnames, 'MPDERIV_RELTOL', ddrtol, default=zero, n=npar
  mpfit_parinfo, parinfo, tagnames, 'MPDERIV_ABSTOL', ddatol, default=zero, n=npar

  <span class="comments">;; Maximum and minimum steps allowed to be taken in one iteration</span>
  mpfit_parinfo, parinfo, tagnames, 'MPMAXSTEP', maxstep, default=zero, n=npar
  mpfit_parinfo, parinfo, tagnames, 'MPMINSTEP', minstep, default=zero, n=npar
  qmin = minstep *  0  <span class="comments">;; Remove minstep for now!!</span>
  qmax = maxstep NE 0
  wh = where(qmin AND qmax AND maxstep LT minstep, ct)
  if ct GT 0 then begin
      errmsg = 'ERROR: MPMINSTEP is greater than MPMAXSTEP'
      goto, TERMINATE
  endif

  <span class="comments">;; Finish up the free parameters</span>
  ifree = where(pfixed NE 1, nfree)
  if nfree EQ 0 then begin
      errmsg = 'ERROR: no free parameters'
      goto, TERMINATE
  endif

  <span class="comments">;; An external Jacobian must be checked against the number of</span>
  <span class="comments">;; parameters</span>
  if isext then begin
      if (nj/nv) NE nfree then begin
          errmsg = string(nv, nfree, nfree, $
           format=('("ERROR: EXTERNAL_FJAC must be a ",I0," x ",I0,' + $
                   '" array, where ",I0," is the number of free parameters")'))
          goto, TERMINATE
      endif
  endif

  <span class="comments">;; Compose only VARYING parameters</span>
  xnew = xall      <span class="comments">;; xnew is the set of parameters to be returned</span>
  x = xnew[ifree]  <span class="comments">;; x is the set of free parameters</span>
  <span class="comments">; Same for min/max step diagnostics</span>
  qmin = qmin[ifree]  & minstep = minstep[ifree]
  qmax = qmax[ifree]  & maxstep = maxstep[ifree]
  wh = where(qmin OR qmax, ct)
  qminmax = ct GT 0


  <span class="comments">;; LIMITED parameters ?</span>
  mpfit_parinfo, parinfo, tagnames, 'LIMITED', limited, status=st1
  mpfit_parinfo, parinfo, tagnames, 'LIMITS',  limits,  status=st2
  if st1 EQ 1 AND st2 EQ 1 then begin

      <span class="comments">;; Error checking on limits in parinfo</span>
      wh = where((limited[0,*] AND xall LT limits[0,*]) OR $
                 (limited[1,*] AND xall GT limits[1,*]), ct)
      if ct GT 0 then begin
          errmsg = 'ERROR: parameters are not within PARINFO limits'
          goto, TERMINATE
      endif
      wh = where(limited[0,*] AND limited[1,*] AND $
                 limits[0,*] GE limits[1,*] AND $
                 pfixed EQ 0, ct)
      if ct GT 0 then begin
          errmsg = 'ERROR: PARINFO parameter limits are not consistent'
          goto, TERMINATE
      endif
      

      <span class="comments">;; Transfer structure values to local variables</span>
      qulim = limited[1, ifree]
      ulim  = limits [1, ifree]
      qllim = limited[0, ifree]
      llim  = limits [0, ifree]

      wh = where(qulim OR qllim, ct)
      if ct GT 0 then qanylim = 1 else qanylim = 0

  endif else begin

      <span class="comments">;; Fill in local variables with dummy values</span>
      qulim = lonarr(nfree)
      ulim  = x * 0.
      qllim = qulim
      llim  = x * 0.
      qanylim = 0

  endelse

  <span class="comments">;; Initialize the number of parameters pegged at a hard limit value</span>
  wh = where((qulim AND (x EQ ulim)) OR (qllim AND (x EQ llim)), npegged)

  n = n_elements(x)
  if n_elements(maxiter) EQ 0 then maxiter = 200L

  <span class="comments">;; Check input parameters for errors</span>
  if (n LE 0) OR (ftol LE 0) OR (xtol LE 0) OR (gtol LE 0) $
    OR (maxiter LT 0) OR (factor LE 0) then begin
      errmsg = 'ERROR: input keywords are inconsistent'
      goto, TERMINATE
  endif

  if keyword_set(rescale) then begin
      errmsg = 'ERROR: DIAG parameter scales are inconsistent'
      if n_elements(diag) LT n then goto, TERMINATE
      wh = where(diag LE 0, ct)
      if ct GT 0 then goto, TERMINATE
      errmsg = ''
  endif

  if n_elements(state) NE 0 AND NOT keyword_set(extinit) then begin
      szst = size(state)
      if szst[szst[0]+1] NE 8  then begin
          errmsg = 'EXTERNAL_STATE keyword was not preserved'
          status = 0
          goto, TERMINATE
      endif
      if nfree NE n_elements(state.ifree) then begin
          BAD_IFREE:
          errmsg = 'Number of free parameters must not change from one '+$
            'external iteration to the next'
          status = 0
          goto, TERMINATE
      endif
      wh = where(ifree NE state.ifree, ct)
      if ct GT 0 then goto, BAD_IFREE

      tnames = tag_names(state)
      for i = 0L, n_elements(tnames)-1 do begin
          dummy = execute(tnames[i]+' = state.'+tnames[i])
      endfor
      wa4 = reform(efvec, n_elements(efvec))

      goto, RESUME_FIT
  endif

  common mpfit_error, mperr

  if NOT isext then begin
      mperr = 0
      catch_msg = 'calling '+fcn
      fvec = mpfit_call(fcn, xnew, _EXTRA=fcnargs)
      iflag = mperr
      if iflag LT 0 then begin
          errmsg = 'ERROR: first call to "'+fcn+'" failed'
          goto, TERMINATE
      endif
  endif else begin
      fvec = reform(efvec, n_elements(efvec))
  endelse

  catch_msg = 'calling MPFIT_SETMACHAR'
  sz = size(fvec[0])
  isdouble = (sz[sz[0]+1] EQ 5)
  
  mpfit_setmachar, double=isdouble

  common mpfit_profile, profvals
<span class="comments">;  prof_start = systime(1)</span>

  MACHEP0 = machvals.machep
  DWARF   = machvals.minnum

  szx = size(x)
  <span class="comments">;; The parameters and the squared deviations should have the same</span>
  <span class="comments">;; type.  Otherwise the MACHAR-based evaluation will fail.</span>
  catch_msg = 'checking parameter data'
  tp = szx[szx[0]+1]
  if tp NE 4 AND tp NE 5 then begin
      if NOT keyword_set(quiet) then begin
          message, 'WARNING: input parameters must be at least FLOAT', /info
          message, '         (converting parameters to FLOAT)', /info
      endif
      x = float(x)
      xnew = float(x)
      szx = size(x)
  endif
  if isdouble AND tp NE 5 then begin
      if NOT keyword_set(quiet) then begin
          message, 'WARNING: data is DOUBLE but parameters are FLOAT', /info
          message, '         (converting parameters to DOUBLE)', /info
      endif
      x = double(x)
      xnew = double(xnew)
  endif

  m = n_elements(fvec)
  if (m LT n) then begin
      errmsg = 'ERROR: number of parameters must not exceed data'
      goto, TERMINATE
  endif

  fnorm = mpfit_enorm(fvec)

  <span class="comments">;; Initialize Levelberg-Marquardt parameter and iteration counter</span>

  par = zero
  iter = 1L
  qtf = x * 0.

  <span class="comments">;; Beginning of the outer loop</span>
  
  OUTER_LOOP:

  <span class="comments">;; If requested, call fcn to enable printing of iterates</span>
  xnew[ifree] = x
  if qanytied then mpfit_tie, xnew, ptied
  dof = (n_elements(fvec) - nfree) > 1L

  if nprint GT 0 AND iterproc NE '' then begin
      catch_msg = 'calling '+iterproc
      iflag = 0L
      if (iter-1) MOD nprint EQ 0 then begin
          mperr = 0
          xnew0 = xnew

          call_procedure, iterproc, fcn, xnew, iter, fnorm^2, $
            FUNCTARGS=fcnargs, parinfo=parinfo, quiet=quiet, $
            dof=dof, _EXTRA=iterargs
          iflag = mperr

          <span class="comments">;; Check for user termination</span>
          if iflag LT 0 then begin  
              errmsg = 'WARNING: premature termination by "'+iterproc+'"'
              goto, TERMINATE
          endif

          <span class="comments">;; If parameters were changed (grrr..) then re-tie</span>
          if max(abs(xnew0-xnew)) GT 0 then begin
              if qanytied then mpfit_tie, xnew, ptied
              x = xnew[ifree]
          endif

      endif
  endif

  <span class="comments">;; Calculate the jacobian matrix</span>
  iflag = 2
  if NOT isext then begin
      catch_msg = 'calling MPFIT_FDJAC2'
      fjac = mpfit_fdjac2(fcn, x, fvec, step, qulim, ulim, dside, $
                          iflag=iflag, epsfcn=epsfcn, $
                          autoderiv=autoderiv, dstep=dstep, $
                          FUNCTARGS=fcnargs, ifree=ifree, xall=xnew, $
                          deriv_debug=ddebug, deriv_reltol=ddrtol, deriv_abstol=ddatol)
      if iflag LT 0 then begin
          errmsg = 'WARNING: premature termination by FDJAC2'
          goto, TERMINATE
      endif
  endif else begin
      fjac = reform(efjac,n_elements(fvec),npar, /overwrite)
  endelse

  <span class="comments">;; Rescale the residuals and gradient, for use with "alternative"</span>
  <span class="comments">;; statistics such as the Cash statistic.</span>
  catch_msg = 'prescaling residuals and gradient'
  if n_elements(scalfcn) GT 0 then begin
      call_procedure, strtrim(scalfcn[0],2), fvec, fjac
  endif

  <span class="comments">;; Determine if any of the parameters are pegged at the limits</span>
  npegged = 0L
  if qanylim then begin
      catch_msg = 'zeroing derivatives of pegged parameters'
      whlpeg = where(qllim AND (x EQ llim), nlpeg)
      whupeg = where(qulim AND (x EQ ulim), nupeg)
      npegged = nlpeg + nupeg
      
      <span class="comments">;; See if any "pegged" values should keep their derivatives</span>
      if (nlpeg GT 0) then begin
          <span class="comments">;; Total derivative of sum wrt lower pegged parameters</span>
          for i = 0L, nlpeg-1 do begin
              sum = total(fvec * fjac[*,whlpeg[i]])
              if sum GT 0 then fjac[*,whlpeg[i]] = 0
          endfor
      endif
      if (nupeg GT 0) then begin
          <span class="comments">;; Total derivative of sum wrt upper pegged parameters</span>
          for i = 0L, nupeg-1 do begin
              sum = total(fvec * fjac[*,whupeg[i]])
              if sum LT 0 then fjac[*,whupeg[i]] = 0
          endfor
      endif
  endif

  <span class="comments">;; Compute the QR factorization of the jacobian</span>
  catch_msg = 'calling MPFIT_QRFAC'
  mpfit_qrfac, fjac, ipvt, wa1, wa2, /pivot

  <span class="comments">;; On the first iteration if "diag" is unspecified, scale</span>
  <span class="comments">;; according to the norms of the columns of the initial jacobian</span>
  catch_msg = 'rescaling diagonal elements'
  if (iter EQ 1) then begin

      if NOT keyword_set(rescale) OR (n_elements(diag) LT n) then begin
          diag = wa2
          wh = where (diag EQ 0, ct)
          if ct GT 0 then diag[wh] = one
      endif
      
      <span class="comments">;; On the first iteration, calculate the norm of the scaled x</span>
      <span class="comments">;; and initialize the step bound delta </span>
      wa3 = diag * x
      xnorm = mpfit_enorm(wa3)
      delta = factor*xnorm
      if delta EQ zero then delta = zero + factor
  endif

  <span class="comments">;; Form (q transpose)*fvec and store the first n components in qtf</span>
  catch_msg = 'forming (q transpose)*fvec'
  wa4 = fvec
  for j=0L, n-1 do begin
      lj = ipvt[j]
      temp3 = fjac[j,lj]
      if temp3 NE 0 then begin
          fj = fjac[j:*,lj]
          wj = wa4[j:*]
          <span class="comments">;; *** optimization wa4(j:*)</span>
          wa4[j] = wj - fj * total(fj*wj) / temp3  
      endif
      fjac[j,lj] = wa1[j]
      qtf[j] = wa4[j]
  endfor
  <span class="comments">;; From this point on, only the square matrix, consisting of the</span>
  <span class="comments">;; triangle of R, is needed.</span>
  fjac = fjac[0:n-1, 0:n-1]
  fjac = reform(fjac, n, n, /overwrite)
  fjac = fjac[*, ipvt]                    <span class="comments">;; Convert to permuted order</span>
  fjac = reform(fjac, n, n, /overwrite)

  <span class="comments">;; Check for overflow.  This should be a cheap test here since FJAC</span>
  <span class="comments">;; has been reduced to a (small) square matrix, and the test is</span>
  <span class="comments">;; O(N^2).</span>
  wh = where(finite(fjac) EQ 0, ct)
  if ct GT 0 then goto, FAIL_OVERFLOW

  <span class="comments">;; Compute the norm of the scaled gradient</span>
  catch_msg = 'computing the scaled gradient'
  gnorm = zero
  if fnorm NE 0 then begin
      for j=0L, n-1 do begin
          l = ipvt[j]
          if wa2[l] NE 0 then begin
              sum = total(fjac[0:j,j]*qtf[0:j])/fnorm
              gnorm = max([gnorm,abs(sum/wa2[l])])
          endif
      endfor
  endif

  <span class="comments">;; Test for convergence of the gradient norm</span>
  if gnorm LE gtol then info = 4
  if info NE 0 then goto, TERMINATE
  if maxiter EQ 0 then begin
     info = 5
     goto, TERMINATE
  endif

  <span class="comments">;; Rescale if necessary</span>
  if NOT keyword_set(rescale) then $
    diag = diag > wa2

  <span class="comments">;; Beginning of the inner loop</span>
  INNER_LOOP:
  
  <span class="comments">;; Determine the levenberg-marquardt parameter</span>
  catch_msg = 'calculating LM parameter (MPFIT_LMPAR)'
  par = mpfit_lmpar(fjac, ipvt, diag, qtf, delta, wa1, wa2, par=par)

  <span class="comments">;; Store the direction p and x+p. Calculate the norm of p</span>
  wa1 = -wa1

  if qanylim EQ 0 AND qminmax EQ 0 then begin
      <span class="comments">;; No parameter limits, so just move to new position WA2</span>
      alpha = one
      wa2 = x + wa1

  endif else begin
      
      <span class="comments">;; Respect the limits.  If a step were to go out of bounds, then</span>
      <span class="comments">;; we should take a step in the same direction but shorter distance.</span>
      <span class="comments">;; The step should take us right to the limit in that case.</span>
      alpha = one

      if qanylim EQ 1 then begin
          <span class="comments">;; Do not allow any steps out of bounds</span>
          catch_msg = 'checking for a step out of bounds'
          if nlpeg GT 0 then wa1[whlpeg] = wa1[whlpeg] > 0
          if nupeg GT 0 then wa1[whupeg] = wa1[whupeg] &lt<span class="comments">; 0</span>

          dwa1 = abs(wa1) GT MACHEP0
          whl = where(dwa1 AND qllim AND (x + wa1 LT llim), lct)
          if lct GT 0 then $
            alpha = min([alpha, (llim[whl]-x[whl])/wa1[whl]])
          whu = where(dwa1 AND qulim AND (x + wa1 GT ulim), uct)
          if uct GT 0 then $
            alpha = min([alpha, (ulim[whu]-x[whu])/wa1[whu]])
      endif

      <span class="comments">;; Obey any max step values.</span>

      if qminmax EQ 1 then begin
          nwa1 = wa1 * alpha
          whmax = where(qmax AND maxstep GT 0, ct)
          if ct GT 0 then begin
              mrat = max(abs(nwa1[whmax])/abs(maxstep[whmax]))
              if mrat GT 1 then alpha = alpha / mrat
          endif
      endif          

      <span class="comments">;; Scale the resulting vector</span>
      wa1 = wa1 * alpha
      wa2 = x + wa1

      <span class="comments">;; Adjust the final output values.  If the step put us exactly</span>
      <span class="comments">;; on a boundary, make sure we peg it there.</span>
      sgnu = (ulim GE 0)*2d - 1d
      sgnl = (llim GE 0)*2d - 1d

      <span class="comments">;; Handles case of </span>
      <span class="comments">;;      ... nonzero *LIM ...     ... zero *LIM ...</span>
      ulim1 = ulim*(1-sgnu*MACHEP0) - (ulim EQ 0)*MACHEP0
      llim1 = llim*(1+sgnl*MACHEP0) + (llim EQ 0)*MACHEP0

      wh = where(qulim AND (wa2 GE ulim1), ct)
      if ct GT 0 then wa2[wh] = ulim[wh]

      wh = where(qllim AND (wa2 LE llim1), ct)
      if ct GT 0 then wa2[wh] = llim[wh]
  endelse

  wa3 = diag * wa1
  pnorm = mpfit_enorm(wa3)

  <span class="comments">;; On the first iteration, adjust the initial step bound</span>
  if iter EQ 1 then delta = min([delta,pnorm])

  xnew[ifree] = wa2
  if isext then goto, SAVE_STATE

  <span class="comments">;; Evaluate the function at x+p and calculate its norm</span>
  mperr = 0
  catch_msg = 'calling '+fcn
  wa4 = mpfit_call(fcn, xnew, _EXTRA=fcnargs)
  iflag = mperr
  if iflag LT 0 then begin
      errmsg = 'WARNING: premature termination by "'+fcn+'"'
      goto, TERMINATE
  endif
  RESUME_FIT:
  fnorm1 = mpfit_enorm(wa4)
  
  <span class="comments">;; Compute the scaled actual reduction</span>
  catch_msg = 'computing convergence criteria'
  actred = -one
  if 0.1D * fnorm1 LT fnorm then actred = - (fnorm1/fnorm)^2 + 1.

  <span class="comments">;; Compute the scaled predicted reduction and the scaled directional</span>
  <span class="comments">;; derivative</span>
  for j = 0L, n-1 do begin
      wa3[j] = 0
      wa3[0:j] = wa3[0:j] + fjac[0:j,j]*wa1[ipvt[j]]
  endfor

  <span class="comments">;; Remember, alpha is the fraction of the full LM step actually</span>
  <span class="comments">;; taken</span>
  temp1 = mpfit_enorm(alpha*wa3)/fnorm
  temp2 = (sqrt(alpha*par)*pnorm)/fnorm
  half  = zero + 0.5
  prered = temp1*temp1 + (temp2*temp2)/half
  dirder = -(temp1*temp1 + temp2*temp2)

  <span class="comments">;; Compute the ratio of the actual to the predicted reduction.</span>
  ratio = zero
  tenth = zero + 0.1
  if prered NE 0 then ratio = actred/prered

  <span class="comments">;; Update the step bound</span>
  if ratio LE 0.25D then begin
      if actred GE 0 then temp = half $
      else temp = half*dirder/(dirder + half*actred)
      if ((0.1D*fnorm1) GE fnorm) OR (temp LT 0.1D) then temp = tenth
      delta = temp*min([delta,pnorm/tenth])
      par = par/temp
  endif else begin
      if (par EQ 0) OR (ratio GE 0.75) then begin
          delta = pnorm/half
          par = half*par
      endif
  endelse

  <span class="comments">;; Test for successful iteration</span>
  if ratio GE 0.0001 then begin
      <span class="comments">;; Successful iteration.  Update x, fvec, and their norms</span>
      x = wa2
      wa2 = diag * x

      fvec = wa4
      xnorm = mpfit_enorm(wa2)
      fnorm = fnorm1
      iter = iter + 1
  endif

  <span class="comments">;; Tests for convergence</span>
  if (abs(actred) LE ftol) AND (prered LE ftol) $
    AND  (0.5D * ratio LE 1) then info = 1
  if delta LE xtol*xnorm then info = 2
  if (abs(actred) LE ftol) AND (prered LE ftol) $
    AND (0.5D * ratio LE 1) AND (info EQ 2) then info = 3
  if info NE 0 then goto, TERMINATE

  <span class="comments">;; Tests for termination and stringent tolerances</span>
  if iter GE maxiter then info = 5
  if (abs(actred) LE MACHEP0) AND (prered LE MACHEP0) $
    AND (0.5*ratio LE 1) then info = 6
  if delta LE MACHEP0*xnorm then info = 7
  if gnorm LE MACHEP0 then info = 8
  if info NE 0 then goto, TERMINATE

  <span class="comments">;; End of inner loop. Repeat if iteration unsuccessful</span>
  if ratio LT 0.0001 then begin
      goto, INNER_LOOP
  endif

  <span class="comments">;; Check for over/underflow</span>
  wh = where(finite(wa1) EQ 0 OR finite(wa2) EQ 0 OR finite(x) EQ 0, ct)
  if ct GT 0 OR finite(ratio) EQ 0 then begin
      FAIL_OVERFLOW:
      errmsg = ('ERROR: parameter or function value(s) have become '+$
                'infinite; check model function for over- '+$
                'and underflow')
      info = -16
      goto, TERMINATE
  endif

  <span class="comments">;; End of outer loop.</span>
  goto, OUTER_LOOP

TERMINATE:
  catch_msg = 'in the termination phase'
  <span class="comments">;; Termination, either normal or user imposed.</span>
  if iflag LT 0 then info = iflag
  iflag = 0
  if n_elements(xnew) EQ 0 then goto, FINAL_RETURN
  if nfree EQ 0 then xnew = xall else xnew[ifree] = x
  if n_elements(qanytied) GT 0 then if qanytied then mpfit_tie, xnew, ptied
  dof = n_elements(fvec) - nfree


  <span class="comments">;; Call the ITERPROC at the end of the fit, if the fit status is</span>
  <span class="comments">;; okay.  Don't call it if the fit failed for some reason.</span>
  if info GT 0 then begin
      
      mperr = 0
      xnew0 = xnew
      
      call_procedure, iterproc, fcn, xnew, iter, fnorm^2, $
        FUNCTARGS=fcnargs, parinfo=parinfo, quiet=quiet, $
        dof=dof, _EXTRA=iterargs
      iflag = mperr

      if iflag LT 0 then begin  
          errmsg = 'WARNING: premature termination by "'+iterproc+'"'
      endif else begin
          <span class="comments">;; If parameters were changed (grrr..) then re-tie</span>
          if max(abs(xnew0-xnew)) GT 0 then begin
              if qanytied then mpfit_tie, xnew, ptied
              x = xnew[ifree]
          endif
      endelse

  endif

  <span class="comments">;; Initialize the number of parameters pegged at a hard limit value</span>
  npegged = 0L
  if n_elements(qanylim) GT 0 then if qanylim then begin
      wh = where((qulim AND (x EQ ulim)) OR $
                 (qllim AND (x EQ llim)), npegged)
  endif

  if fcn NE '(EXTERNAL)' AND nprint GT 0 AND info GT 0 then begin
      catch_msg = 'calling '+fcn
      fvec = mpfit_call(fcn, xnew, _EXTRA=fcnargs)
      catch_msg = 'in the termination phase'
      fnorm = mpfit_enorm(fvec)
  endif

  if n_elements(fnorm) GT 0 AND n_elements(fnorm1) GT 0 then begin
      fnorm = max([fnorm, fnorm1])
      fnorm = fnorm^2.
  endif

  covar = !values.d_nan
  <span class="comments">;; (very carefully) set the covariance matrix COVAR</span>
  if info GT 0 AND NOT keyword_set(nocovar) $
    AND n_elements(n) GT 0 $
    AND n_elements(fjac) GT 0 AND n_elements(ipvt) GT 0 then begin
      sz = size(fjac)
      if n GT 0 AND sz[0] GT 1 AND sz[1] GE n AND sz[2] GE n $
        AND n_elements(ipvt) GE n then begin
          catch_msg = 'computing the covariance matrix'
          if n EQ 1 then $
            cv = mpfit_covar(reform([fjac[0,0]],1,1), ipvt[0]) $
          else $
            cv = mpfit_covar(fjac[0:n-1,0:n-1], ipvt[0:n-1])
          cv = reform(cv, n, n, /overwrite)
          nn = n_elements(xall)
          
          <span class="comments">;; Fill in actual covariance matrix, accounting for fixed</span>
          <span class="comments">;; parameters.</span>
          covar = replicate(zero, nn, nn)
          for i = 0L, n-1 do begin
              covar[ifree, ifree[i]] = cv[*,i]
          end
          
          <span class="comments">;; Compute errors in parameters</span>
          catch_msg = 'computing parameter errors'
          i = lindgen(nn)
          perror = replicate(abs(covar[0])*0., nn)
          wh = where(covar[i,i] GE 0, ct)
          if ct GT 0 then $
            perror[wh] = sqrt(covar[wh, wh])
      endif
  endif
<span class="comments">;  catch_msg = 'returning the result'</span>
<span class="comments">;  profvals.mpfit = profvals.mpfit + (systime(1) - prof_start)</span>

  FINAL_RETURN:
  nfev = mpconfig.nfev
  if n_elements(xnew) EQ 0 then return, !values.d_nan
  return, xnew

  
  <span class="comments">;; ------------------------------------------------------------------</span>
  <span class="comments">;; Alternate ending if the user supplies the function and gradients</span>
  <span class="comments">;; externally</span>
  <span class="comments">;; ------------------------------------------------------------------</span>

  SAVE_STATE:

  catch_msg = 'saving MPFIT state'

  <span class="comments">;; Names of variables to save</span>
  varlist = ['alpha', 'delta', 'diag', 'dwarf', 'factor', 'fnorm', $
             'fjac', 'gnorm', 'nfree', 'ifree', 'ipvt', 'iter', $
             'm', 'n', 'machvals', 'machep0', 'npegged', $
             'whlpeg', 'whupeg', 'nlpeg', 'nupeg', $
             'mpconfig', 'par', 'pnorm', 'qtf', $
             'wa1', 'wa2', 'wa3', 'xnorm', 'x', 'xnew']
  cmd = ''

  <span class="comments">;; Construct an expression that will save them</span>
  for i = 0L, n_elements(varlist)-1 do begin
      ival = 0
      dummy = execute('ival = n_elements('+varlist[i]+')')
      if ival GT 0 then begin
          cmd = cmd + ',' + varlist[i]+':'+varlist[i]
      endif
  endfor
  cmd = 'state = create_struct({'+strmid(cmd,1)+'})'
  state = 0

  if execute(cmd) NE 1 then $
    message, 'ERROR: could not save MPFIT state'

  <span class="comments">;; Set STATUS keyword to prepare for next iteration, and reset init</span>
  <span class="comments">;; so we do not init the next time</span>
  info = 9
  extinit = 0

  return, xnew

end

</code>
    </div>
  </body>
</html>